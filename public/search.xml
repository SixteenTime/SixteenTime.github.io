<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git相关知识点</title>
    <url>/2021/12/21/Git/</url>
    <content><![CDATA[<hr>
<p><em>本文来源于<a href="https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82%E5%B9%B6%E4%B8%94%E5%9B%A0%E4%B8%BA%E6%9C%AC%E6%AC%A1%E5%A4%8D%E4%B9%A0%E6%98%AF%E4%BA%89%E5%AF%B9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E4%BC%9A%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%88%BB%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%AA%E4%BC%9A%E7%B2%97%E7%95%A5%E6%89%AB%E8%BF%87">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过</a></em>。</p>
<hr>
<h2 id="1-集中式与分布式"><a href="#1-集中式与分布式" class="headerlink" title="1.集中式与分布式"></a>1.集中式与分布式</h2><p>Git属于<u>分布式版本控制系统</u>，分布式的好处是每个成员的电脑上都有一份完整代码，而<u>集中式</u>的只有中心服务器才有。并且集中式版本控制系统一旦中心服务器出问题所有成员都无法使用，还必须依赖连网使用，分布式则不存在这些问题。分布式版本控制建立新分支、合并分支操作迅速，集中式新建一个分支相当于复制一份完整代码，操作较慢。</p>
<h2 id="2-中心服务器"><a href="#2-中心服务器" class="headerlink" title="2.中心服务器"></a>2.中心服务器</h2><p>Git的中心服务器是<u>GitHub</u>。中心服务器用来交换成员的修改。</p>
<h2 id="3-工作流"><a href="#3-工作流" class="headerlink" title="3.工作流"></a>3.工作流</h2><p>新建一个目录并且Git初始化后，该目录就成为一个工作仓库。该工作区有一个<code>.git</code>文件夹，它是Git的版本库。Git 的版本库有一个称为 <code>Stage</code> 的暂存区以及最后的 <code>History</code> 版本库，<code>History</code> 存储所有分支信息，使用一个 <code>HEAD</code> 指针指向当前分支。</p>
<p>具体工作流如下图所示：</p>
<p><img src="/images/react/2021122111.png"></p>
<p>执行命令<code>git add files</code> 将仓库内的文件存入<code>Stage</code>缓存区，执行<code>git commit</code>命令将这些存在<code>Stage</code>的文件数据存入<code>History</code>区，此时<code>Stage</code>也被清空。执行命令<code>git reset --files</code>使用当前分支上的修改覆盖暂存区，用来撤销最后一次 <code>git add files</code>，执行命令<code>git checkout --file</code> 使用暂存区的修改覆盖工作目录，用来撤销本地修改。</p>
<h2 id="4-分支实现和冲突"><a href="#4-分支实现和冲突" class="headerlink" title="4.分支实现和冲突"></a>4.分支实现和冲突</h2><p><code>HEAD</code>指针总是指向当前分支指针，在新建分支时，新建的分支指针会指向当前节点，并且<code>HEAD</code>指针指向新分支指针。每次提交只有当前分支指针会改变。</p>
<p>如果两个分支都进行了修改，当它们合并时会产生冲突，必须删除冲突才能进行合并。</p>
<h2 id="5-SSH传输设置"><a href="#5-SSH传输设置" class="headerlink" title="5.SSH传输设置"></a>5.SSH传输设置</h2><p>Git 仓库和 Github 中心仓库之间的传输是通过 SSH 加密。</p>
<p>本地设置SSH Key可以通过命令<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code>来实现。其中出现在<code>.ssh</code>目录的<code>id_rsa.pub</code>里的数据就是SSH的公钥。</p>
<h2 id="6-储存"><a href="#6-储存" class="headerlink" title="6.储存"></a>6.储存</h2><p>在一个分支操作后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也会有修改内容，这是所有分支公用一个工作区的缘故。可以使用命令<code>git stash</code>将当前分支的修改存储起来，此时当前工作区的所有修改都会被存到栈中，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了。</p>
<h2 id="7-Git常用命令"><a href="#7-Git常用命令" class="headerlink" title="7.Git常用命令"></a>7.Git常用命令</h2><p><strong>初始化操作</strong></p>
<p><code>git init</code> 设置本地目录为新的Git仓库</p>
<p><code>git clone [url]</code> 克隆一个代码仓库</p>
<p><strong>增加文件操作</strong></p>
<p><code>git add [file1] [file2]</code> 增加file1、file2到暂存区</p>
<p><code>git add .</code> 将当前目录下全部文件存入暂存区。</p>
<p><strong>删除文件操作</strong></p>
<p><code>git rm [file1] [file2]</code> 删除指定文件，并在暂存区中也删除</p>
<p><strong>代码提交操作</strong></p>
<p><code>git commit -m [message]</code> 提交暂存区到仓库区（History），并备注消息</p>
<p><code>git commit -a</code> 直接从暂存区提交进仓库区</p>
<p><strong>分支相关操作</strong></p>
<p><code>git branch</code> 列出所有本地分支</p>
<p><code>git branch -r</code> 列出所有远程分支</p>
<p><code>git branch -a</code> 列出所有分支，包括本地分支和远程分支。</p>
<p><code>git branch [branch]</code> 新建分支</p>
<p><code>git checkout [branch-name]</code> 切换到指定的分支进行工作</p>
<p><code>git merge [branch]</code> 合并指定分支到当前分支</p>
<p><code>git branch -d [branch-name]</code> 删除指定的本地分支</p>
<p><code>git push origin --delete [branch-name]</code> 删除远程分支</p>
<p><code>git branch -dr [remote/branch]</code> 删除远程分支</p>
<p><strong>查看信息操作</strong></p>
<p><code>git status</code> 显示有变更文件</p>
<p><code>git log</code> 显示当前分支的版本历史</p>
<p><strong>远程同步操作</strong></p>
<p><code>git remote -v</code> 显示所有的远程仓库</p>
<p><code>git remote show [remote]</code> 显示某个远程仓库信息</p>
<p><code>git remote add [remote]</code> 新增某个远程仓库</p>
<p><code>git pull [remote] [branch]</code> 从远程仓库的某一分支拉取到本地</p>
<p><code>git push [remote] [branch]</code> 上传本地指定分支到远程仓库</p>
<p><code>git push -f [remote] [branch]</code> 强制推送当前分支到远程仓库，即使有冲突</p>
<p><code>git push [remote] --all</code> 推送所有分支到远程仓库</p>
<p><strong>撤销操作</strong></p>
<p><code>git checkout [commit] [file]</code> 恢复某个commit的指定文件到暂存区和工作区</p>
<p><code>git reset --hard</code> 重置暂存区与工作区，与上一次commit保持一致</p>
<p><code>git reset [commit]</code> 重置当前分支指针为指定commit，同时重置暂存区，但工作区不变</p>
<p><code>git reset --hard [commit]</code> 重置当前HEAD为指定commit，同时重置暂存区与工作区。</p>
]]></content>
      <categories>
        <category>计算机基础复习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>前端面试，Git</tag>
      </tags>
  </entry>
  <entry>
    <title>React的列表和表单</title>
    <url>/2021/12/19/React%E5%AD%A6%E4%B9%A0%E4%B8%89/</url>
    <content><![CDATA[<h3 id="一、使用map来进行列表渲染"><a href="#一、使用map来进行列表渲染" class="headerlink" title="一、使用map来进行列表渲染"></a>一、使用map来进行列表渲染</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>		<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">		<span class="hljs-comment">//通过map的方式渲染列表</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">List</span>(<span class="hljs-params">props</span>)</span>&#123;</span><br><span class="javascript">			<span class="hljs-comment">//获取列表参数</span></span><br><span class="javascript">			<span class="hljs-keyword">const</span> numbers=props.numbers;</span><br><span class="javascript">			<span class="hljs-comment">//利用map进行渲染</span></span><br><span class="javascript">			<span class="hljs-keyword">const</span> listItem=numbers.map((<span class="hljs-function"><span class="hljs-params">number</span>=&gt;</span></span><br><span class="javascript">			<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;number&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>));</span><br><span class="javascript">			</span><br><span class="javascript">			<span class="hljs-keyword">return</span> (</span><br><span class="javascript">			  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItem&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></span><br><span class="javascript">			)</span><br><span class="javascript">		&#125;</span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-keyword">const</span> numbers=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];</span><br><span class="javascript">		ReactDOM.render(</span><br><span class="javascript">		<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">numbers</span>=<span class="hljs-string">&#123;numbers&#125;</span> /&gt;</span></span>,</span><br><span class="javascript">		<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test1&#x27;</span>))</span><br><span class="javascript"></span><br><span class="javascript">		</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>运行以上代码，发现已成功渲染列表，但是在控制台获得警告如下：</p>
<p><img src="/images/react/2021121903.png"></p>
<p>提示对于列表的每一个元素都需要key关键词，给每一列添加key:<code>&lt;li key=&#123;number.toString()&#125;&gt;&#123;number&#125;&lt;/li&gt;));</code>，key作为列表中每个元素的唯一标识符，是有优化性能的作用。对于应该在哪里设置元素的key，一个好的经验法则是：在 <code>map()</code> 方法中的元素需要设置 key 属性。</p>
<p>以上情况可以也通过以下方法实现</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx">funtion <span class="hljs-function"><span class="hljs-title">ListItem</span>(<span class="hljs-params">props</span>)</span>&#123;<br>			<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;props.value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&#125;<br>		<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">List2</span>(<span class="hljs-params">props</span>)</span>&#123;<br>	<span class="hljs-keyword">const</span> numbers=props.numbers;<br>	<span class="hljs-keyword">return</span> (<br>		 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">			&#123;numbers.map((number=&gt;</span><br><span class="xml">			<span class="hljs-tag">&lt;<span class="hljs-name">ListItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;number.toString()&#125;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;number&#125;</span> /&gt;</span></span><br><span class="xml">			))&#125;</span><br><span class="xml">		<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>	)<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="二、表单"><a href="#二、表单" class="headerlink" title="二、表单"></a>二、表单</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>		<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">		<span class="hljs-comment">//表单的运用</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">//自定义表单组件</span></span><br><span class="javascript">		<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">super</span>(props);</span><br><span class="javascript">				<span class="hljs-comment">//定义可更改的变量，即表单输入元素</span></span><br><span class="javascript">				<span class="hljs-built_in">this</span>.state=&#123;<span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;&#x27;</span>&#125;;</span><br><span class="javascript">				<span class="hljs-comment">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleChange=<span class="hljs-built_in">this</span>.handleChange.bind(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleSubmit=<span class="hljs-built_in">this</span>.handleSubmit.bind(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleChange</span>(<span class="hljs-params">event</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">value</span>:event.target.value&#125;);</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleSubmit</span>(<span class="hljs-params">event</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-comment">//提交前显示名字</span></span><br><span class="javascript">				alert(<span class="hljs-string">&#x27;提交的名字：&#x27;</span>+<span class="hljs-built_in">this</span>.state.value);</span><br><span class="javascript">				event.preventDefault();</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-keyword">return</span>(</span><br><span class="javascript">				  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">				    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">					  名字:</span></span><br><span class="xml"><span class="javascript">					  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="xml"><span class="javascript">					 <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">					  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">					<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>  </span><br><span class="javascript">				)</span><br><span class="javascript">			&#125;</span><br><span class="javascript">		&#125;</span><br><span class="javascript">		ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">NameForm</span> /&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test1&#x27;</span>))</span><br><span class="javascript"></span><br><span class="javascript">		</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>以上例子实现了一个自定义表单的应用。</p>
<p>注意：在Html中<code>&lt;textarea&gt;</code> 组件直接通过子元素定义其文本，而在React中通过属性value来确定其文本。针对<code>&lt;select&gt;</code>组件React 并不会使用 <code>selected</code> 属性，而是在根 <code>select</code> 标签上使用 <code>value</code> 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。</p>
<p>具体关于textarea 和select在React里的具体操作如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>		<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">		<span class="hljs-comment">//表单的运用</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">//自定义表单组件</span></span><br><span class="javascript">		<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">super</span>(props);</span><br><span class="javascript">				<span class="hljs-comment">//定义可更改的变量，即表单输入元素</span></span><br><span class="javascript">				<span class="hljs-built_in">this</span>.state=&#123;</span><br><span class="javascript">					<span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="javascript">					<span class="hljs-attr">textValue</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="javascript">					<span class="hljs-attr">selected</span>:<span class="hljs-string">&#x27;aa&#x27;</span>,</span><br><span class="javascript">				&#125;;</span><br><span class="javascript">				<span class="hljs-comment">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleChange=<span class="hljs-built_in">this</span>.handleChange.bind(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleSubmit=<span class="hljs-built_in">this</span>.handleSubmit.bind(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleChangeSelect=<span class="hljs-built_in">this</span>.handleChangeSelect.bind(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleChangeTextarea=<span class="hljs-built_in">this</span>.handleChangeTextarea.bind(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleChange</span>(<span class="hljs-params">event</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">value</span>:event.target.value&#125;);</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleSubmit</span>(<span class="hljs-params">event</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-comment">//提交前显示名字</span></span><br><span class="javascript">				alert(<span class="hljs-string">&#x27;提交的名字：&#x27;</span>+<span class="hljs-built_in">this</span>.state.value);</span><br><span class="javascript">				event.preventDefault();</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleChangeTextarea</span>(<span class="hljs-params">event</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">textValue</span>:event.target.value&#125;)</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleChangeSelect</span>(<span class="hljs-params">event</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;event&#x27;</span>,event)</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">selected</span>:event.target.value&#125;);</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-keyword">return</span>(</span><br><span class="javascript">				  &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="javascript">				    &lt;label&gt;</span><br><span class="javascript">					  名字:</span><br><span class="javascript">					  &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="javascript">					 &lt;/label&gt;</span><br><span class="javascript">					 &lt;label&gt;</span><br><span class="javascript">						 内容：</span><br><span class="javascript">						 &lt;textarea  value=&#123;this.state.textValue&#125; onChange=&#123;this.handleChangeTextarea&#125;/&gt;</span><br><span class="javascript">					 &lt;/label&gt;</span><br><span class="javascript">					 &lt;label&gt;</span><br><span class="javascript">					 	选择：</span><br><span class="javascript">					 	&lt;select value=&#123;this.state.selected&#125; onChange=&#123;this.handleChangeSelect&#125; &gt;</span><br><span class="javascript">					 	    &lt;option value=&#x27;aa&#x27;&gt;aa&lt;/ option&gt;</span><br><span class="javascript">					 		&lt;option value=&#x27;bb&#x27;&gt;bb&lt;/ option&gt;</span><br><span class="javascript">					 		&lt;option value=&#x27;cc&#x27;&gt;cc&lt;/ option&gt;</span><br><span class="javascript">					 	&lt;/select&gt;</span><br><span class="javascript">					 &lt;/label&gt;</span><br><span class="javascript">					  &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="javascript">					&lt;/form&gt;  </span><br><span class="javascript">				)</span><br><span class="javascript">			&#125;</span><br><span class="javascript">		&#125;</span><br><span class="javascript">		ReactDOM.render(&lt;NameForm /&gt;,document.getElementById(&#x27;test1&#x27;))</span><br><span class="javascript"></span><br><span class="javascript">		</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>以上的形式在一个表单中调用了多个onChange，也可以只调用同一个onChange函数同时监听并改变多个数据，可以给每个元素添加 <code>name</code> 属性，并让处理函数根据 <code>event.target.name</code> 的值选择要执行的操作。具体代码如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>		<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">		<span class="hljs-comment">//表单的运用</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">//自定义表单组件</span></span><br><span class="javascript">		<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">super</span>(props);</span><br><span class="javascript">				<span class="hljs-comment">//定义可更改的变量，即表单输入元素</span></span><br><span class="javascript">				<span class="hljs-built_in">this</span>.state=&#123;</span><br><span class="javascript">					<span class="hljs-attr">nameValue</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="javascript">					<span class="hljs-attr">textValue</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="javascript">					<span class="hljs-attr">selected</span>:<span class="hljs-string">&#x27;aa&#x27;</span>,</span><br><span class="javascript">				&#125;;</span><br><span class="javascript">				<span class="hljs-comment">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleChange=<span class="hljs-built_in">this</span>.handleChange.bind(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleSubmit=<span class="hljs-built_in">this</span>.handleSubmit.bind(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleChange</span>(<span class="hljs-params">event</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-keyword">const</span> value=event.target.value;</span><br><span class="javascript">				<span class="hljs-keyword">const</span> name=event.target.name;</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.setState(&#123;</span><br><span class="javascript">					[name]:value</span><br><span class="javascript">				&#125;)</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleSubmit</span>(<span class="hljs-params">event</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-comment">//提交前显示名字</span></span><br><span class="javascript">				alert(<span class="hljs-string">&#x27;提交的名字：&#x27;</span>+<span class="hljs-built_in">this</span>.state.value);</span><br><span class="javascript">				<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;state&#x27;</span>,<span class="hljs-built_in">this</span>.state)</span><br><span class="javascript">				event.preventDefault();</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-keyword">return</span>(</span><br><span class="javascript">				  &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="javascript">				    &lt;label&gt;</span><br><span class="javascript">					  名字:</span><br><span class="javascript">					  &lt;input name=&quot;nameValue&quot; type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="javascript">					 &lt;/label&gt;</span><br><span class="javascript">					 &lt;label&gt;</span><br><span class="javascript">						 内容：</span><br><span class="javascript">						 &lt;textarea name=&quot;textValue&quot;  value=&#123;this.state.textValue&#125; onChange=&#123;this.handleChange&#125;/&gt;</span><br><span class="javascript">					 &lt;/label&gt;</span><br><span class="javascript">					 &lt;label&gt;</span><br><span class="javascript">					 	选择：</span><br><span class="javascript">					 	&lt;select name=&quot;selected&quot; value=&#123;this.state.selected&#125; onChange=&#123;this.handleChange&#125; &gt;</span><br><span class="javascript">					 	    &lt;option value=&#x27;aa&#x27;&gt;aa&lt;/ option&gt;</span><br><span class="javascript">					 		&lt;option value=&#x27;bb&#x27;&gt;bb&lt;/ option&gt;</span><br><span class="javascript">					 		&lt;option value=&#x27;cc&#x27;&gt;cc&lt;/ option&gt;</span><br><span class="javascript">					 	&lt;/select&gt;</span><br><span class="javascript">					 &lt;/label&gt;</span><br><span class="javascript">					  &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="javascript">					&lt;/form&gt;  </span><br><span class="javascript">				)</span><br><span class="javascript">			&#125;</span><br><span class="javascript">		&#125;</span><br><span class="javascript">		ReactDOM.render(&lt;NameForm /&gt;,document.getElementById(&#x27;test1&#x27;))</span><br><span class="javascript"></span><br><span class="javascript">		</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React的认识与初步尝试</title>
    <url>/2021/12/19/React%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
    <content><![CDATA[<h3 id="一、React是什么"><a href="#一、React是什么" class="headerlink" title="一、React是什么"></a>一、React是什么</h3><p>一个JavaScipt库，配合JSX（一个JavaScipt语法扩展）能够更好描述UI应该呈现的交互本质形式。</p>
<h3 id="二、初步使用React实例"><a href="#二、初步使用React实例" class="headerlink" title="二、初步使用React实例"></a>二、初步使用React实例</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-comment">&lt;!-- 上面两个Js文件是有固定的引用先后顺序 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>		<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">name</span>)</span>&#123;</span><br><span class="javascript">			<span class="hljs-keyword">return</span> name+<span class="hljs-string">&#x27; hh&#x27;</span>;</span><br><span class="javascript">		&#125;</span><br><span class="javascript">		<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloMsg</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-keyword">return</span> (</span><br><span class="javascript">				<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">				  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello React<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">				  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">				  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;2+3&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">				  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;fun(&#x27;abc&#x27;)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">				<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="javascript">				)</span><br><span class="javascript">			&#125;</span><br><span class="javascript">		&#125;</span><br><span class="javascript">		ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">HelloMsg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hhh&quot;</span>/&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;test1&quot;</span>))</span><br><span class="javascript"></span><br><span class="javascript">		</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>第一步：导入相关js文件</p>
<p>第二步：在body中定义需要渲染的元素</p>
<p>第三步：在js区域自定义组件，并调用<code>ReactDOM.render</code>进行元素渲染。</p>
<p>之后仔细分析js部分代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">name</span>)</span>&#123;<br>			<span class="hljs-keyword">return</span> name+<span class="hljs-string">&#x27; hh&#x27;</span>;<br>	&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloMsg</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;<br>	<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>		<span class="hljs-keyword">return</span> (<br>			<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">		      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello React<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">			  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="xml">			  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;2+3&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">		      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;fun(&#x27;abc&#x27;)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">			<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>			)<br>		&#125;<br>	&#125;<br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">HelloMsg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hhh&quot;</span>/&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;test1&quot;</span>))<br></code></pre></td></tr></table></figure>

<p>在方法<code>ReactDOM.render(element, document.getElementById(&#39;root&#39;));</code>为将自定义的元素<code>element</code>覆盖html中id为root的块元素。因为覆盖Html中的元素只有一个，所以返回的也是一个块元素，里面可以包裹很多小元素，在使用html元素时使用js相关只要使用<code>&#123;&#125;</code>就可以。而元素传参运用<code>this.props</code>来进行传输。</p>
<p>React元素不可修改，更新的方法只能是创建一个新的元素传入ReactDOM.render</p>
<p>React 只更新它需要更新的部分,尽管每一秒我们都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容，也就是例子中的文本节点。</p>
<h3 id="三、定义React元素"><a href="#三、定义React元素" class="headerlink" title="三、定义React元素"></a>三、定义React元素</h3><p>可以通过以下方法自定义元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//自定义元素element</span><br><span class="hljs-keyword">const</span> element = (<br>	<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">		<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>h1h1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">		<span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>h2h2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">	<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br>ReactDOM.render(element,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;test1&quot;</span>))<br></code></pre></td></tr></table></figure>

<h3 id="四、自定义组件"><a href="#四、自定义组件" class="headerlink" title="四、自定义组件"></a>四、自定义组件</h3><p>React可以自定义复杂的组件，有两种自定义组件的方法，分别是函数的方法和类的方法。如下例所示：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 用函数的方式自定义组件</span><br>function <span class="hljs-type">HelloMsg</span>(props)&#123;<br>	<span class="hljs-keyword">return</span> &lt;h1&gt;hello~ &#123;props.name&#125; !&lt;/h1&gt;<br>&#125;<br><span class="hljs-comment">// ES6的类自定义组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HiMsg</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;<br>	render()&#123;<br>			<span class="hljs-keyword">return</span> &lt;h2&gt;hi~ &#123;<span class="hljs-keyword">this</span>.props.name&#125;&lt;/h2&gt;<br>	&#125;	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中，函数方法的元素传参方式和类的元素传参方式有所区别。</p>
<p>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</p>
<p>自定义组件还可以组合使用，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-comment">&lt;!-- 上面两个Js文件是有固定的引用先后顺序 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>		<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">		<span class="hljs-comment">// 组合组件</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">// 用函数的方式自定义组件</span></span><br><span class="javascript">		<span class="hljs-comment">// 自定义组件可以实现交互传参</span></span><br><span class="javascript">		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HelloMsg</span>(<span class="hljs-params">props</span>)</span>&#123;</span><br><span class="javascript">			<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello~ &#123;props.name&#125; !<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></span><br><span class="javascript">		&#125;</span><br><span class="javascript">		<span class="hljs-comment">// ES6的类自定义组件</span></span><br><span class="javascript">		<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HiMsg</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>hi~ &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><br><span class="javascript">			&#125;</span><br><span class="javascript">			</span><br><span class="javascript">		&#125;</span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">// 组合组件</span></span><br><span class="javascript">		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">			<span class="hljs-keyword">return</span> (</span><br><span class="javascript">			  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">				  <span class="hljs-tag">&lt;<span class="hljs-name">HelloMsg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;zhangsan&quot;</span>/&gt;</span></span></span><br><span class="xml"><span class="javascript">				  <span class="hljs-tag">&lt;<span class="hljs-name">HiMsg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;zhangsan&quot;</span>/&gt;</span></span></span><br><span class="xml"><span class="javascript">				  <span class="hljs-tag">&lt;<span class="hljs-name">HelloMsg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Mody&quot;</span>/&gt;</span></span></span><br><span class="xml"><span class="javascript">				  <span class="hljs-tag">&lt;<span class="hljs-name">HiMsg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Mody&quot;</span>/&gt;</span></span></span><br><span class="xml"><span class="javascript">				  <span class="hljs-tag">&lt;<span class="hljs-name">HelloMsg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Recy&quot;</span>/&gt;</span></span></span><br><span class="xml"><span class="javascript">				  <span class="hljs-tag">&lt;<span class="hljs-name">HiMsg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Recy&quot;</span>/&gt;</span></span></span><br><span class="xml"><span class="javascript">			  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="javascript">			)</span><br><span class="javascript">		&#125;</span><br><span class="javascript">		ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;test1&quot;</span>))</span><br><span class="javascript"></span><br><span class="javascript">		</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React的数据更新和监听事件</title>
    <url>/2021/12/19/React%E5%AD%A6%E4%B9%A0%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="一、使用state实现更新React组件数据"><a href="#一、使用state实现更新React组件数据" class="headerlink" title="一、使用state实现更新React组件数据"></a>一、使用state实现更新React组件数据</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-comment">&lt;!-- 上面两个Js文件是有固定的引用先后顺序 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>		<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">		<span class="hljs-comment">// 使用state实现更新React组件数据</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">// 利用class定义自定义组件</span></span><br><span class="javascript">		<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;</span><br><span class="javascript">			<span class="hljs-comment">//调用父类构造器</span></span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;</span><br><span class="javascript">			    <span class="hljs-built_in">super</span>(props);</span><br><span class="javascript">			    <span class="hljs-comment">//定义state内的数据</span></span><br><span class="javascript">				<span class="hljs-built_in">this</span>.state=&#123;<span class="hljs-attr">data</span>:<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;;</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			</span><br><span class="javascript">			<span class="hljs-comment">//生命周期函数：挂载完成时，每一秒调用tick函数，即每一秒改变stata内data的数据。</span></span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.timeID=<span class="hljs-built_in">setInterval</span>(</span><br><span class="javascript">				<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">this</span>.tick(),<span class="hljs-number">1000</span></span><br><span class="javascript">				)</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-comment">//生命周期函数：即将卸载时</span></span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">clearInterval</span>(<span class="hljs-built_in">this</span>.timeID);</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			</span><br><span class="javascript">		    <span class="hljs-function"><span class="hljs-title">tick</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.setState(&#123;</span><br><span class="javascript">					<span class="hljs-attr">data</span>:<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()</span><br><span class="javascript">				&#125;);</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-keyword">return</span> (</span><br><span class="javascript">				    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">				        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello!!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">					    <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>It is &#123;this.state.data.toLocaleTimeString()&#125; .<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">				    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="javascript">				)</span><br><span class="javascript">			&#125;</span><br><span class="javascript">		&#125;</span><br><span class="javascript">		ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;test1&quot;</span>))</span><br><span class="javascript">	</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>以上为一个时钟渲染实例，通过state和生命周期的使用来实时完成时钟的运行。</p>
<p>构造函数是唯一可以给 <code>this.state</code> 赋值的地方，使用 <code>setState()</code>修改state里的数据</p>
<p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用，因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p>
<h3 id="二、监听事件"><a href="#二、监听事件" class="headerlink" title="二、监听事件"></a>二、监听事件</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-comment">&lt;!-- 上面两个Js文件是有固定的引用先后顺序 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>		<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">		<span class="hljs-comment">//监听事件</span></span><br><span class="javascript">		<span class="hljs-comment">//实时切换一个按钮的状态</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">//定义一个按钮组件</span></span><br><span class="javascript">		<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;</span><br><span class="javascript">		    <span class="hljs-comment">//因为设计到React.Component里的一些特性，所以需要构造器继承父类构造器</span></span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;</span><br><span class="javascript">			    <span class="hljs-built_in">super</span>(props);</span><br><span class="javascript">				<span class="hljs-comment">//state里的数据可以更新修改，相当于Vue里的data</span></span><br><span class="javascript">				<span class="hljs-built_in">this</span>.state=&#123;</span><br><span class="javascript">					<span class="hljs-attr">isToggleOn</span>:<span class="hljs-literal">true</span>,</span><br><span class="javascript">					<span class="hljs-attr">data1</span>:<span class="hljs-string">&#x27;haha&#x27;</span>,</span><br><span class="javascript">				&#125;</span><br><span class="javascript">				</span><br><span class="javascript">				<span class="hljs-comment">//为了在该类的方法中调用this.setState来改变state里的数据来实现实时监听，所以，要在构造器里提前将需要的方法绑定this</span></span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleClick=<span class="hljs-built_in">this</span>.handleClick.bind(<span class="hljs-built_in">this</span>)</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			</span><br><span class="javascript">			<span class="hljs-comment">//该方法来实现实时切换</span></span><br><span class="javascript">			<span class="hljs-comment">//若前面没有绑定this，则该方法里的this指向underfined</span></span><br><span class="javascript">			<span class="hljs-comment">//prevState是state原先的状态</span></span><br><span class="javascript">			<span class="hljs-comment">//这里的=&gt;(&#123;...&#125;)等价于=&gt;&#123;return (&#123;...&#125;)&#125;</span></span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleClick</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.setState(<span class="hljs-function"><span class="hljs-params">prevState</span>=&gt;</span>(&#123;</span><br><span class="javascript">					<span class="hljs-attr">isToggleOn</span>:!prevState.isToggleOn</span><br><span class="javascript">				&#125;))</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			</span><br><span class="javascript">			<span class="hljs-comment">// 下面的方法显示打印出prevState的数据</span></span><br><span class="javascript">			<span class="hljs-comment">// handleClick()&#123;</span></span><br><span class="javascript">			<span class="hljs-comment">// 	this.setState(prevState=&gt;&#123;</span></span><br><span class="javascript">			<span class="hljs-comment">// 		console.log(&#x27;prevState&#x27;,prevState)</span></span><br><span class="javascript">			<span class="hljs-comment">// 		return (&#123;</span></span><br><span class="javascript">			<span class="hljs-comment">// 			isToggleOn:!prevState.isToggleOn</span></span><br><span class="javascript">			<span class="hljs-comment">// 		&#125;)</span></span><br><span class="javascript">			<span class="hljs-comment">// 	&#125;)</span></span><br><span class="javascript">			<span class="hljs-comment">// &#125;</span></span><br><span class="javascript">			</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-keyword">return</span> (</span><br><span class="javascript">				    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">					    &#123;this.state.isToggleOn?&#x27;ON&#x27;:&#x27;OFF&#x27;&#125;</span></span><br><span class="xml"><span class="javascript">					<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span></span><br><span class="javascript">				)</span><br><span class="javascript">			&#125;</span><br><span class="javascript">		&#125;</span><br><span class="javascript">		</span><br><span class="javascript">		ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button1</span> /&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;test1&quot;</span>))</span><br><span class="javascript"></span><br><span class="javascript">		</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>以上例子实现了实时监控切换一个按钮状态。</p>
<p>在 React 中另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code>。</p>
<h3 id="三、条件渲染"><a href="#三、条件渲染" class="headerlink" title="三、条件渲染"></a>三、条件渲染</h3><p>可以通过以下方法自定义元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-comment">&lt;!-- 上面两个Js文件是有固定的引用先后顺序 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>		<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">		<span class="hljs-comment">//条件渲染</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">//用函数定义的方式实现子组件的定义</span></span><br><span class="javascript">		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SonDiv</span>(<span class="hljs-params">props</span>)</span>&#123;</span><br><span class="javascript">			<span class="hljs-comment">//若isShow=false,则返回null，即该组件不会渲染，会被隐藏</span></span><br><span class="javascript">			<span class="hljs-keyword">if</span>(!props.isShow)&#123;</span><br><span class="javascript">				<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-keyword">return</span> (</span><br><span class="javascript">			    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Son is Show<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="javascript">			)</span><br><span class="javascript">		&#125;</span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">//用类的方式实现父组件的定义</span></span><br><span class="javascript">		<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FatherDiv</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;</span><br><span class="javascript">			    <span class="hljs-built_in">super</span>(props)</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.state=&#123;<span class="hljs-attr">isShow</span>:<span class="hljs-literal">true</span>&#125;</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleToggleChilk=<span class="hljs-built_in">this</span>.handleToggleChilk.bind(<span class="hljs-built_in">this</span>)</span><br><span class="javascript">				</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleToggleChilk</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.setState(<span class="hljs-function"><span class="hljs-params">prevState</span>=&gt;</span>(&#123;</span><br><span class="javascript">					<span class="hljs-attr">isShow</span>:!prevState.isShow</span><br><span class="javascript">				&#125;))</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-keyword">return</span> (</span><br><span class="javascript">				    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">						<span class="hljs-tag">&lt;<span class="hljs-name">SonDiv</span> <span class="hljs-attr">isShow</span>=<span class="hljs-string">&#123;this.state.isShow&#125;</span> /&gt;</span></span></span><br><span class="xml"><span class="javascript">						<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleToggleChilk&#125;</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">							&#123;this.state.isShow?&#x27;hide&#x27;:&#x27;show&#x27;&#125;</span></span><br><span class="xml"><span class="javascript">						<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">					<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="javascript">				)</span><br><span class="javascript">			&#125;</span><br><span class="javascript">		&#125;</span><br><span class="javascript">		</span><br><span class="javascript">		ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">FatherDiv</span> /&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;test1&quot;</span>))</span><br><span class="javascript"></span><br><span class="javascript">		</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>以上案例实现了一个监控+条件渲染的案例，初始状态为：</p>
<p><img src="/images/react/2021121901.png"></p>
<p>点击按钮’hide’，则会隐藏子组件并且按钮内容改为’show’，点击’show’则会回到初始状态即显示子组件。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React的状态提升&amp;组合VS继承</title>
    <url>/2021/12/19/React%E5%AD%A6%E4%B9%A0%E5%9B%9B/</url>
    <content><![CDATA[<h3 id="一、状态提升"><a href="#一、状态提升" class="headerlink" title="一、状态提升"></a>一、状态提升</h3><p>通常，多个组件需要反应同一个数据变化时，建议使用状态提升，即共享状态提升到最近的父组件中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>		<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">		<span class="hljs-comment">//通过map的方式渲染列表</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">List</span>(<span class="hljs-params">props</span>)</span>&#123;</span><br><span class="javascript">			<span class="hljs-comment">//获取列表参数</span></span><br><span class="javascript">			<span class="hljs-keyword">const</span> numbers=props.numbers;</span><br><span class="javascript">			<span class="hljs-comment">//利用map进行渲染</span></span><br><span class="javascript">			<span class="hljs-keyword">const</span> listItem=numbers.map((<span class="hljs-function"><span class="hljs-params">number</span>=&gt;</span></span><br><span class="javascript">			<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;number&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>));</span><br><span class="javascript">			</span><br><span class="javascript">			<span class="hljs-keyword">return</span> (</span><br><span class="javascript">			  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItem&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></span><br><span class="javascript">			)</span><br><span class="javascript">		&#125;</span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-keyword">const</span> numbers=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];</span><br><span class="javascript">		ReactDOM.render(</span><br><span class="javascript">		<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">numbers</span>=<span class="hljs-string">&#123;numbers&#125;</span> /&gt;</span></span>,</span><br><span class="javascript">		<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test1&#x27;</span>))</span><br><span class="javascript"></span><br><span class="javascript">		</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>运行以上代码，发现已成功渲染列表，但是在控制台获得警告如下：</p>
<p><img src="/images/react/2021121903.png"></p>
<p>提示对于列表的每一个元素都需要key关键词，给每一列添加key:<code>&lt;li key=&#123;number.toString()&#125;&gt;&#123;number&#125;&lt;/li&gt;));</code>，key作为列表中每个元素的唯一标识符，是有优化性能的作用。对于应该在哪里设置元素的key，一个好的经验法则是：在 <code>map()</code> 方法中的元素需要设置 key 属性。</p>
<p>以上情况可以也通过以下方法实现</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx">funtion <span class="hljs-function"><span class="hljs-title">ListItem</span>(<span class="hljs-params">props</span>)</span>&#123;<br>			<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;props.value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&#125;<br>		<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">List2</span>(<span class="hljs-params">props</span>)</span>&#123;<br>	<span class="hljs-keyword">const</span> numbers=props.numbers;<br>	<span class="hljs-keyword">return</span> (<br>		 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">			&#123;numbers.map((number=&gt;</span><br><span class="xml">			<span class="hljs-tag">&lt;<span class="hljs-name">ListItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;number.toString()&#125;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;number&#125;</span> /&gt;</span></span><br><span class="xml">			))&#125;</span><br><span class="xml">		<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>	)<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="二、表单"><a href="#二、表单" class="headerlink" title="二、表单"></a>二、表单</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>		<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">		<span class="hljs-comment">//表单的运用</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">//自定义表单组件</span></span><br><span class="javascript">		<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">super</span>(props);</span><br><span class="javascript">				<span class="hljs-comment">//定义可更改的变量，即表单输入元素</span></span><br><span class="javascript">				<span class="hljs-built_in">this</span>.state=&#123;<span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;&#x27;</span>&#125;;</span><br><span class="javascript">				<span class="hljs-comment">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleChange=<span class="hljs-built_in">this</span>.handleChange.bind(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleSubmit=<span class="hljs-built_in">this</span>.handleSubmit.bind(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleChange</span>(<span class="hljs-params">event</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">value</span>:event.target.value&#125;);</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleSubmit</span>(<span class="hljs-params">event</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-comment">//提交前显示名字</span></span><br><span class="javascript">				alert(<span class="hljs-string">&#x27;提交的名字：&#x27;</span>+<span class="hljs-built_in">this</span>.state.value);</span><br><span class="javascript">				event.preventDefault();</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-keyword">return</span>(</span><br><span class="javascript">				  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">				    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">					  名字:</span></span><br><span class="xml"><span class="javascript">					  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="xml"><span class="javascript">					 <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">					  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span></span><br><span class="xml"><span class="javascript">					<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>  </span><br><span class="javascript">				)</span><br><span class="javascript">			&#125;</span><br><span class="javascript">		&#125;</span><br><span class="javascript">		ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">NameForm</span> /&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test1&#x27;</span>))</span><br><span class="javascript"></span><br><span class="javascript">		</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>以上例子实现了一个自定义表单的应用。</p>
<p>注意：在Html中<code>&lt;textarea&gt;</code> 组件直接通过子元素定义其文本，而在React中通过属性value来确定其文本。针对<code>&lt;select&gt;</code>组件React 并不会使用 <code>selected</code> 属性，而是在根 <code>select</code> 标签上使用 <code>value</code> 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。</p>
<p>具体关于textarea 和select在React里的具体操作如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>		<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">		<span class="hljs-comment">//表单的运用</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">//自定义表单组件</span></span><br><span class="javascript">		<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">super</span>(props);</span><br><span class="javascript">				<span class="hljs-comment">//定义可更改的变量，即表单输入元素</span></span><br><span class="javascript">				<span class="hljs-built_in">this</span>.state=&#123;</span><br><span class="javascript">					<span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="javascript">					<span class="hljs-attr">textValue</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="javascript">					<span class="hljs-attr">selected</span>:<span class="hljs-string">&#x27;aa&#x27;</span>,</span><br><span class="javascript">				&#125;;</span><br><span class="javascript">				<span class="hljs-comment">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleChange=<span class="hljs-built_in">this</span>.handleChange.bind(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleSubmit=<span class="hljs-built_in">this</span>.handleSubmit.bind(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleChangeSelect=<span class="hljs-built_in">this</span>.handleChangeSelect.bind(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleChangeTextarea=<span class="hljs-built_in">this</span>.handleChangeTextarea.bind(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleChange</span>(<span class="hljs-params">event</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">value</span>:event.target.value&#125;);</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleSubmit</span>(<span class="hljs-params">event</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-comment">//提交前显示名字</span></span><br><span class="javascript">				alert(<span class="hljs-string">&#x27;提交的名字：&#x27;</span>+<span class="hljs-built_in">this</span>.state.value);</span><br><span class="javascript">				event.preventDefault();</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleChangeTextarea</span>(<span class="hljs-params">event</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">textValue</span>:event.target.value&#125;)</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleChangeSelect</span>(<span class="hljs-params">event</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;event&#x27;</span>,event)</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">selected</span>:event.target.value&#125;);</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-keyword">return</span>(</span><br><span class="javascript">				  &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="javascript">				    &lt;label&gt;</span><br><span class="javascript">					  名字:</span><br><span class="javascript">					  &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="javascript">					 &lt;/label&gt;</span><br><span class="javascript">					 &lt;label&gt;</span><br><span class="javascript">						 内容：</span><br><span class="javascript">						 &lt;textarea  value=&#123;this.state.textValue&#125; onChange=&#123;this.handleChangeTextarea&#125;/&gt;</span><br><span class="javascript">					 &lt;/label&gt;</span><br><span class="javascript">					 &lt;label&gt;</span><br><span class="javascript">					 	选择：</span><br><span class="javascript">					 	&lt;select value=&#123;this.state.selected&#125; onChange=&#123;this.handleChangeSelect&#125; &gt;</span><br><span class="javascript">					 	    &lt;option value=&#x27;aa&#x27;&gt;aa&lt;/ option&gt;</span><br><span class="javascript">					 		&lt;option value=&#x27;bb&#x27;&gt;bb&lt;/ option&gt;</span><br><span class="javascript">					 		&lt;option value=&#x27;cc&#x27;&gt;cc&lt;/ option&gt;</span><br><span class="javascript">					 	&lt;/select&gt;</span><br><span class="javascript">					 &lt;/label&gt;</span><br><span class="javascript">					  &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="javascript">					&lt;/form&gt;  </span><br><span class="javascript">				)</span><br><span class="javascript">			&#125;</span><br><span class="javascript">		&#125;</span><br><span class="javascript">		ReactDOM.render(&lt;NameForm /&gt;,document.getElementById(&#x27;test1&#x27;))</span><br><span class="javascript"></span><br><span class="javascript">		</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>以上的形式在一个表单中调用了多个onChange，也可以只调用同一个onChange函数同时监听并改变多个数据，可以给每个元素添加 <code>name</code> 属性，并让处理函数根据 <code>event.target.name</code> 的值选择要执行的操作。具体代码如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>		<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">		<span class="hljs-comment">//表单的运用</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class="javascript">		</span><br><span class="javascript">		<span class="hljs-comment">//自定义表单组件</span></span><br><span class="javascript">		<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-built_in">super</span>(props);</span><br><span class="javascript">				<span class="hljs-comment">//定义可更改的变量，即表单输入元素</span></span><br><span class="javascript">				<span class="hljs-built_in">this</span>.state=&#123;</span><br><span class="javascript">					<span class="hljs-attr">nameValue</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="javascript">					<span class="hljs-attr">textValue</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="javascript">					<span class="hljs-attr">selected</span>:<span class="hljs-string">&#x27;aa&#x27;</span>,</span><br><span class="javascript">				&#125;;</span><br><span class="javascript">				<span class="hljs-comment">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleChange=<span class="hljs-built_in">this</span>.handleChange.bind(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.handleSubmit=<span class="hljs-built_in">this</span>.handleSubmit.bind(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleChange</span>(<span class="hljs-params">event</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-keyword">const</span> value=event.target.value;</span><br><span class="javascript">				<span class="hljs-keyword">const</span> name=event.target.name;</span><br><span class="javascript">				<span class="hljs-built_in">this</span>.setState(&#123;</span><br><span class="javascript">					[name]:value</span><br><span class="javascript">				&#125;)</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">handleSubmit</span>(<span class="hljs-params">event</span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-comment">//提交前显示名字</span></span><br><span class="javascript">				alert(<span class="hljs-string">&#x27;提交的名字：&#x27;</span>+<span class="hljs-built_in">this</span>.state.value);</span><br><span class="javascript">				<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;state&#x27;</span>,<span class="hljs-built_in">this</span>.state)</span><br><span class="javascript">				event.preventDefault();</span><br><span class="javascript">			&#125;</span><br><span class="javascript">			<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">				<span class="hljs-keyword">return</span>(</span><br><span class="javascript">				  &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="javascript">				    &lt;label&gt;</span><br><span class="javascript">					  名字:</span><br><span class="javascript">					  &lt;input name=&quot;nameValue&quot; type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="javascript">					 &lt;/label&gt;</span><br><span class="javascript">					 &lt;label&gt;</span><br><span class="javascript">						 内容：</span><br><span class="javascript">						 &lt;textarea name=&quot;textValue&quot;  value=&#123;this.state.textValue&#125; onChange=&#123;this.handleChange&#125;/&gt;</span><br><span class="javascript">					 &lt;/label&gt;</span><br><span class="javascript">					 &lt;label&gt;</span><br><span class="javascript">					 	选择：</span><br><span class="javascript">					 	&lt;select name=&quot;selected&quot; value=&#123;this.state.selected&#125; onChange=&#123;this.handleChange&#125; &gt;</span><br><span class="javascript">					 	    &lt;option value=&#x27;aa&#x27;&gt;aa&lt;/ option&gt;</span><br><span class="javascript">					 		&lt;option value=&#x27;bb&#x27;&gt;bb&lt;/ option&gt;</span><br><span class="javascript">					 		&lt;option value=&#x27;cc&#x27;&gt;cc&lt;/ option&gt;</span><br><span class="javascript">					 	&lt;/select&gt;</span><br><span class="javascript">					 &lt;/label&gt;</span><br><span class="javascript">					  &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="javascript">					&lt;/form&gt;  </span><br><span class="javascript">				)</span><br><span class="javascript">			&#125;</span><br><span class="javascript">		&#125;</span><br><span class="javascript">		ReactDOM.render(&lt;NameForm /&gt;,document.getElementById(&#x27;test1&#x27;))</span><br><span class="javascript"></span><br><span class="javascript">		</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>V8工作原理</title>
    <url>/2022/01/11/V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<hr>
<p><em>本文来源于<a href="http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82">http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程</a><a href="https://time.geekbang.org/column/intro/216">《浏览器工作原理与实践》_-极客时间</a>。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。</em></p>
<hr>
<p>V8是谷歌团队研发的一种JavaScript引擎。本文将从数据存储、数据回收、编译机制三个角度来分析JavaScript。</p>
<h2 id="1-数据存储"><a href="#1-数据存储" class="headerlink" title="1.数据存储"></a>1.数据存储</h2><h3 id="1-1-JavaScript是什么类型的语言"><a href="#1-1-JavaScript是什么类型的语言" class="headerlink" title="1.1 JavaScript是什么类型的语言"></a>1.1 JavaScript是什么类型的语言</h3><p>如C语言、Java语言就是在定义变量时就<u>需要声明变量类型</u>的语言，这种语言称为<u>静态语言</u>，像Python、JavaScript语言就是定义变量时无需声明变量类型的语言，这种语言叫做<u>动态语言</u>。如下段代码就是静态语言和动态语言的案例对比。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//静态语言-C语言</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>   <span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>;<br>   <span class="hljs-built_in">char</span>* b = <span class="hljs-string">&quot; 极客时间 &quot;</span>;<br>   <span class="hljs-built_in">bool</span> c = <span class="hljs-literal">true</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//动态语言-JavaScript语言</span><br><span class="hljs-keyword">var</span> a=<span class="hljs-number">1</span><br>console.log(a,<span class="hljs-keyword">typeof</span>(a))<br></code></pre></td></tr></table></figure>

<p>如C语言、JavaScript语言又可称为<u>弱类型语言</u>，弱类型语言是指可以<u>支持隐式类型转换</u>的语言。反之，不支持隐式类型转换的语言就是<u>强类型语言</u>，如Java、Python。</p>
<p>所以，JavaScript是一种动态的、弱类型的语言。</p>
<h3 id="1-2-JavaScript的数据类型"><a href="#1-2-JavaScript的数据类型" class="headerlink" title="1.2 JavaScript的数据类型"></a>1.2 JavaScript的数据类型</h3><p>JavaScript一共有<u>8种</u>数据类型，这8种类型可以分为两大类型，分别是<u>基础类型（原始类型）和引用类型</u>。基础类型包括Boolean布尔类型、Null空值、Underfined未定义类型、Nubmber基于IEEE754标准的双精度64位数据类型、BigInt可以曹处Number的安全整数范围限制的新的数据类型、String文本类型、Symbol符号类型不可修改且唯一。引用类型的数据只有一种即<u>Object对象类型</u>。</p>
<p>其中要注意的是，使用typeof方法检测Null类型时返回的是Object（这是一个JavaScript一直以来的Bug）；Object类型是一种由基础类型组成的包含了key-value对的数据类型；基础数据类型和原始数据类型存储的位置不同。</p>
<h3 id="1-3-内存空间"><a href="#1-3-内存空间" class="headerlink" title="1.3 内存空间"></a>1.3 内存空间</h3><p>JavaScript运行时需要利用内存来存储数据，其中可以将内存分为三个部分分别是<u>代码空间</u>——用来存储可执行代码，<u>栈空间</u>——用来存储执行上下文，以及<u>堆空间</u>。</p>
<p>栈空间用来存储可执行上下文，一般基础数据都直接存储在栈中，而Object数据由于其往往需要占较大内存所以会将其存储在堆中，栈中只存储其内存地址。一般而言，栈空间的大小都是较小的，因为栈空间若是较大，则释放或添加执行上下文则会调用更大的时间，而堆空间一般较大，也可以存储更多的数据。</p>
<h3 id="1-4-再谈闭包"><a href="#1-4-再谈闭包" class="headerlink" title="1.4 再谈闭包"></a>1.4 再谈闭包</h3><p>以下这段代码涉及到了闭包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 极客时间 &quot;</span><br>    <span class="hljs-keyword">let</span> test1 = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">const</span> test2 = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">var</span> innerBar = &#123; <br>        <span class="hljs-attr">setName</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newName</span>)</span>&#123;<br>            myName = newName<br>        &#125;,<br>        <span class="hljs-attr">getName</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(test1)<br>            <span class="hljs-keyword">return</span> myName<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> innerBar<br>&#125;<br><span class="hljs-keyword">var</span> bar = foo()<br>bar.setName(<span class="hljs-string">&quot; 极客邦 &quot;</span>)<br>bar.getName()<br><span class="hljs-built_in">console</span>.log(bar.getName())<br></code></pre></td></tr></table></figure>

<p>按道理，foo函数中的 <code>myName</code>、<code>test1</code>变量都是基础数据，应该直接存储在栈中，而随着foo函数执行完毕也会随之销毁，那么闭包又是怎么形成的呢？这就要分析这段代码的执行流程。</p>
<p>首先JavaScript引擎执行foo函数时，会先编译，并创建一个空的执行上下文，编译过程中，遇到<code>setName</code>内部函数时会对其进行<u>一次快速的词法扫描</u>，发现在内部函数中遇到了其外部函数中定义的变量，JavaScript引擎就会判断这是一个闭包，就会在堆空间中创建一个<u>closure(foo)</u>的对象来存储相关变量。同理在<code>getName</code>函数中也会将<code>test1</code>变量存储在堆中对应位置。这样即使foo函数的执行上下文被移除，闭包中的变量也可以保留。</p>
<h2 id="2-垃圾回收"><a href="#2-垃圾回收" class="headerlink" title="2.垃圾回收"></a>2.垃圾回收</h2><p>有一些数据使用之后就不再需要，我们将这些数据称为<u>垃圾数据</u>，不同语言都有不同的垃圾回收政策，对于JavaScript语言则有一个<u>自动垃圾回收策略</u>。</p>
<h3 id="2-1-调用栈中的数据回收"><a href="#2-1-调用栈中的数据回收" class="headerlink" title="2.1 调用栈中的数据回收"></a>2.1 调用栈中的数据回收</h3><p>和操作系统中涉及到的栈结构相似，调用栈是利用<u>ESP指针</u>（永远指向栈顶的指针）来进行数据回收，因为栈是一种先入后出的结构，栈顶的数据是最先废弃掉的，所以通过移动ESP指针来确定栈顶的位置，ESP指针以上的部分就是被回收的可以重新覆盖的数据区域。</p>
<h3 id="2-2-堆中的数据如何回收"><a href="#2-2-堆中的数据如何回收" class="headerlink" title="2.2 堆中的数据如何回收"></a>2.2 堆中的数据如何回收</h3><p>在回收栈数据中，有一些数据类似Object数据是存储在堆中的，所以即使回收掉栈中的数据，堆中这些垃圾数据依旧没有被处理，那么这些数据该如何处理呢？这要涉及到<u>代际假说</u>的概念。</p>
<p>代际假说有<u>两个特点</u>，分别是大部分对象在对村中存在时间很短，很多对象一经分配内存就会变得不可访问，第二个特点是不死的对象会活很久。</p>
<p>代际假说适用于大多数的<u>动态语言</u>。V8通过将堆分为<u>新生代和老生代</u>两个区域，分别使用<u>副垃圾回收器和主垃圾回收器</u>来实现垃圾回收。</p>
<h3 id="2-3-垃圾回收器的工作流程"><a href="#2-3-垃圾回收器的工作流程" class="headerlink" title="2.3 垃圾回收器的工作流程"></a>2.3 垃圾回收器的工作流程</h3><p>V8的两个垃圾回收器拥有一套共同的执行流程。</p>
<p>第一步：标记空间中活动对象和非活动对象，活动对象就是还在使用的对象。</p>
<p>第二步：回收非活动对象所占据的内存。</p>
<p>第三步：进行内存整理，一般在回收对象后，内存中会出现大量不连续的空间，如果需要分配较大连续空间时就会出现内存不足的情况，所以需要进行内存整理。而整理<u>内存碎片</u>其实只在老生代中会进行，使用副垃圾回收器无需再新生代进行此步骤。</p>
<p><strong>副垃圾回收器</strong>：主要负责新生区的垃圾回收，通常情况，大多数<u>小的对象</u>都会被分配到新生区，所以该区域虽然不大但是使用频繁。新生区又对半分为对象区域和空间区域。如下图所示为堆的结构图：</p>
<p><img src="/images/react/2022011102.png"></p>
<p>新加入的对象会被放入对象区域，当对象区域被写满时，则需要执行一次垃圾清理操作。</p>
<p>在垃圾回收过程，首先要对对象进行标记，标记完成后会将存货的对象<u>复制</u>到空闲区域，并且将它们<u>有序排列</u>起来，这个过程也相当于完成了<u>内存整理</u>工作。完成复制后会将对象区域和空闲区与进行<u>角色翻转</u>，原来被填满的对象区域变成了空闲区域。以此这样反复循环的使用就是在新生代中采用的<u>Scavenge算法</u>。</p>
<p>由于新生区的空间不大，很容易就被存活对象装满整个区域，所以JavaScript引擎采用了<u>对象晋升策略</u>，将两次垃圾回收仍然存活的新生区对象转移到老生区中。</p>
<p><strong>主垃圾回收器</strong>：主要负责老生区中的垃圾回收，对比于新生区，它的对象总是<u>占用较大空间或者是存活时间较长</u>。</p>
<p>因为老生区空间较大不适合采用Scavenge算法，其采用了<u>标记-清除（Mark-Sweep）算法</u>进行垃圾回收。</p>
<p>比如，当调用栈中要移除顶部的执行上下文后，就会进行一次数据扫描——此时便利调用栈，发现找不到相应堆中某数据的引用地址，则会标记堆中该数据为垃圾数据，标记完垃圾数据后就是清除阶段，直接清除被标记为垃圾数据的数据，然后采用<u>标记-整理（Mark-Compact）算法</u>进行内存整理。具体的老生区标记清除过程和标记整理过程如下两张图所示。</p>
<p><img src="/images/react/2022011103.png"></p>
<p><img src="/images/react/2022011104.png"></p>
<h3 id="2-4-全停顿"><a href="#2-4-全停顿" class="headerlink" title="2.4 全停顿"></a>2.4 全停顿</h3><p>我们已经知道V8是如何进行垃圾回收的，但由于JavaScript是运行在主线程上，一旦执行垃圾回收算法，就需要暂停其他正在执行的JavaScript脚本，直到垃圾回收执行完毕才能继续执行脚本，这种行为叫做<u>全停顿（Stop-The-World）</u>。</p>
<p>全停顿总是会消耗一定时间导致<u>页面卡顿</u>的问题，为了解决这样的现象V8将主垃圾回收器的标记过程分为一个个的<u>子标记</u>过程，让这些块过程和JS脚本交叉运行，这个算法叫做<u>增量标记（Incremental Marking)算法</u>。</p>
<h2 id="3-代码编译"><a href="#3-代码编译" class="headerlink" title="3.代码编译"></a>3.代码编译</h2><p>要深入理解V8的工作原理，需要理解一些概念和原理，比如接下来要详细介绍的<u>编译器(Compiler)、解释器(Interpreter)、抽象语法树(AST）、字节码(Bytecode)、及时编译器(JIT)</u>。</p>
<h3 id="3-1-编译器和解释器"><a href="#3-1-编译器和解释器" class="headerlink" title="3.1 编译器和解释器"></a>3.1 编译器和解释器</h3><p>从程序员能够理解的高级语言到机器能够理解的机器语言之间需要使用到编译器/解释器来进行语言的转换。如C/C++、GO等是通过编译器来解析语言的<u>编译型语言</u>；如Python、JavaScript等则是通过解释器来解析语言的<u>解释型语言</u>。以下是编译器和解析器翻译代码的过程图。</p>
<p><img src="/images/react/2022011105.png"></p>
<p>从图中你可以看出这二者的执行流程，大致可阐述为如下：</p>
<p>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功</p>
<p>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</p>
<h3 id="3-2-V8执行一段JavaScript代码过程"><a href="#3-2-V8执行一段JavaScript代码过程" class="headerlink" title="3.2 V8执行一段JavaScript代码过程"></a>3.2 V8执行一段JavaScript代码过程</h3><p>如图所示为V8执行一段JavaScript代码的流程图。</p>
<p><img src="/images/react/2022011106.png"></p>
<p>第一步：源代码生成<u>抽象语法树</u>和执行上下文。</p>
<p>这个步骤相当于Html文件转化为浏览器可以理解的DOM树情况雷系，Javascript也是要转化为计算机能够理解的AST结构。这个过程分别运用到了<u>词法分析</u>和<u>语法分析</u>。</p>
<p>第二步：<u>解释器Lgnition</u>根据AST生成<u>字节码</u>。</p>
<p>第三步：判断是否为<u>热点代码(HotSpot)</u>，如果不是则将字节码放入<u>解释器</u>逐条解释执行，如果是则将字节码放入<u>JIT编译器</u>编译成高效的机器码来执行。这样能够提高代码的整体执行效率。</p>
<h3 id="3-3-JavaScript的性能优化"><a href="#3-3-JavaScript的性能优化" class="headerlink" title="3.3 JavaScript的性能优化"></a>3.3 JavaScript的性能优化</h3><p>主要关注以下三个方面。</p>
<ul>
<li><p>提升但此脚本的执行速度，避免JavaScript的长任务霸占主线程，这样可以使得页面快速响应交互。</p>
</li>
<li><p>避免大的内联脚本，因为在解析HTML的过程中，解析和编译也会占用主线程。</p>
</li>
<li><p>减少JavaScript文件容量，因为更小的文件会提升下载速度，并且占用更低的内存。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>JavaScript</tag>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>一封信</title>
    <url>/2022/01/12/%E4%B8%80%E5%B0%81%E4%BF%A1/</url>
    <content><![CDATA[<p>我时常在浪漫和理智中徘徊。</p>
<p>一个在浪漫和理智中徘徊的人到底是一个理想主义者还是现实主义者呢？</p>
<p>我总是对自己说：别写这么傻的信，即使你看了也只会扫上两眼然后对别人说：XXX给我写了一封无聊的东西。最后用草稿纸的背面写几个字回我。</p>
<p>此外，时间过去很久了，久到我似乎没有理由写这样的信，久到这封信变得不是为你写的，而是为我自己写的。可是，写来写去也是欺骗自己，为自己打造一副自己情深的可笑场面。因为我明明已经释然了已经习惯了却偏偏还要回忆。</p>
<p>前天晚上梦见了你，以前，三年前的时候，我每次梦见你都会在备忘录上记下一笔，不过后来梦见你的次数实在太多了，也就没再记录。前天我梦见，你对你的专业不满意，你想要转专业，你转了我这个专业，又和我一起读书了。大概是因为我有基础吧，老师总是表扬我，然后你也对我刮目相看，我在梦里想：现在你应该注意到我了，我该找个什么机会和你自然地和好呢。</p>
<p>其实每一次梦见你都是这样的，每一次我都想在梦里与你和好，有几次和好成功了，有几次正在试探中，有几次非常浪漫，有一次的梦里，我要回高中处理一些事情，我抬头看到了宛如极光的天空，我发出感慨，朝着这绚烂的天边走去，然后我遇见了也在抬头看天的你。有一次的梦里，你主动来和好，我真开心，第二天我们一起吃早饭，我问你：为什么想要和好呢？你说：因为你是主角啊（因为是在你的梦里啊），然后突然意识到自己是在做梦。有一次的梦非常真实，我已经忘记了到底梦见什么，不外乎我们和好了，我太高兴了，高兴到在梦中反复询问这不会是在做梦吧这不会是在做梦吧，然后我突然被闹钟吵醒了，从混沌到彻底清醒的那段时间似乎变得很漫长，我的心脏从开始的狂跳不止逐渐恢复正常，然后就是失望、心灰意冷、一种无法相信那竟然只是梦的质疑。</p>
<p>2017年的时候，我写过一封表白信给你，发送出去了的，给十年后的你，前段日子我再次浏览那个网站的时候，发现有追溯以前信件的功能，我搜了一下，发现我写给你的信失踪了。没有逃过一劫的窃喜，只有遗憾。虽然打扰未来的你是一件不太负责任的事情，但我还是希望那份心意能沿着时空隧道传到未来的你那里。2017年秋天的那个晚上，我写了又删，小心翼翼打下一个个幼稚的文字（现在隐约记得，是蛮幼稚和天真的），选择的时间是十年后，填写的收件人邮箱是你的QQ邮箱，然后我点了公开信。我还以为公开信是对方收到信后才公开，可是我点击发送后就在公开列表中看到了它。</p>
<p>非常慌张，我害怕被你看到，我只要一考虑到有这个可能性，一考虑到你有可能会看到，一想到如果你那时就看了我们也许连朋友都做不了，我就慌张地不知所措，然后我就非常笨拙地写下了几十封上百封的公开信吧，收件人一开始是我的邮箱，然后是不知道是谁的邮箱，信的内容也是乱七八糟的复制粘贴的，那一天我大概花了四五个小时都在写公开信，只是想把我写给你的那封信隐藏在角落里。即使这样，我还是不放心，我记得那个时候已经是早上四点了，我找到了网站开发者的微博账号，在账号上私信他，发了很多很多骚扰文字，然后终于还是睡着了，醒来后第一件事就是看微博私信，收到他的回复：已删——我才松了一口气。</p>
<p>可是，没想到他是把这封信彻底删了。我好遗憾啊。</p>
<p>我为什么就喜欢上你了呢？回忆已经被美化滤镜过滤了一遍，我偶尔回忆起来的也只是你很美好这件事了，现在我回忆起你的时间越来越短，回忆的内容也越来越单薄，过去，不知道是前年还是去年的时候，我突然回忆起关于你的什么事情来，然后一阵恍惚，因为我意识到我已经忘记了好多好多回忆了，是很难受的，我不希望忘记这些回忆。</p>
<p>还是说现在的事情吧，也许是因为我不知道怎么去讲述我过去对你的感情，我担心你不会想听的，因为，我在那段时间里总是在悲伤中、痛苦中、嫉妒中。</p>
<p>昨天我在b站上看到了一个刚刚从失恋中走出来的up主发的新视频，她说她失恋时非常地痛苦，让我突然觉得我那时的痛苦好像变得无所谓了，因为不是只有我一个人经历过这样的痛苦，也许百分之五十的人都会经历过，这样就显得我的过去是一段很寻常的往事。可是我还是会觉得，我和那个up主是不一样的，因为我喜欢的人比她喜欢的人要好很多。大概是因为我一直都是暗恋你的缘故吧，所以你真的变得无比美好了，不，即使排除这些区别，你也比别人好上很多，你真的无比美好，我现在还是觉得你是我应该追逐的存在。我以前做了很多很多愚蠢的事情，比方说我为了给你一个人写明信片，我会给全班交好的女生都写上一张明信片，大概这样就能隐藏我对你的情感了吧。</p>
<p>如果我记得没错的话，那张明信片上其实只有一句话：遇见你是一件很幸运的事情。一开始是写满了整张明信片的文字，只有最后一句是这句话，我觉得文字太多显得我絮叨，就重写了一张，写着写着，换了很多明信片，变得只剩下这一句话了。又因为我的字实在是不好看，这句话我也写了好几遍。但是，即使是现在我也想对你说：谢谢你，遇见你是一件很幸运的事。</p>
<p>我翻高中的日记，我在日记里是这样形容我对你的感情：我确定我对她的感情不是爱情，因为爱情可能会冷淡但是我对她的感情永远也不会改变。不过我还是偷偷写了很多表白信给你，不是写给未来的你，是写给那时的你。有一阵子，我每天都在被子里练字——是写表白信，只是白天总是不敢交给你而已。不过那都是高三后面的事情了，我和你“绝交”时的事情了。我很早就对你有了超过友谊的情感，有一天晚上我突然梦见你对我表白，让我意识到我喜欢上你了，当然我是害怕的，我那时更傻，女生喜欢女生对于我来说是很不可思议的事情，我下意识地忽略和遗忘这件事，所以那段时间很多情况我自己都没有意识到我在做什么。现在想想真好笑，我甚至还在无意间和你表白过，那句话太露骨了，其实就等于表白了，可是我是出自真心说出的，完全不加思考，当时也完全意识不到这句话意味着什么。</p>
<p>对不起，对不起，真的很对不起，我突然想起了很多画面，我想起了你的眼神，我想起了你对我说的话，你大概是知道我喜欢你的，甚至不需要大概，你就是知道我喜欢你吧，也许不只是你，其他人也多少意识到了，那时我真的很傻，我喜欢一个人，但是我完全不知道该怎么表达自己的喜欢，完全不知道要怎么去追求她，谢谢你，真的谢谢你，我觉得我是应该满足了，我真后悔那次毕业散伙饭我没有穿的好看一点。谢谢你。</p>
<p>你就是我的莉拉，我是莱农，我是爱上莉拉的莱农，真可惜她们两个人走散了，也许不再相聚了，可是，莱农是因为莉拉才变成莱农的。谢谢你。</p>
]]></content>
  </entry>
  <entry>
    <title>二零二一年十二月二十七日</title>
    <url>/2021/12/27/%E4%BA%8C%E9%9B%B6%E4%BA%8C%E4%B8%80%E5%B9%B4%E5%8D%81%E4%BA%8C%E6%9C%88%E4%BA%8C%E5%8D%81%E4%B8%83%E6%97%A5/</url>
    <content><![CDATA[<hr>
<p><em>莉拉和娜斯塔霞</em></p>
<hr>
<p>当我读完《白痴》时，我也许会默念无数遍娜斯塔霞这个名字，就像是当初读完那不勒斯四部曲时无数遍的“莉拉”。前面一百八十页都只是轻飘飘地压着，第一部的最后二十页突然沉重地如同深海里的陨石一样压得我喘不过气来。我仔细凝视书中的一张画像，然后翻到了影视版莉拉的剧照——太像了，连长得都如此相像，我甚至怀疑导演就是举着这张画像找的演员。莉拉的那张剧照在平板上看着好美，她的美是摄人心魄的，她产生的冲击力，大概只有《时时刻刻》里的伍尔夫才能相提并论吧。</p>
<p>真想一口气读完，可这是陀思妥耶夫斯基，可不是费兰特。</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>二零二一年十二月二十三日</title>
    <url>/2021/12/23/%E4%BA%8C%E9%9B%B6%E4%BA%8C%E4%B8%80%E5%B9%B4%E5%8D%81%E4%BA%8C%E6%9C%88%E4%BA%8C%E5%8D%81%E4%B8%89%E6%97%A5/</url>
    <content><![CDATA[<hr>
<p><em>失望。</em></p>
<p><em>高兴。</em></p>
<hr>
<p>没有什么比书看了一半去看豆瓣评分发现好友评分只有五分多更失望的了。虽然轻易被左右思想说起来很难听但是我已经不想看下去了，这本书。</p>
<p>晚上又看了一部很好的电影，于是心情变得很好。这个电影讲述了永无止境的一日。当你过着枯燥、乏味、格式化的生活，当你每一天都被社会规则和世俗观念束缚，当你养着一身因为懒惰、贪婪和虚无而滋生的赘肉时，突然有一天醒来，你发现”今天是昨天“，然后你发现不仅”今天是昨天“，”今天还是明天“，或者说明天是今天，昨天也是今天，永远只有今天，世界宛如陷入一个while(1)的无限循环的程序，而你就是那个不断累积次数的变量，其他所有人的日子都会在新的一天开始时被默认重置，那么你会怎么选择过你的生活呢？</p>
<p>这真的是一个很简单的问题吗？我在看电影的时候也想了无数种可能，我在想，我也许会因为这无限的重复而感到绝望，我也许会自杀，我想过我也许会突破任何束缚变得彻底自由无所顾忌，我可以尝试任何我想尝试的事情。我在想我可以像玩攻略游戏一样去认识了解身边的每一个人，发展出尽量多的可能性，我又想我可能无法忍受我搭建好的友谊的小船在第二天完全消失，甚至不曾出现过。我想过我可能彻底陷入虚无的泥潭一蹶不起（然后我发现我想的电影主角都做了，他唯一没做的就是我想过了解身边每一个陌生人然后告诉他们我就是神我来统治你们了，然后建立起个人崇拜的大旗——不过主角也说过：我就是上帝）。看到最后我才明白一件事情，就是我们过着的“连续的每一天”和电影里的“重复的某一天”可能没有什么区别。只有那些非常珍惜当下并且了解到自己真正需要什么的人才会觉得二者之间是有区别的。起码对于我来说，这两者可以没有区别。当我现在不重复过着每一天时，我却企图用最低地成本过着重复的日子，看起来我的每一天都是不同的，但其实我的每一天的许多时候都是相同的。如此想来，“重复的某一天”的日子或许才能找到更多的生命力，就像是电影里的主角一样，我们开始认真过好这一天，因为我们只有这一天，因为我们已经度过了虚无的这一天、贪婪的这一天、愤怒的这一天、颓废的这一天、绝望的这一天。因为我们意识到了这一天的单调性，因为我们无法真正地忍受重复，所以我们只有不断地创造，创造自己、创造周围。</p>
<p>“连续的每一天”和“重复的某一天”到底有什么区别？他们本质上是没有区别的，他们只不过都是由时间堆叠的日子而已，只不过两种情况延续的方向轴不在同一个维度而已。可是似乎只有在“重复的某一天”里，我们才能去突破去创新去利用时间，因为我们畏惧重复。可是当我们只过着“连续的每一天”时我们又开始依赖重复，因为这种重复构建的稳定让我们在不重复的日子里找到了安全感。</p>
<p>所以，我真希望自己能经历重复的某一天，这样我就知道如何度过连续的每一天了。</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>二零二一年十二月二十二日</title>
    <url>/2021/12/22/%E4%BA%8C%E9%9B%B6%E4%BA%8C%E4%B8%80%E5%B9%B4%E5%8D%81%E4%BA%8C%E6%9C%88%E4%BA%8C%E5%8D%81%E4%BA%8C%E6%97%A5/</url>
    <content><![CDATA[<hr>
<p><em>好开心。</em></p>
<hr>
<p>刚刚看完《Tokyo！》，真的是好喜欢好喜欢这部电影啊！然后就好开心好开心，就是因为看了一部很好的电影就很开心。喜欢卡拉克斯，喜欢Alex！三个短片，每一个都好喜欢！喜欢到想要迫不及待地写年末观影小结然后写很多很多文字赞美它，虽然我现在都挤不出什么来，只能不停地说好喜欢。</p>
<p>今天上午看一本上半年没看完的书，发现了两片花瓣。想起了前两天在杂志堆里发现的几片黑漆漆干巴巴的玉兰花，这两片花瓣对比之下非常干净可爱，即使已经没有水分了依旧留有几分柔软，但是由于我太猛烈地翻页所以还是撕开了一个裂痕，颜色也是，依稀能够看出曾经的颜色来，但是现在的颜色也不讨人嫌弃。</p>
<p><img src="/images/2021122202.png"></p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>二零二一年十二月二十五日</title>
    <url>/2021/12/25/%E4%BA%8C%E9%9B%B6%E4%BA%8C%E4%B8%80%E5%B9%B4%E5%8D%81%E4%BA%8C%E6%9C%88%E4%BA%8C%E5%8D%81%E4%BA%94%E6%97%A5/</url>
    <content><![CDATA[<hr>
<p><em>圣诞节快乐</em></p>
<hr>
<p>圣诞节这一天下雪了。</p>
<p>外面在下雪，我读着似乎永远都读不完的陀思妥耶夫斯基。</p>
<p>昨天两个小时竟然只读了五十页，今天再尝试了一下，两个半小时五十页。</p>
<p>俄国人的名字真长，真难记，昨天认识的人名今天全给弄混了，一页出现了三个人名，往前追溯发现竟然全都是一个人的名字，可是这个人的名字我又和另一个人的名字弄混了，以至于读的非常糊涂。</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>二零二一年十二月十七日</title>
    <url>/2021/12/17/%E4%BA%8C%E9%9B%B6%E4%BA%8C%E4%B8%80%E5%B9%B4%E5%8D%81%E4%BA%8C%E6%9C%88%E5%8D%81%E4%B8%83%E6%97%A5/</url>
    <content><![CDATA[<hr>
<p><em>重看《寄生虫》。</em></p>
<hr>
<p>喜欢小右的眼睛，好美。</p>
<p><img src="/images/2021121702.png"></p>
<p><img src="/images/2021121801.png"></p>
<p>看完后百感交集，想到这次的新冠，那句共存的口号，以及《素食者》这本书。也许以后可以谈谈。</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>二零二一年十二月十八日</title>
    <url>/2021/12/18/%E4%BA%8C%E9%9B%B6%E4%BA%8C%E4%B8%80%E5%B9%B4%E5%8D%81%E4%BA%8C%E6%9C%88%E5%8D%81%E5%85%AB%E6%97%A5/</url>
    <content><![CDATA[<hr>
<p><em>包书。</em></p>
<hr>
<p>包杂志的时候抖出了一堆黑乎乎的玉兰花干片，怪丑的，还蛮多的。不知道我以前抱着什么心情收集的，想要留住玉兰花的美好吗？</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>二零二一年十二月十四日</title>
    <url>/2021/12/14/%E4%BA%8C%E9%9B%B6%E4%BA%8C%E4%B8%80%E5%B9%B4%E5%8D%81%E4%BA%8C%E6%9C%88%E5%8D%81%E5%9B%9B%E6%97%A5/</url>
    <content><![CDATA[<hr>
<p><em>开展“新生活”是一件很困难的事情。</em></p>
<hr>
<p><img src="/images/2021121401.png"></p>
<p>整理书架，先拿出从学校带回的书。</p>
<p><img src="/images/2021121402.png"></p>
<p>发现了一个小发绳，是妹妹的发绳。</p>
<p><img src="/images/2021121403.png"></p>
<p>书上全都是灰尘，翻开最厚的那本，书页全都泛黄了。毛姆的《人性的枷锁》，高三的课间和午间休息时拿出来读，现在想想真佩服那时的自己，上了大学反而没有耐性读这么厚的书了。</p>
<p><img src="/images/2021121404.png"></p>
<p>书架坏了。垃圾书架，便宜没好货。</p>
<p><img src="/images/2021121405.png"></p>
<p>晚上用新买来的幕布看电影，看《新桥恋人》，好喜欢好喜欢这部电影，想为Alex新建一个相册。</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo搭建博客时遇到的问题</title>
    <url>/2021/12/11/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>主要是deploy部署问题的坑</p>
<h3 id="1-需要输入Github账号和密码，输入之后依旧部署失败"><a href="#1-需要输入Github账号和密码，输入之后依旧部署失败" class="headerlink" title="1.需要输入Github账号和密码，输入之后依旧部署失败"></a>1.需要输入Github账号和密码，输入之后依旧部署失败</h3><p>问题描述：在输入命令 <code>hexo d</code> 来部署时提示需要输入Github的账号和密码进行验证，输入后提示登陆验证失败。</p>
<p>解决方法：网上查询后得知是2021年8月13日之后github不支持输入账号密码登陆而要求输入token登陆，在参考了这篇博客资料后成功解决了该问题，直接在需要输入密码的地方输入token。</p>
<p><a href="https://blog.csdn.net/yjw123456/article/details/119696726#commentBox">https://blog.csdn.net/yjw123456/article/details/119696726#commentBox</a></p>
<h3 id="2-解决上面的问题，但是出现openSSL问题"><a href="#2-解决上面的问题，但是出现openSSL问题" class="headerlink" title="2.解决上面的问题，但是出现openSSL问题"></a>2.解决上面的问题，但是出现openSSL问题</h3><p>问题描述：错误信息：<code>OpenSSL SSL_read: Connection was reset, errno 10054</code></p>
<p>解决方法：删掉项目根目录下的 <code>.deploy_git</code> 文件，重新执行命令 <code>hexo d</code> ,参考以下这篇博客：</p>
<p><a href="https://www.cnblogs.com/tenderwx/p/5783432.html">https://www.cnblogs.com/tenderwx/p/5783432.html</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统原理基础知识点</title>
    <url>/2021/12/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<p><em>本文来源于<a href="https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82%E5%B9%B6%E4%B8%94%E5%9B%A0%E4%B8%BA%E6%9C%AC%E6%AC%A1%E5%A4%8D%E4%B9%A0%E6%98%AF%E4%BA%89%E5%AF%B9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E4%BC%9A%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%88%BB%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%AA%E4%BC%9A%E7%B2%97%E7%95%A5%E6%89%AB%E8%BF%87">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过</a></em>。</p>
<hr>
<h2 id="1-基本特质"><a href="#1-基本特质" class="headerlink" title="1.基本特质"></a>1.基本特质</h2><p>操作系统的基本特征为并发、共享、虚拟、异步。</p>
<p><strong>并发</strong>：同一时间段运行多个程序，区分<u>并行</u>，并行指同一时刻运行多个指令，需要硬件支持。</p>
<p><strong>共享</strong>：指系统的资源可以被多个并发进程同时共享。共享方式分为<u>互斥共享</u>（同一时刻只允许一个进程访问，其共享资源被称为临界资源，比如打印机）和<u>同时共享</u>。</p>
<p><strong>虚拟</strong>：把一个物理实体转换为多个逻辑实体，虚拟技术有<u>时分复用技术</u>（比如多个进程并发执行）和<u>空分复用技术</u>（比如虚拟内存）。</p>
<p><strong>异步</strong>：进程不是一次性执行完毕。</p>
<h2 id="2-基本功能"><a href="#2-基本功能" class="headerlink" title="2.基本功能"></a>2.基本功能</h2><p>包括<u>进程管理</u>、<u>内存管理</u>、<u>文件管理</u>和<u>设备管理</u>。</p>
<h2 id="3-系统调用"><a href="#3-系统调用" class="headerlink" title="3.系统调用"></a>3.系统调用</h2><p>如果一个进程在用户态需要使用内核态功能，则进行系统调度，Linux的系统调度有<u>进程控制、进程通信、文件操作、设备操作、信息维护、安全</u>。</p>
<h2 id="4-大内核和微内核"><a href="#4-大内核和微内核" class="headerlink" title="4.大内核和微内核"></a>4.大内核和微内核</h2><p><strong>大内核</strong>：将操作系统功能作为一个紧密结合的整体放在内核中，各模块共享信息，具有高性能。</p>
<p><strong>微内核</strong>：将部分操作系统功能移除内核，只有微内核这部分模块处在内核态，可降低系统的复杂性。</p>
<h2 id="5-中断分类"><a href="#5-中断分类" class="headerlink" title="5.中断分类"></a>5.中断分类</h2><p><strong>外中断</strong>：由CPU执行指令以外的事件引起的中断，如I/O完成中断等。</p>
<p><strong>异常</strong>：由CPU执行指令内部事件引起的中断，如地址越界等。</p>
<p><strong>陷入</strong>：在用户程序中使用系统调用引起。</p>
<h2 id="6-进程管理"><a href="#6-进程管理" class="headerlink" title="6.进程管理"></a>6.进程管理</h2><h3 id="6-1-进程和线程"><a href="#6-1-进程和线程" class="headerlink" title="6.1 进程和线程"></a>6.1 进程和线程</h3><p><strong>进程</strong>：资源分配的基本单位，PCB（进程控制块）描述进程的基本信息和运行状态。</p>
<p><strong>线程</strong>：独立调度的基本单位，一个进程有多个线程，它们共享进程资源。</p>
<p><strong>进程和线程的区别（面试题）：</strong></p>
<p>进程是<u>资源分配</u>的基本单位，线程不拥有资源，但是线程可以访问所属进程的资源。</p>
<p>进程<u>开销</u>大，在创建、撤销和切换进程时，系统都要为之分配或回收资源，而线程切换只需要保存和设置少量寄存器内容，开销小。</p>
<p>进程<u>通信</u>需要借助IPC，线程间通过直接读写同一进程数据可进行通信。</p>
<h3 id="6-2-进程状态转换"><a href="#6-2-进程状态转换" class="headerlink" title="6.2 进程状态转换"></a>6.2 进程状态转换</h3><p>进程的状态转换如图所示：</p>
<p><img src="/images/react/2021122006.png"></p>
<p>其中，<u>处于就绪状态和运行状态的进程可以相互转换</u>，其他状态进程只能单向转换。处于阻塞状态的进程是缺少资源（不包括时间资源）的进程。</p>
<h3 id="6-3-批处理系统"><a href="#6-3-批处理系统" class="headerlink" title="6.3 批处理系统"></a>6.3 批处理系统</h3><p>该系统没有太多用户操作，调度算法包括<u>FCFS</u>（先来先服务，有利于长作业）、<u>SJF</u>（短作业优先，不利于长作业）、<u>SRTN</u>（最短剩余时间优先）。该系统的调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<h3 id="6-4-交互式系统"><a href="#6-4-交互式系统" class="headerlink" title="6.4 交互式系统"></a>6.4 交互式系统</h3><p>该系统有大量用户交互操作，调度算法包括<u>时间片轮转</u>、<u>优先级调度</u>、<u>多级反馈列表</u>。该系统的调度算法目标是快速进行响应。</p>
<h3 id="6-5-实时系统"><a href="#6-5-实时系统" class="headerlink" title="6.5 实时系统"></a>6.5 实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。分为<u>硬实时和软实时</u>，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h3 id="6-6-进程同步"><a href="#6-6-进程同步" class="headerlink" title="6.6 进程同步"></a>6.6 进程同步</h3><p><strong>临界区</strong>：对临界资源进行访问的那段代码</p>
<p><strong>同步</strong>：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系</p>
<p><strong>互斥</strong>：多个进程在同一时刻只有一个进程能进入临界区。</p>
<p><strong>信号量</strong>：是一个整型变量，可以对其执行P/V操作，即-1/+1操作。</p>
<h2 id="7-内存管理"><a href="#7-内存管理" class="headerlink" title="7.内存管理"></a>7.内存管理</h2><p><strong>虚拟内存</strong>：其目的是为了让物理内存扩充成更大的<u>逻辑内存</u>，让程序获得更多可用内存。</p>
<p><strong>存储方式</strong>：<u>分页存储</u>和<u>分段存储</u>。分页存储更加透明，分段存储需要程序员显示划分每个段。分页存储的地址空间是一维的，分段是二维的。页的大小不可改变，段的大小可以动态改变。分页主要用于实现虚拟内存，从而获得更大的地址空间，分段主要是为了使程序和数据可以被划分为逻辑独立的地址空间且有助于共享和保护。</p>
<h2 id="8-设备管理"><a href="#8-设备管理" class="headerlink" title="8.设备管理"></a>8.设备管理</h2><h3 id="8-1-磁盘结构"><a href="#8-1-磁盘结构" class="headerlink" title="8.1 磁盘结构"></a>8.1 磁盘结构</h3><p>如下所示是磁盘结构图：</p>
<p><img src="/images/react/2021122101.png"></p>
<p><strong>盘面</strong>：一个磁盘有多个盘面；</p>
<p><strong>磁道</strong>：盘面上的圆形带状区域，一个盘面可以有多个磁道；</p>
<p><strong>扇区</strong>：磁道上的一个弧段，一个磁道可以有多个扇区，<u>它是最小的物理储存单位</u>，目前主要有 512 bytes 与 4 K 两种大小；</p>
<p><strong>磁头</strong>：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</p>
<p><strong>制动手臂</strong>：用于在磁道之间移动磁头；</p>
<p><strong>主轴</strong>：使整个盘面转动。</p>
<h2 id="9-连接"><a href="#9-连接" class="headerlink" title="9.连接"></a>9.连接</h2><h3 id="9-1-编译系统。"><a href="#9-1-编译系统。" class="headerlink" title="9.1 编译系统。"></a>9.1 编译系统。</h3><p>一个.c文件被解析执行的具体过程图如下所示：</p>
<p><img src="/images/react/2021122102.png"></p>
<p><code>.c</code>文件先后要经过预处理阶段转为<code>.i</code>文件，再经过编译阶段转为<code>.s</code>程序，经过汇编器转为可重定位的<code>.o</code>程序，最后经过连接器转为可执行的目标程序。</p>
<h3 id="9-2-静态链接和动态链接"><a href="#9-2-静态链接和动态链接" class="headerlink" title="9.2 静态链接和动态链接"></a>9.2 静态链接和动态链接</h3><p><strong>静态链接</strong>：以一组可重定位文件为输入，通过完成<u>符号解析</u>和<u>重定位</u>生产一个完全可执行的输出文件。</p>
<p><strong>动态连接</strong>：为了解决静态库存在的更新时需要重新链接以及如<code>printf</code>这种标准函数库，如果每个程序都有代码会极大浪费资源的问题而出现了<u>共享库</u>。</p>
<h2 id="10-死锁"><a href="#10-死锁" class="headerlink" title="10.死锁"></a>10.死锁</h2><p>死锁是指两个及以上进程执行过程中，由于竞争资源或彼此通信造成的阻塞现象，若无外力作用无法继续推进下去，而造成永久等待的情况。</p>
<h3 id="10-1-产生的原因条件"><a href="#10-1-产生的原因条件" class="headerlink" title="10.1 产生的原因条件"></a>10.1 产生的原因条件</h3><p><strong>互斥</strong>：资源以分配给其他进程，而某资源若需要使用资源只能等待。</p>
<p><strong>请求和保持</strong>：进程已经保持一个资源，但又提出新的资源请求，而此资源被其他进程占用，会造成一直占用已有资源并且一直等待的情况。</p>
<p><strong>不可抢占</strong>：已经分配给一个进程的资源不能强制性抢占，只能等待占有资源的进程显式释放。</p>
<p><strong>环路等待</strong>：两个及以上进程组成一条环路，该环路的每个进程都在等待下一个进程释放占有资源。</p>
<h3 id="10-2-处理方法"><a href="#10-2-处理方法" class="headerlink" title="10.2 处理方法"></a>10.2 处理方法</h3><p><strong>鸵鸟策略</strong>：假装什么事都没发生，忽略死锁问题。</p>
<p><strong>死锁检测与死锁恢复</strong>：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<p><strong>死锁预防</strong>：在程序运行前预防发生死锁。</p>
<p><strong>死锁避免</strong>：在程序运行时避免发生死锁。</p>
]]></content>
      <categories>
        <category>计算机基础复习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>前端面试，操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理基础知识点</title>
    <url>/2021/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<p><em>本文来源于<a href="https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82%E5%B9%B6%E4%B8%94%E5%9B%A0%E4%B8%BA%E6%9C%AC%E6%AC%A1%E5%A4%8D%E4%B9%A0%E6%98%AF%E4%BA%89%E5%AF%B9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E4%BC%9A%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%88%BB%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%AA%E4%BC%9A%E7%B2%97%E7%95%A5%E6%89%AB%E8%BF%87">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过</a></em>。</p>
<hr>
<h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h2><p>事务是指满足<u>ACID特性</u>的一组操作。ACID特性分别包括以下四个特性：</p>
<p><strong>原子性</strong>（Atomicity）：事务被视为不可分割最小单元。事务的操作要么全部提交成功，要么全部失败滚回。</p>
<p><strong>一致性</strong>（Consistency）：数据库在事务执行的前后都保持一致性状态。在一致性状态下，所有事务对同一数据的读取结构是相同的。</p>
<p><strong>隔离性</strong>（Islation）一个事务所做的修改在最终提交以前，对其他食物不可见。</p>
<p><strong>持久性</strong>（Durability）一旦事务提交，则其所做的修改将会永远保存在数据库中。即使系统崩溃，事务执行结构也不会丢失。</p>
<h2 id="2-并发一致性问题"><a href="#2-并发一致性问题" class="headerlink" title="2.并发一致性问题"></a>2.并发一致性问题</h2><p>在并发环境下，事务隔离性很难保证，因此会出现以下并发一致性问题。</p>
<p><strong>丢失修改</strong>：一个事务的更新操作被另一个事务的更新操作替换，如下图所示：</p>
<p><img src="/images/react/2021122103.png"></p>
<p><strong>读脏数据</strong>：当前事务可以读到另外事务未提交的数据，如下图所示：</p>
<p><img src="/images/react/2021122104.png"></p>
<p><strong>不可重复读</strong>：在一个事务内多次读取同一数据，期间该数据被另一事务进行了修改，会导致重复读统一数据的结果不一致，如下图所示：</p>
<p><img src="/images/react/2021122105.png"></p>
<h2 id="3-封锁"><a href="#3-封锁" class="headerlink" title="3.封锁"></a>3.封锁</h2><p><strong>封锁粒度</strong>：封锁粒度越细，锁定数据越少，发生锁争用的可能越小，系统的并发程度就越高，但是也会消耗更多的资源，所以在选择封锁粒度时需要有所权衡。</p>
<p><strong>封锁类型</strong>：读写锁和意向锁。</p>
<p><strong>封锁协议</strong>：包括一、二、三级封锁协议和两段锁协议。</p>
<h2 id="4-关系数据库设计理论"><a href="#4-关系数据库设计理论" class="headerlink" title="4.关系数据库设计理论"></a>4.关系数据库设计理论</h2><h3 id="4-1-函数依赖"><a href="#4-1-函数依赖" class="headerlink" title="4.1 函数依赖"></a>4.1 函数依赖</h3><p>记A - &gt;B表示A决定B，也可以说B依赖于A。</p>
<p><strong>键码</strong>：若（A1,A2,…An）是关系的一个或多个属性集合，该集合函数决定了关系的其他属性并且是最小的，那么该集合就是键码。</p>
<p><strong>部份依赖</strong>：若A-&gt;B，但A的真子集A’-&gt;B成立，则A-&gt;B是部份依赖。</p>
<p><strong>完全依赖</strong>：若A-&gt;B，且无A的真子集A’-&gt;B成立，则A-&gt;B是完全依赖。</p>
<p><strong>依赖传递</strong>：A-&gt;B,B-&gt;C，则A-&gt;C。</p>
<h3 id="4-2-范式"><a href="#4-2-范式" class="headerlink" title="4.2 范式"></a>4.2 范式</h3><p>高级别范式的依赖于低级别的范式，1NF（第一范式） 是最低级别的范式。</p>
<p><strong>INF</strong>：属性不可分。</p>
<p><strong>2NF</strong>：每个非主属性完全依赖于键码。</p>
<p><strong>3NF</strong>：非主属性之间必须互相独立，不存在依赖关系。</p>
<h3 id="4-3-异常"><a href="#4-3-异常" class="headerlink" title="4.3 异常"></a>4.3 异常</h3><p>不符合范式的关系，会出现很多异常，主要有以下四种：</p>
<p><strong>冗余数据</strong>：比如一个记录多次出现在表内。</p>
<p><strong>修改异常</strong>：修改了一个记录中的信息，但另一个记录中相同的信息却没有被修改。</p>
<p><strong>删除异常</strong>：删除一个信息，那么也会丢失其他信息。</p>
<p><strong>插入异常</strong>：因为关联问题出现无法插入记录错误。</p>
<h2 id="5-ER图"><a href="#5-ER图" class="headerlink" title="5.ER图"></a>5.ER图</h2><p>实体关系图（Entity-Relationship），有三个组成部分：<u>实体、属性、联系</u>。</p>
<p>实体之间存在三种关系，分别是<u>一对一、一对多和多对多关系</u>。</p>
]]></content>
      <categories>
        <category>计算机基础复习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>前端面试，数据库系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>日本女性简简简史笔记</title>
    <url>/2022/01/24/%E6%97%A5%E6%9C%AC%E5%A5%B3%E6%80%A7%E7%AE%80%E7%AE%80%E7%AE%80%E5%8F%B2%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><em>”元始，女性是太阳，一个真正的人。 如今，女性是月亮，仰赖他人而存在， 依靠他人的亮光而发光， 是宛若病人的苍白月亮。“——《青鞜》</em></p>
<h1 id="原始社会中日本女性地位"><a href="#原始社会中日本女性地位" class="headerlink" title="原始社会中日本女性地位"></a>原始社会中日本女性地位</h1><p>原始日本社会为母系社会，据记载伊邪那岐命生下三子，其中以女性的天照大神奉为权力至高的神明，象征和代表着太阳。直到弥生时代（公元前300年-公元后300年），这个时段社会逐渐由母权社会慢慢转向父权社会，但依旧有很多女性领袖人物，女性领主（还有一个小故事：一个女皇去世了她的儿子继位但是造成了动乱，后她的女儿继位才平息了动乱）。这个时代的婚姻制度也比较开发，虽然社会已经逐步转向父系社会，但在家庭和婚姻的层面上依旧保留着浓烈的母权色彩，女性依旧占据主导地位，婚姻多为群婚制度，男女双方的自由度很高，可以说是多妻多夫。</p>
<h1 id="古代社会中日本女性地位变化"><a href="#古代社会中日本女性地位变化" class="headerlink" title="古代社会中日本女性地位变化"></a>古代社会中日本女性地位变化</h1><ul>
<li><p>飞鸟时代（公元592-公元710）这个时间段一共出现了5位女天皇，男皇执政时间只有14年。奈良时代（公元711-公元794）这个阶段7位天皇中也有4位是女皇。这个时段依旧在社会上是父系社会，出现这么多女皇的原因之一是大多数女皇都是男天皇的皇后，而皇后都是从男皇同父异母的姐妹中选出来的，日本古代向来认为血缘连接是母方血液的连接，而只禁止母系通婚不禁止父系通婚。所以会认为本就是同一氏族的女儿也有继承权，而且这一阶段皇后的权力和皇太子权力同等，天皇逝世权力则优先传于皇后。</p>
</li>
<li><p>平安时代（公元794-公元1192），女性文学大量涌现，如《源氏物语》《枕草子》都为平安时代女性文学，并且由于贵族女性写作习惯出现了“女手”，就是现今日本的公用文字平假名。弥生时代到平安时代，日本流行的婚姻制度为访妻制，访妻制为男女双方互通情愫后，男方就可以在晚上去女方家，第二天早上就得离开的形式，社会层面上是以父系氏族为主的父权社会，但是家庭层面上却是母系连接，社会层面上是一夫多妻制，但是女方其实为婚姻的主体，女方自由度高，女性亦可在有婚姻关系时与其他男性接触相处，若男方不再访问女方也就很自然解除婚姻关系，这个时段婚姻的主导权多在女方母亲手里。夫妻双方实际为疏离关系，即使结婚也不是一家人，女方生下的孩子虽然和男方姓，但是由女方抚养和教育，属于女方家庭成员而不属于男方家庭成员，也不会认为同父异母的姐妹兄弟和自己有亲属关系，只有母方亲属才被认为有血液的亲属关系。在这样强烈母权色彩的婚姻制度下，女性在家庭的地位极高，女性有完整的继承权，家庭财产也是优先传给女性。（感觉这个时段男人只是生育工具）</p>
</li>
<li><p>平安时代中后期逐渐出现了招婿制，这是家庭层面上逐渐从母系转向父系的过度时期，这个时期婚姻前后很长一段时间男方需要居住在女方家中，直到女方认为时机成熟再搬到男方家中居住，招婿制度的婚姻主导权逐渐转向女方父亲。平安时期以后婚姻制度就变为现在的嫁娶制，婚姻主导权转为男方父亲，女性逐渐转为客体的地位。</p>
</li>
<li><p>平安时代之后也就是镰仓时代，随着幕府建立，武士阶层的固化，以及中国朱子儒学中女子三从四德思想在武士阶层的影响，女性开始被严重规训和束缚。“家庭制”的巩固，社会上的男权到家庭上的父权，无论是婚姻上还是身体思想上女性都被束缚，女性文学也淹没了很长一段时间，但即使是这个时候，女性在日本的地位依旧比其他儒学影响社会要高出很多，由于传统崇拜女性习俗的影响，在非武士阶层女性依旧有着相对多和大的权力，许多村落女性依旧有参政权，女性也有家庭财产继承权，若家庭无长子其财产则会顺位继承给长女。</p>
</li>
</ul>
<h1 id="明治时代日本女性地位变化"><a href="#明治时代日本女性地位变化" class="headerlink" title="明治时代日本女性地位变化"></a>明治时代日本女性地位变化</h1><p>明治时代（1868-1911），受到西方民主思想的影响，日本社会进行了很大的变革（明治维新），逐步走向近代化民主国家，但是日本的变革是“先天不足”的——因为天皇制的保留让很多变革趋于形式，出现很多矛盾，其中女性问题特别尖锐。</p>
<ul>
<li><p>明治初期一些近代思想家受到西方思想影响猛烈抨击了传统的性别价值观，提出男女平权言论。女性开始获得”身体“上的自由，开始从”家庭制度“的束缚中解放出来。</p>
</li>
<li><p>明治中期，受到西方“天赋人权”影响出现了自由民权运动——日本最大规模的国民政治运动，女性解放运动也由此进入发轫期。该阶段多为妇女运动家积极开展抗议和组织运动，1880年成功获得女户主参政权、她们有人积极开展女性教育、女性参政等运动，拉开了日本妇女解放运动的序幕。</p>
</li>
<li><p>明治后期，由于民权运动直接威胁到明治政府的统治，政府开始放弃文明开化的道路转而强调日本传统意识形态。其中做出了三种政策来限制妇女的权力：1890年推出法律废除妇女参政权；1898年《民法》强调宗法家庭制，强调男户主和嫡长子的权利，对女性的权利做出极大打压，她们甚至无权处理家庭财产；一方面为了富国强兵不断加强女性教育，另一方面又极力给女性灌输“贤妻良母”的教育，企图将女性打造为优质的没有主体意识的生育工具。该年《民法》中还明确规定妻随夫姓的条规，近代以前并没有这样的传统，进一步让女性堕入社会边缘。</p>
</li>
<li><p>面对政府强力打压女性运动，妇女只能将运动的中心转向文学，此时出现了许多文学作品来宣传自由民主以及权利解放意识，这个阶段的代表人物谢野晶子受到西方民主和浪漫主义思想影响发表的《乱发》讽刺了官僚和政府震惊整个日本文坛，促进了日本知识女性的自我觉醒。</p>
</li>
</ul>
<p>在明治时期出现了三个杰出的女权运动代表家，她们的开始是热烈和高涨的，结局确实低迷的妥协的。她们前期积极争取女性选举权、教育权等权益，后来却被打压到社会边缘。一个转身家庭只能靠纸笔论述女性问题，一个饱受牢狱之灾却转身反思自己和转变观念，而另一个也是迫于婚姻家庭只能克制自己的表达欲望。</p>
<p>明治维新时期，虽然政府大力提倡女子受教育，也大力提高了女子入学率，但是那时想要培养的是“贤妻良母”的女子，明治维新初期的教育起初是模仿西方女性教育课程的，极大的和女子教育课程相似，家政课只占极少内容，直到自由民权运动极大威胁到了政府，政府放弃了西化的模仿，选择加强传统意识形态，又意识到女子必须受教育才能富强国家，所以极力灌输女子的教育是有非常强烈传统意识、家庭意识、民族意识的教育。</p>
<h1 id="明治时代之后到今天"><a href="#明治时代之后到今天" class="headerlink" title="明治时代之后到今天"></a>明治时代之后到今天</h1><ul>
<li><p>青鞜社的建立。1911年6月建立了日本第一个全部由女性组成的社团组织，发表杂志《青鞜》，在日本史上第一次出现了“新女性”，前后聚拢了许多日本女性革命家，发表的《女性原本是太阳》就像是一份“女性解放宣言”深深影响了整个文坛，是千百年来日本女性发出的第一声有份量的呐喊，她们吸取了西方女权运动的经验而转以文学实践形式出金女性觉醒，青鞜社的成立正式揭开女性解放运动的序幕。（1916年就被解散）</p>
</li>
<li><p>进入大正时代的日本加速进入军国主义阶段，为了配合侵略运动，日本政府在原来的“贤妻良母”形式女性教育下添加了更多的民族主义色彩，他们打造“军国之母”的形象来宣言和赞扬那些有民族主义精神，积极送自己的丈夫和儿子进入战场，并且能够积极生育来增长国家人口的女性形象。在此期间，也有少部分女性积极开展女性解放运动，都被政府无情打压。</p>
</li>
<li><p>二战日本战败后受到联合国的管制，美方向日本提出的五大改革之一的第一条就是解放妇女。从此妇女拥有了选举权、参政权、婚姻家庭上也和男方拥有一样的权力，在法律上实现了初步男女平等。</p>
</li>
<li><p>联合国的七年管制后日本政府重新掌握国家主权，战后资本主义国家经济高速发展，无论是西方还是日本都出现了“主妇回归潮”——战后第一产业高速发展需要更多的体力劳动，女性开始回归家庭。这个阶段东西方资本主义国家的妇女就业都成M型趋势——婚育前女性参加工作，婚育后暂时回归家庭，待孩子长大到一定岁数后再次回归职场。但是由于西方意识形态逐渐改进，有意识在制度上支持女性工作，所以西方社会女性就业曲线逐渐转化为“倒U型”——即婚育后也不会脱离职场。而日本由于本土意识形态以及高速压缩资本主义国家现代化历程在社会性别分工方面与欧美出现很大偏差。</p>
</li>
<li><p>战后日本经济高速发展，也有越来越多的年轻劳动力涌入市场。前期女性劳动者也迅速增长，但是女性劳动者多为临时工或短期工，政策上没有推进女性持续就业导致大部分女性都回归到了家庭。为了使得充分有效利用劳动人员，日本在政策上支持男性全身心投入工作，而支持妇女回归家庭。196X年颁布法律鼓励妇女回归家庭，在经济层面上回归家庭的妇女会给家庭带来很大的经济补贴（免额度税务，添加年度工资补贴等使得女性回归家庭后能为家庭带来每年70万日元左右的金额），让西方社会的“去妇女回归家庭化”现象并没有出现，反而加重或者是固化了妇女回归家庭的现状。另外男女同工不同酬的情况持续到了1986年，即使在该年之后依旧在占据人们经济来源很大一部分的奖金层面上女性普遍也只有男性的1/2-2/3。日本女性M型就业曲线直到2009年都没有实质性的改变，直到现在依旧是M型曲线形式。</p>
</li>
<li><p>在教育层面上，日本保留并支持大量女子学校的开办，大部分女子学校依旧以明治维新时期“贤妻良母”的思想为教育女性的方针，比如有名的双叶学校（出过很多名人以及名人的妻子，出过两代皇后）的校训依旧是百年前的“天真无邪，行事踏实”。鼓励性别差异教育，从婴儿阶段就对男女性别准备不同色彩的服饰和生活用品。这样的教育方针导致日本的性别分工意识形态发展比较缓慢，直到2002年的统计数据才第一次出现人们反对“男主外，女主内”思想人数高于赞成的人（但是后面2012年的统计数据出现回返现象），而最近（2019年）的统计数据显示日本赞成该思想的人数依旧还有1/3。</p>
</li>
<li><p>日本的女性地位其实和日本的女性主义进展没有直接的关系。由于战后支持的民主自由的主调思想让学术上的研究得以支持和发展。所以日本有许多开设女性主义相关的课程。但是在社会女性地位上却不容乐观。日本女性研究专家将1970年-1975年视为女性解放阶段，将1976-1985年称为女性主义阶段。其中因为1975年国际妇人年对日本的影响-到1985年国际妇人年结束，加上上世纪八十年代日本经历泡沫经济时代，日本被迫进行改革，传统的夫妻分工形式受到了动摇。越来越多人在性别问题上有了更加先进的意识形态。但是日本一直都面临着意识形态和社会现状错位的问题，即使在2002年多数人反对“男主外，女主内”思想，社会情况却不容乐观且难以改变。</p>
</li>
<li><p>2010年安倍内阁提出“女性经济学”，想要支持女性在市场职场上的发展，最后政策实行结构也没有太大的改变。因为其根本问题是社会层面，意识形态的问题，但是安倍提出的却是经济方针，女性就业困难问题依旧没有得到乐观的改善。</p>
</li>
</ul>
<p>日本女性史是一个需要深入探索和研究的学科，而我只用了一周零零散散的时间寻找国内论文进行了整理，既没有找过日本学者的相关论文也没有系统阅读过哪本相关研究的书籍。而且这一个姑且能够用时间线串联起来的简简简史也是阅读了一堆杂乱的无序的论文后拼凑起来的“别人的言论”。但是在阅读和整理过程中还是有很大收货的，也对这个和我们有很大渊源的邻国有了更深的了解。以前就很喜欢日本，喜欢日本动画，日本电影，日本文学，即使去年读了《菊与刀》对日本很下头了一阵子后还是重新拾回对日本的好感。这一次的研究到没有下头，是更了解日本了，比起读《菊与刀》产生的因陌生导致的误解有了更多的理解和同理心。现在觉得，日本真是一个复杂的国家，但是哪个国家不是呢？</p>
]]></content>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2021/12/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<hr>
<p><em>本文来源于<a href="https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82%E5%B9%B6%E4%B8%94%E5%9B%A0%E4%B8%BA%E6%9C%AC%E6%AC%A1%E5%A4%8D%E4%B9%A0%E6%98%AF%E4%BA%89%E5%AF%B9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E4%BC%9A%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%88%BB%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%AA%E4%BC%9A%E7%B2%97%E7%95%A5%E6%89%AB%E8%BF%87">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过</a></em>。</p>
<hr>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>正则表达式用于文本内容的查找和替换，本身不是一种语言或软件。</p>
<h2 id="2-匹配单个字符"><a href="#2-匹配单个字符" class="headerlink" title="2.匹配单个字符"></a>2.匹配单个字符</h2><p><code>.</code>用来匹配单个任意字符，是元字符。如果想要匹配字符<code>.</code>，则要在前面加<code>\</code>，即<code>\.</code>，在<code>[]</code>里的<code>.</code>不是元字符。</p>
<h2 id="3-匹配一组字符"><a href="#3-匹配一组字符" class="headerlink" title="3.匹配一组字符"></a>3.匹配一组字符</h2><p><code>[]</code>定义一个 字符集合，<code>0-9</code>、<code>a-z</code>在<code>[]</code>中表示一个字符区间，用ASCII码确定。<code>^</code>在<code>[]</code>中是取非操作。 <code>abc[^0-9]</code>表示以’abc’开头，并且第四个字符不为数字的字符串。</p>
<h2 id="4-使用元字符"><a href="#4-使用元字符" class="headerlink" title="4.使用元字符"></a>4.使用元字符</h2><p><code>[\b]</code>是删除一个字符的意思；<code>\f</code>匹配换页符，<code>\n</code>匹配换行符，<code>\r</code>匹配回车符，<code>\t</code>匹配制表符，<code>\v</code>匹配垂直制表符。</p>
<p><code>\d</code>等价于<code>[0-9]</code>，<code>\D</code>等价于<code>[^0-9]</code>，<code>\w</code>等价于<code>[a-zA-Z0-9_]</code>大小写字母、下划线和数字。<code>\W</code>等价于<code>[^a-zA-Z0-9_]</code>。<code>\s</code>表示任何一个空白字符，等价于<code>[\f\n\r\t\v]</code>，<code>\S</code>表示对<code>\s</code>取非，等价于<code>[^\f\n\r\t\v]</code>。</p>
<p><code>\x</code>匹配十六进制字符,<code>\0</code>匹配八进制字符，比如<code>\xA</code>对应值为10的ASCII字符，即<code>\n</code>。</p>
<h2 id="5-重复匹配"><a href="#5-重复匹配" class="headerlink" title="5.重复匹配"></a>5.重复匹配</h2><p><code>+</code>匹配1个或多个字符，<code>*</code>匹配0个或多个字符，<code>?</code>匹配0个或1个字符。</p>
<p><code>&#123;n&#125;</code>匹配n个字符，<code>&#123;m,n&#125;</code>匹配m~n个字符，<code>&#123;m,&#125;</code>匹配至少m个字符。</p>
<p><code>[\w]+</code>表示匹配字母数字或下划线很多次，a+c表示1个或多个连续的a加上一个c。</p>
<p><img src="/images/react/2021122114.png"></p>
<p><img src="/images/react/2021122115.png"></p>
<p><code>*</code>和<code>+</code>都是贪婪的，会匹配尽可能多的内容。在后面加?可以转换为懒惰型元字符。</p>
<p><code>a.+c</code>的匹配结果可以是<code>abcabcabc</code>，即明明前三个字符已经满足匹配结果，但因为<code>+</code>是贪婪的所以会匹配尽可能多的字符。</p>
<h2 id="6-位置匹配"><a href="#6-位置匹配" class="headerlink" title="6.位置匹配"></a>6.位置匹配</h2><p><code>\b</code>可以匹配一个单词的边界，边界是指位于<code>\w</code>和<code>\W</code>之间的位置，<code>\B</code>匹配一个不是单词边界的位置。这两种匹配的都是位置，而不是字符串，比如<code>\babc\b</code>匹配的结果是3个字符串。</p>
<p><code>^</code>在字符集合外用作匹配整个字符串的开头，<code>$</code>匹配整个字符串的结尾。</p>
<p><code>^\s*\/\/.*$</code>的意思是匹配一个开头是0到多个空白字符加上<code>//</code>结尾是1个到多个任意字符的一行字符串，如下图所示：</p>
<p><img src="/images/react/2021122118.png"></p>
<h2 id="7-子表达式"><a href="#7-子表达式" class="headerlink" title="7.子表达式"></a>7.子表达式</h2><p><code>(ab)&#123;2,&#125;</code>表示至少两个<code>ab</code>组合元素的字符。可以匹配abab或更多有ab的字符串。</p>
<p><img src="/images/react/2021122113.png"></p>
<p><code>|</code>是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。比如<code>(19|20)\d&#123;2&#125;</code>的意思是匹配’19‘或’20’开头并且后面有两个任意数字的字符串，如下图所示：</p>
<p><img src="/images/react/2021122116.png"></p>
<h2 id="8-回溯引用"><a href="#8-回溯引用" class="headerlink" title="8.回溯引用"></a>8.回溯引用</h2><p>回溯引用使用 <strong>\n</strong> 来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和第n个子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。</p>
<p><code>&lt;(h[1-6])&gt;(\w*?)&lt;\/\1\2&gt;</code>里使用了两个回溯引用，分别引用了第一个表达式和第二个表达式，如下图所示：</p>
<p><img src="/images/react/2021122117.png"></p>
<h2 id="9-替换"><a href="#9-替换" class="headerlink" title="9.替换"></a>9.替换</h2><p>正则表达式也可以应用在文本替换上，这需要两个正则表达式，第一个用来查找，第二个用来替换。例如修改电话号码<code>313-555-1234</code>的格式为<code>(313) 555-1234</code>，则需要1.查找电话，正则表达式为<code>(\d&#123;3&#125;)(-)(\d&#123;3&#125;)(-)(\d&#123;4&#125;)</code>，利用子表达式将电话号码的格式划分。2.替换，正则表达式为<code>($1) $3-$5</code>，表示为在第一个子表达式查找的结果加上 () ，然后加一个空格，在第三个和第五个字表达式查找的结果中间加上 - 进行分隔。</p>
<p><code>\l</code>表示把下一个字符转为小写，<code>\u</code>表示把下一个字符转为大写，<code>\L</code>表示把<code>\L</code>和<code>\E</code>之间的字符全部转为小写，<code>\U</code>表示把<code>\U</code>和<code>\E</code>之间的字符全部转为大写，<code>\E</code>表示结束<code>\L</code>或<code>\U</code>。</p>
<h2 id="10-前后查找"><a href="#10-前后查找" class="headerlink" title="10.前后查找"></a>10.前后查找</h2><p>前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。</p>
<p>向前查找使用 <code>?=</code> 定义，它规定了尾部匹配的内容，这个匹配的内容在<code>?=</code>之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 <code>?&lt;= </code>定义（注: JavaScript 不支持向后匹配，Java 对其支持也不完善）。</p>
<p>如<code>\w+(?=@)</code>表示查找@字符前面的部分，如图所示：</p>
<p><img src="/images/react/2021122119.png"></p>
<h2 id="11-嵌入条件"><a href="#11-嵌入条件" class="headerlink" title="11.嵌入条件"></a>11.嵌入条件</h2><p>条件为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。</p>
<p>比如<code>(\()?abc(?(1)\))</code>的意思是，先看第一个表达式即第一个<code>()</code>里的内容为<code>\(</code>，表达式后面有一个<code>?</code>，目前为止的意思是匹配0或1个<code>(</code>，然后匹配字符串<code>abc</code>，然后遇到第二个子表达式，这个表达式为条件表达式，<code>?(1)</code>为条件，表示第一个表达式内容若成立，则需要执行<code>)</code>匹配，如下图所示：</p>
<p><img src="/images/react/2021122120.png"></p>
<p><code>?(?=-) </code>为前向查找条件，只有在以 - 为前向查找的结尾能匹配<code>\d&#123;5&#125;</code>，才继续匹配 <code>-\d&#123;4&#125;</code> ，如下图所示：</p>
<p><img src="/images/react/2021122121.png"></p>
]]></content>
      <categories>
        <category>计算机基础复习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>前端面试，正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器中的页面循环系统</title>
    <url>/2022/01/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%BE%AA%E7%8E%AF%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<hr>
<p><em>本文来源于<a href="http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82">http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程</a><a href="https://time.geekbang.org/column/intro/216">《浏览器工作原理与实践》_-极客时间</a>。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。</em></p>
<hr>
<p>我们已经知道每个渲染进程都有一个主进程，它需要处理DOM、计算样式、处理布局以及处理JavaScript的各种任务，工作特别繁忙，那么这些任务是如何有条不紊地被主进程处理的呢？这就涉及到了浏览器的休息队列和事件循环系统。</p>
<h2 id="1-消息队列和事件循环"><a href="#1-消息队列和事件循环" class="headerlink" title="1.消息队列和事件循环"></a>1.消息队列和事件循环</h2><h3 id="1-1-单线程处理任务结构"><a href="#1-1-单线程处理任务结构" class="headerlink" title="1.1 单线程处理任务结构"></a>1.1 单线程处理任务结构</h3><p>主线程会有一个事件处理的<u>消息队列</u>，那些需要执行的任务会逐个加入消息队列当中，按照先进先出的顺序被主线程去执行。</p>
<p>但是主线程在运行过程中如何接收新的任务呢？这就涉及到了<u>事件循环机制</u>，在主线程中添加一个循环语句实时监听新任务的产生。</p>
<p>不过在这样的结构下主线程处理的所有任务都是内部任务，而有一些IO任务比如接收键盘消息等外部任务又如何添加到渲染进程的主线程当中呢？IO任务是由<u>IO线程</u>来管理的，当IO线程接收到这些处理事件时会将其添加到主线程的消息队列中，这样渲染主线程就能接收这些外部任务了。</p>
<p>在此基础上渲染进程还会经常接收其他进程的交互处理信息例如网络进程、浏览器进程的相关信息，这些进程产生的事件又是如何添加到渲染进程的消息队列中进行处理的呢？如下图所示，这些跨进程任务和渲染进程的IO线程进行沟通交互来进行任务的传送。</p>
<p><img src="/images/react/2022012401.png"></p>
<p>当需要退出页面时，则会考虑到安全退出渲染进程主线程的问题，chrome会在主线程中设置一个<u>退出标志变量</u>，主线程每次执行完一个任务时都会判断退出标志是否有变化。如果有则会安全推出线程。</p>
<h3 id="1-2-该结构的缺点"><a href="#1-2-该结构的缺点" class="headerlink" title="1.2 该结构的缺点"></a>1.2 该结构的缺点</h3><p>单线程以及先入先出的结构会产生两个问题。</p>
<p>第一：<u>如何处理高优先级任务</u>。比方说DOM节点变化渲染就是个需要优先处理的任务，针对这个情况，<u>微任务</u>就诞生了。我们将消息队列中的任务称为宏任务，每个宏任务都有一个微任务队列。在主线程执行某个宏任务的过程中如果监听接收到哪些需要优先处理的任务，就会把这些任务添加到当前的微任务队列中，当当前的宏任务执行结束后就执行微任务队列中的所有微任务，再继续执行下一个宏任务。</p>
<p>第二：<u>如何解决单个任务执行时长过久的情况</u>。因为是单线程执行，一次只能执行一个任务，当一个任务执行过久就会让人视觉上感受到页面卡顿的效果，针对这种情况，JavaScript采用<u>回调功能</u>来规避问题。</p>
<h3 id="1-3-浏览器中的页面"><a href="#1-3-浏览器中的页面" class="headerlink" title="1.3 浏览器中的页面"></a>1.3 浏览器中的页面</h3><p>可以再chrome的开发者工具中，点击“Performance”标签来查看页面加载的事件执行情况，如下图所示。</p>
<p><img src="/images/react/2022012402.png"></p>
<h2 id="2-Webapi：setTimeout"><a href="#2-Webapi：setTimeout" class="headerlink" title="2.Webapi：setTimeout"></a>2.Webapi：setTimeout</h2><p>setTimeout是一个<u>定时器</u>，用来指定某个函数在多少毫秒之后执行，它会返回一个整数来表示定时器的编号，利用该编号可以取消定时器。以下为使用代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot; 极客时间 &quot;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> timerID = <span class="hljs-built_in">setTimeout</span>(showName,<span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure>

<h3 id="2-1-setTimeout的实现"><a href="#2-1-setTimeout的实现" class="headerlink" title="2.1 setTimeout的实现"></a>2.1 setTimeout的实现</h3><p>定时器的作用就是为了在指定时间内执行某任务，如果将定时器放在普通的消息队列中，有可能在执行该定时器时就已经超过了任务时长。为了解决该问题，JavaScript又引入了<u>延迟队列机制</u>。</p>
<p>当JavaScript创建一个定时器时，渲染经常会将该定时器的回调任务添加到延迟队列当中，其中包括回调任务函数名称、发起时间、延迟执行时间。在主线程中每当处理完一个宏任务就会去执行延迟队列当中那些已经到期的任务。</p>
<h3 id="2-2-使用setTimeout的注意事项"><a href="#2-2-使用setTimeout的注意事项" class="headerlink" title="2.2 使用setTimeout的注意事项"></a>2.2 使用setTimeout的注意事项</h3><p><u>如果当前任务执行时间过久，会影响延迟到期任务执行。</u>因为每次执行延迟队列中的任务都是在执行完一个宏任务之后的事情，如果该宏任务占用太多时间也有可能超过延迟队列中的任务定时时间。</p>
<p><u>如果setTimeout存在嵌套调用，那么系统会设置最短时间为4ms 。</u>当setTimeout的嵌套函数调用超过5次以上，后面每次调用的最小时间间隔为4ms 。所以一些实时性较高的需求不太适合使用setTime。比如JavaScript动画。</p>
<p><u>延迟执行时间有最大值。</u>定时器的执行延迟时间的最大值一般都为2147483647ms (大约24.8天，根据浏览器而异)，如果超出该值则会溢出，所以延迟时间的取值不能超过该值。</p>
<p>使用setTimeout设置的回调函数中的this不符合直觉。</p>
<p>比如以下这段代码的this就是指向全局，输出为1 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name= <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> MyObj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">showName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;<br>&#125;<br><span class="hljs-built_in">setTimeout</span>(MyObj.showName,<span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure>

<h2 id="3-Webapi-XMLHttpRequest"><a href="#3-Webapi-XMLHttpRequest" class="headerlink" title="3.Webapi : XMLHttpRequest"></a>3.Webapi : XMLHttpRequest</h2><p>XMLHttpRequest这个api的引入使得更新网络数据时无需刷新整张页面而直接操作DOM来更新页面内容。在深入理解XMLHttpRequest之前先理解<u>同步回调</u>和<u>异步回调</u>两个概念。</p>
<h3 id="3-1-回调函数VS系统调用栈"><a href="#3-1-回调函数VS系统调用栈" class="headerlink" title="3.1 回调函数VS系统调用栈"></a>3.1 回调函数VS系统调用栈</h3><p>将一个函数作为参数传递给另一个函数，那么作为参数的这个函数就是回调函数（其他情况也可以是回调函数，不一定必须是参数）。回调函数分为同步回调和异步回调，同步回调函数是指在主函数返回之前执行的函数，异步回调则是在主函数外部执行的回调函数，如下代码所示。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//同步回调</span><br><span class="hljs-keyword">let</span> callback = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span>&#123;<br>    console.log(&#x27;i am <span class="hljs-keyword">do</span> homework&#x27;)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">do</span><span class="hljs-constructor">Work(<span class="hljs-params">cb</span>)</span> &#123;<br>    console.log(&#x27;start <span class="hljs-keyword">do</span> work&#x27;)<br>    cb<span class="hljs-literal">()</span><br>    console.log(&#x27;<span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span> work&#x27;)<br>&#125;<br><span class="hljs-keyword">do</span><span class="hljs-constructor">Work(<span class="hljs-params">callback</span>)</span><br><br><span class="hljs-comment">//异步回调</span><br><span class="hljs-keyword">let</span> callback = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span>&#123;<br>    console.log(&#x27;i am <span class="hljs-keyword">do</span> homework&#x27;)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">do</span><span class="hljs-constructor">Work(<span class="hljs-params">cb</span>)</span> &#123;<br>    console.log(&#x27;start <span class="hljs-keyword">do</span> work&#x27;)<br>    set<span class="hljs-constructor">Timeout(<span class="hljs-params">cb</span>,1000)</span>   <br>    console.log(&#x27;<span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span> work&#x27;)<br>&#125;<br><span class="hljs-keyword">do</span><span class="hljs-constructor">Work(<span class="hljs-params">callback</span>)</span><br><span class="hljs-comment">//异步回调</span><br></code></pre></td></tr></table></figure>

<p>在页面的事件循环系统中，每一个消息队列中的任务都有一个系统调用栈，这个类似于JavaScript的调用栈，在当前任务被执行的过程中，同步回调就是在当前主函数的上下文中执行回调函数。异步回调会有两种处理方式：第一种是将异步函数做成一个任务添加到信息队列尾部；2.第二种是异步函数添加到维任务队列中，就可以在当前任务的末尾执行微任务。</p>
<h3 id="3-2-XMLHttpRequest运行机制"><a href="#3-2-XMLHttpRequest运行机制" class="headerlink" title="3.2 XMLHttpRequest运行机制"></a>3.2 XMLHttpRequest运行机制</h3><p>首先通过以下图片可以了解XMLHttpRequest的实行机制。</p>
<p><img src="/images/react/2022012403.png"></p>
<p>先从 XMLHttpRequest 的用法开始，首先看下面这样一段请求代码：</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><code class="hljs qml"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GetWebData</span>(<span class="hljs-params">URL</span>)</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1: 新建 XMLHttpRequest 请求对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 2: 注册相关事件回调处理函数 </span><br><span class="hljs-comment">     */</span><br>    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">switch</span>(xhr.readyState)&#123;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">// 请求未初始化</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot; 请求未初始化 &quot;</span>)<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-comment">//OPENED</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;OPENED&quot;</span>)<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-comment">//HEADERS_RECEIVED</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;HEADERS_RECEIVED&quot;</span>)<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-comment">//LOADING  </span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;LOADING&quot;</span>)<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-comment">//DONE</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status == <span class="hljs-number">200</span>||<span class="hljs-keyword">this</span>.status == <span class="hljs-number">304</span>)&#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.responseText);<br>                &#125;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;DONE&quot;</span>)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    xhr.ontimeout = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ontimeout&#x27;</span>) &#125;<br>    xhr.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;onerror&#x27;</span>) &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 3: 打开请求</span><br><span class="hljs-comment">     */</span><br>    xhr.open(<span class="hljs-string">&#x27;Get&#x27;</span>, URL, <span class="hljs-literal">true</span>);<span class="hljs-comment">// 创建一个 Get 请求, 采用异步</span><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 4: 配置参数</span><br><span class="hljs-comment">     */</span><br>    xhr.timeout = <span class="hljs-number">3000</span> <span class="hljs-comment">// 设置 xhr 请求的超时时间</span><br>    xhr.responseType = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-comment">// 设置响应返回的数据格式</span><br>    xhr.setRequestHeader(<span class="hljs-string">&quot;X_TEST&quot;</span>,<span class="hljs-string">&quot;time.geekbang&quot;</span>)<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 5: 发送请求</span><br><span class="hljs-comment">     */</span><br>    xhr.send();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在封装请求时的第一步，创建XMLHttpRequest对象，第二步为xhr对象注册回调函数，第三步配置基础的请求信息，第四步发起请求。</p>
<h3 id="3-3-XMLHttpRequest使用过程中的”坑“"><a href="#3-3-XMLHttpRequest使用过程中的”坑“" class="headerlink" title="3.3 XMLHttpRequest使用过程中的”坑“"></a>3.3 XMLHttpRequest使用过程中的”坑“</h3><p><strong>跨域问题</strong>：默认情况下，跨域请求是不被允许的。</p>
<p><strong>HTTPS混合内容问题</strong>：HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。通常，如果 HTTPS 请求页面中使用混合内容，浏览器会针对 HTTPS 混合内容显示警告，用来向用户表明此 HTTPS 页面包含不安全的资源。</p>
<h2 id="4-宏任务与微任务"><a href="#4-宏任务与微任务" class="headerlink" title="4.宏任务与微任务"></a>4.宏任务与微任务</h2><h3 id="4-1-宏任务"><a href="#4-1-宏任务" class="headerlink" title="4.1 宏任务"></a>4.1 宏任务</h3><p>页面中大部分任务都是在渲染进程的主线程上执行的，包括渲染事件（解析DOM、计算布局、绘制），用户交互事件、JavaScript脚本执行事件，网络请求完成，文件读写完成事件等。为了让这些任务有条不紊在主线程上执行而引入了消息队列和事件循环机制，在消息队列中的任务就是宏任务。</p>
<h3 id="4-2-微任务"><a href="#4-2-微任务" class="headerlink" title="4.2 微任务"></a>4.2 微任务</h3><p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前。有两种方式可以创造微任务，分别是使用<u>MutationObserver</u>以及使用<u>Promise</u>。从V8引擎上分析，在执行一段JavaScript任务时JavaScript引擎会创建一个全局执行上下文，这个执行上下文中就包括微任务队列，在该JavaScript脚本执行结束前即即将销毁其执行上下文时会先检测其为任务队列，直到为任务队列彻底没有内容后才会销毁。</p>
<h3 id="4-3-监听DOM变化方法演变"><a href="#4-3-监听DOM变化方法演变" class="headerlink" title="4.3 监听DOM变化方法演变"></a>4.3 监听DOM变化方法演变</h3><p>监听DOM变化是前端工程师一项非常核心的需求。一开始监听DOM的变化是设置<u>setTimeout或者setInterval</u>来定时检测DOM是否有变化，这个问题会有事件间隔长短以及资源消耗等问题，2000年的时候引入了<u>Mutation Event</u>，这个方法采用观察者设计模式，当DOM有变动时就会立刻触发相应的事件，采用的方法是同步回调。但是Mutation Event让每一次DOM发送变化要立刻调用JavaScript接口，这种实时性造成严重的性能问题，为了解决其同步回调产生的性能问题而引入了<u>MutionObserver</u>。它采用”异步+微任务“的策列来解决这些问题。</p>
<h2 id="5-Promise和async-await"><a href="#5-Promise和async-await" class="headerlink" title="5.Promise和async await"></a>5.Promise和async await</h2><h3 id="5-1-异步编码问题"><a href="#5-1-异步编码问题" class="headerlink" title="5.1 异步编码问题"></a>5.1 异步编码问题</h3><p>Promise解决了异步编码风格的问题。看普通的异步回调情况，如下代码所示。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 执行状态</span><br><span class="hljs-keyword">function</span> on<span class="hljs-constructor">Resolve(<span class="hljs-params">response</span>)</span>&#123;console.log(response) &#125;<br><span class="hljs-keyword">function</span> on<span class="hljs-constructor">Reject(<span class="hljs-params">error</span>)</span>&#123;console.log(error) &#125;<br><br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-constructor">XMLHttpRequest()</span><br>xhr.ontimeout = <span class="hljs-keyword">function</span>(e) &#123; on<span class="hljs-constructor">Reject(<span class="hljs-params">e</span>)</span>&#125;<br>xhr.onerror = <span class="hljs-keyword">function</span>(e) &#123; on<span class="hljs-constructor">Reject(<span class="hljs-params">e</span>)</span> &#125;<br>xhr.onreadystatechange = <span class="hljs-keyword">function</span> <span class="hljs-literal">()</span> &#123; on<span class="hljs-constructor">Resolve(<span class="hljs-params">xhr</span>.<span class="hljs-params">response</span>)</span> &#125;<br><br><span class="hljs-comment">// 设置请求类型，请求 URL，是否同步信息</span><br><span class="hljs-keyword">let</span> URL = &#x27;https:<span class="hljs-comment">//time.geekbang.com&#x27;</span><br>xhr.<span class="hljs-keyword">open</span>(&#x27;Get&#x27;, URL, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 设置参数</span><br>xhr.timeout = <span class="hljs-number">3000</span> <span class="hljs-comment">// 设置 xhr 请求的超时时间</span><br>xhr.responseType = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-comment">// 设置响应返回的数据格式</span><br>xhr.set<span class="hljs-constructor">RequestHeader(<span class="hljs-string">&quot;X_TEST&quot;</span>,<span class="hljs-string">&quot;time.geekbang&quot;</span>)</span><br><br><span class="hljs-comment">// 发出请求</span><br>xhr.send<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure>

<p>这一个网络请求多次使用了异步回调，使得代码逻辑显得不连贯和不线性。所以可以封装该请求使得符合我们的观看直觉。但即使封装之后也会出现低于回调的问题，这使得代码陷入一个非常混乱的局面，引入promise就可以很好解决低于回调的问题。（其实promise我也研究不是很透彻，包括后面的async await ，以后有时间仔细学习，这里就不细讲了）</p>
<h3 id="5-2-async-await"><a href="#5-2-async-await" class="headerlink" title="5.2 async await"></a>5.2 async await</h3><p>即使promise能够解决异步回调编码风格问题使其看起来更能理解，但是过多的<u>then方法</u>依旧似乎有着语义化不明显的问题，所以<u>ES7</u>引入了<u>async await</u>很好解决了这个问题。async await使得异步回掉函数的写法和同步回调几乎一样，视觉上一目了然非常简介。</p>
<p>async await其实背后的技术就是promise和生成器的应用。如下代码所示就是一个生成器的应用。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genDemo</span><span class="hljs-params">()</span></span> &#123;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot; 开始执行第一段 &quot;</span>)<br>    <span class="hljs-built_in">yield</span> <span class="hljs-string">&#x27;generator 2&#x27;</span><br><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot; 开始执行第二段 &quot;</span>)<br>    <span class="hljs-built_in">yield</span> <span class="hljs-string">&#x27;generator 2&#x27;</span><br><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot; 开始执行第三段 &quot;</span>)<br>    <span class="hljs-built_in">yield</span> <span class="hljs-string">&#x27;generator 2&#x27;</span><br><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot; 执行结束 &quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;generator 2&#x27;</span><br>&#125;<br><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;main 0&#x27;</span>)<br>let gen = genDemo()<br>console.<span class="hljs-built_in">log</span>(gen.<span class="hljs-built_in">next</span>().value)<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;main 1&#x27;</span>)<br>console.<span class="hljs-built_in">log</span>(gen.<span class="hljs-built_in">next</span>().value)<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;main 2&#x27;</span>)<br>console.<span class="hljs-built_in">log</span>(gen.<span class="hljs-built_in">next</span>().value)<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;main 3&#x27;</span>)<br>console.<span class="hljs-built_in">log</span>(gen.<span class="hljs-built_in">next</span>().value)<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;main 4&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>执行这个函数观察输出结果可以发现genDemo并不是一次执行完成的，全局代码和genDemo代码交易执行，这就是<u>生成器函</u>数的特性。</p>
<p>这里就涉及到了<u>协程</u>的概念，我们已经知道进程和线程的概念，一个进程里有多个线程，相类似的一个线程里也有多个协程，并且同一时间只能执行一个协程。如果从A协程启动了B协程，那么我们就将A协程称为B协程的<u>父协程</u>。如上代码就是执行在一个线程内的程序，但是它有两个协程，全局的父协程以及genDemo所对应的子协程。他们的连接和应用关系如下图所示。</p>
<p><img src="/images/react/2022012404.png"></p>
<p>我们可以知道：第一、在生成器函数内部执行一段代码，如果遇到<u> yield </u>关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。外部函数可以通过<u> next</u> 方法恢复函数的执行。</p>
<p>我们必须知道一个线程中的协程是<u>交互执行</u>而不是并发执行的，它们的切换是通过yield和gen.next来配合完成的。另外，当gen协程中调用了yied方法时，JavaScript引擎就会保留gen协程当前的<u>调用栈</u>信息，并恢复父协程的调用栈信息；同样当父协程中执行gen.next时也会保留父协程的调用栈信息而恢复gen协程的调用栈信息，可以参考下图所示。</p>
<p><img src="/images/react/2022012405.png"></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基础知识点</title>
    <url>/2021/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<p><em>本文来源于<a href="https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。</a></em></p>
<hr>
<h2 id="1-network、internet、Internet的区别"><a href="#1-network、internet、Internet的区别" class="headerlink" title="1.network、internet、Internet的区别"></a>1.network、internet、Internet的区别</h2><p>network是计算机的网络，把计算机主机连接起来（有很多种网络，包括局域网、广域网等），而internet则是把<u>广域网</u>的一种，是泛指，不一定采取TCP/IP协议；internet是网络的网络。Internet是全球最大最开放的internet，<u>采用TCP/IP协议</u>。</p>
<h2 id="2-ISP"><a href="#2-ISP" class="headerlink" title="2.ISP"></a>2.ISP</h2><p>ISP（Internet Service Provider 互联网服务提供商）在互联网<u>主干网上</u>提供相应服务使个体设备接入互联网。在中国比较热门的互联网提供商有移动、联通、电信等。</p>
<h2 id="3-主机之间通信方式"><a href="#3-主机之间通信方式" class="headerlink" title="3.主机之间通信方式"></a>3.主机之间通信方式</h2><p><strong>C/S 客户-服务器方式：</strong>以服务器为核心提供客户资源</p>
<p><strong>P2P 点对点方式：</strong>双方对等、共享资源（比如迅雷下载）</p>
<h2 id="4-电路交换、分组交换"><a href="#4-电路交换、分组交换" class="headerlink" title="4.电路交换、分组交换"></a>4.电路交换、分组交换</h2><p><strong>电路交换：</strong>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终<u>占用</u>该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p>
<p><strong>分组交换：</strong>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换<u>不需要占用传输线路</u>。</p>
<h2 id="5-计算机网络体系结构"><a href="#5-计算机网络体系结构" class="headerlink" title="5.计算机网络体系结构"></a>5.计算机网络体系结构</h2><p>OSI 国际标准的网络体系结构，共有七层，自下往上分别是<u>物理层、数据链路层、网络层、运输层、会话层、应用层</u>。</p>
<p>TCP/IP协议是民间运用最广泛的网络协议，它简化了OSI协议，只有四层，自下往上是<u>网络接口层、网际层、运输层、应用层</u>。</p>
<p>因为上面两个结构有层数太多或太少的问题，所以往往采取折中的方式即五层协议的体系架构，它自下往上分别是<u>物理层、数据链路层、网络层、运输层、应用层</u>。</p>
<p><strong>物理层</strong>：传输的是可以通过<u>物理介质</u>运输的数据比特流。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p>
<p><strong>数据链路层</strong>：物理寻址，同时将原始的比特流转变为<u>逻辑传输路线</u>。主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧，该层涉及到的协议有<u>以太网协议、点对点协议</u>。</p>
<p><strong>网络层</strong>：它通过路由选择算法，为分组通过通信子网选择最适当的路径，以实现网络的互连功能。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、流量控制、拥塞控制等将信息从一台网络设备传送到另一台网络设备。该层协议的代表包括<u>IP、IPX 协议</u>等。</p>
<p><strong>运输层</strong>：该层是通信子网和资源子网的接口和桥梁，起到了承上启下的作用。该层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时对数据进行分割然后将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此,运输层负责提供主机中<u>两个进程之间数据的可靠传送</u>。运输层的目的是向用户透明地传送报文，它向高层屏蔽了下层数据通信的细节。该层主要有两种协议：<u>TCP协议、UDP协议</u>。</p>
<p><strong>会话层</strong>：其主要任务是负责维护两个实体之间的会话连接确保点到点的传输不被中断，并进行会话管理和数据交换管理，即组织和协调两个会话进程之间的通信，并对数据交换进行管理。</p>
<p><strong>表示层</strong>：主要功能是协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异,，以使一个主机应用层的数据可以被另一个主机的应用层理解。</p>
<p><strong>应用层</strong>：用户应用程序和网络之间的接口，完成用户希望在网络上完成的各种工作。该层的协议有<u>HTTP、DNS协议</u>，数据单位为<u>报文</u>。</p>
<p>TCP/IP协议相当于五层协议的下面两层合并成一层（网络接口层）。</p>
<h2 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6.应用层"></a>6.应用层</h2><p><strong>DNS：</strong>域名解析，提供了主机名和IP地址相互转化的服务，域名的层次结构如下所示：</p>
<p><img src="/images/react/2021122001.png"></p>
<p>DNS使用的端口是53，可以使用UDP或TCP协议，如果返回的响应超过512字节或者是区域传输则会使用TCP进行运输。</p>
<p><strong>FTP：</strong>使用TCP进行连接，需要两个连接（控制连接、数据连接）来传输一个文件。端口：20、21.有主动传输和被动传输两种模式。</p>
<p><strong>DHCP：</strong>动态主机配置协议.一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。</p>
<p>电子邮件协议：一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。发送协议常用<strong>SMTP</strong>（只能发送ASCII码，MIMI扩充了SMTP，可以发送非ASCII码）、读取协议常用POP3（阅后即焚，最新版本可不焚）和IMAP。</p>
<p><strong>常用端口：</strong>如下图所示：</p>
<p><img src="/images/react/2021122002.png"></p>
<p>须知0-1023是熟知端口，客服端生产的随机端口必须大于1024。</p>
<h2 id="7-传输层（报文）"><a href="#7-传输层（报文）" class="headerlink" title="7.传输层（报文）"></a>7.传输层（报文）</h2><h3 id="7-1-UDP和TCP的区别"><a href="#7-1-UDP和TCP的区别" class="headerlink" title="7.1 UDP和TCP的区别"></a>7.1 UDP和TCP的区别</h3><p>UDP 用户数据报协议，无连接，尽最大可能交付，没有拥塞控制，面对报文（应用层传下来的报文，只在其头部添加UDP首部），支持一对一、一对多、多对一、多对多的连接。</p>
<p>TCP面向连接，提供可靠交付，有拥塞控制（TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复），提供全双工通信，面向字节流（应用层传下来的报文看成字节流，并拆分成数据块），连接一对一。</p>
<h3 id="7-2-UDP首部"><a href="#7-2-UDP首部" class="headerlink" title="7.2 UDP首部"></a>7.2 UDP首部</h3><p>UDP的首部有8字节以及12字节的伪首部，伪首部是为了计算检验而临时添加，首部8字节包括2字节源端口和目的端口，2字节长度和检验和。以下为UDP首部示意图：</p>
<p><img src="/images/react/2021122003.png"></p>
<h3 id="7-3-TCP首部"><a href="#7-3-TCP首部" class="headerlink" title="7.3 TCP首部"></a>7.3 TCP首部</h3><p>TCP首部长度不固定，有20字节的固定头部，具体情况如下图所示：</p>
<p><img src="/images/react/2021122004.png"></p>
<p>序号：当前报文的序号，下一个报文的序号则为前一个报文的序号加上前一个报文的长度。</p>
<p>确认号：因为TCP协议是可靠的一对一协议，所以当前报文发出时也要有希望接收到的下一个报文的序号，将接收到的下一个报文的序号则是前一个报文的确认号。</p>
<p>数据偏移：实际就是TCP报文头部长度。</p>
<p>确认位ACK：只有当ACK=1时确认号字段才有效。</p>
<p>同步位SYN：建立连接时用来同步序号。SYN=1,ACK=0表示这是一个请求连接报文，SYN=1,ACK=1是同意连接的响应报文。</p>
<p>终止位FIN：FIN=1表示释放一个连接。</p>
<h3 id="7-4-TCP的三次握手"><a href="#7-4-TCP的三次握手" class="headerlink" title="7.4 TCP的三次握手"></a>7.4 TCP的三次握手</h3><p>第一次握手：客服端向服务端发送请求报文，其中ACK=0,SYN=1。</p>
<p>第二次握手：服务端返回客服端一个响应报文，其中SYN=1,ACK=1。</p>
<p>第三次握手：客服端向服务端发送确认报文，其中SYN=0,ACK=1。</p>
<p>三次握手成功建立连接。</p>
<p><strong>需要三次握手的原因（面试题）：</strong></p>
<p>三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。如果没有三次握手，会出现这种现象，客户端发送请求访问报文给服务端，但是这个报文在网络中受阻延迟没有及时传达到，而超时后客户端会再次发送请求报文给服务端，此时服务端就会收到并且要处理先后两条请求报文，有了三次握手，客户端会忽略服务器发送的第二条响应请求报文，不会进行第三次握手。</p>
<h3 id="7-5-TCP的四次挥手"><a href="#7-5-TCP的四次挥手" class="headerlink" title="7.5 TCP的四次挥手"></a>7.5 TCP的四次挥手</h3><p>在客户端要关闭服务时需要和服务端进行四次挥手。</p>
<p>第一次挥手：客户端向服务端发送释放请求报文，其中FIN=1</p>
<p>第二次挥手：TCP处于半关闭状态，客户端无法再发送报文给服务端，服务端可以向客户端发送服务器端发送还未传送完毕的数据。</p>
<p>第三次挥手：服务端向客户端发送释放报文，FIN=1</p>
<p>第四次挥手：客户端向服务端发送确认报文，等待2MSL后释放应用。服务端收到确认报文后释放应用。</p>
<p><strong>四次挥手的原因（面试题）：</strong></p>
<p>客户端发送释放报文后，TCP处于半关闭状态，这个状态能让服务端继续发送未传送完毕的数据，数据传完后，服务器会发送释放报文。</p>
<p><strong>四次挥手过程中TIME_WAIT的原因（面试题）：</strong></p>
<p>在客户端收到服务端的FIN释放报文时回有2MSL（MSL 一个报文在网络中最大的存活时间）的等待时间，这是为了确保自己发送给服务端的确认报文能顺利传达，若出现意外则可以再次发送。也可让这段连续时间内产生的报文在网络中消失以避免干扰之后的连接请求。</p>
<h2 id="8-网络层（分组）"><a href="#8-网络层（分组）" class="headerlink" title="8.网络层（分组）"></a>8.网络层（分组）</h2><p>网络层是整个互联网的核心，其中最关键的就是IP协议，其将异构的物理网络连接起来。与IP协议配套的还有地址解析协议ARP、网际控制报文协议ICMP、网际组管理协议IGMP。</p>
<h3 id="8-1-IP协议"><a href="#8-1-IP协议" class="headerlink" title="8.1 IP协议"></a>8.1 IP协议</h3><p>通过IP地址，保证了联网设备的唯一性，实现了网络通信的面向无连接和不可靠的传输功能。</p>
<p>IP地址的偏执方式经历了三个历史阶段：分类、子网划分、无分类。</p>
<p><strong>分类</strong>：32位的IP地址根据网络号的长度（8、16、24位）分为A、B、C类地址以及多播地址D类、今后使用地址E类。具体几类地址的区别如下所示：</p>
<p><img src="/images/react/2021122005.png"></p>
<p><strong>子网划分</strong>：对于局域网内部的网络可进行子网划分，首先需要配置子网掩码。</p>
<p><strong>无分类</strong>：无分类编制CIDR消除了以上两种情况概念，使用网络前缀和主机号来对IP地址进行编码。如128.14.35.7/20 就是使用CIDR进行表示，其代表前 20 位为网络前缀。</p>
<h3 id="8-2-ARP协议"><a href="#8-2-ARP协议" class="headerlink" title="8.2 ARP协议"></a>8.2 ARP协议</h3><p>ARP协议实现了通过IP地址获得<u>MAC地址</u>。MAC地址是主机的硬件地址。每个主机都有一个<u>ARP高速缓存</u>，即IP地址到MAC地址的映射表。如果主机A没有主机B的MAC地址，只要获得其IP地址，通过广播的形式将访问信息发送给B，B 收到请求就将其MAC地址发送给A，这样A就可以通过ARP发送信息给B了。</p>
<h3 id="8-3-ICMP协议"><a href="#8-3-ICMP协议" class="headerlink" title="8.3 ICMP协议"></a>8.3 ICMP协议</h3><p>ICMP协议是为了更有效地转发IP数据包，它被封装在IP数据报中，但不属于高层协议。<u>Ping</u>是ICNMP的一个重要应用，主要用来测试两台主机之间的连通性。</p>
<h3 id="8-4-虚拟专用网VPN"><a href="#8-4-虚拟专用网VPN" class="headerlink" title="8.4 虚拟专用网VPN"></a>8.4 虚拟专用网VPN</h3><p>因为实际的主机数要远远大于IP地址，并且也不需要把所有的主机接入到外部的互联网中，所以就有了专用地址，即机构内的计算机可使用仅在本机构有效的IP地址。VPN使用公用的互联网作为本机构各个专用网之间的通信载体，其功能是在公用网络上建立专用网络，进行加密通讯，即只要本机构的主机才能进行通讯。</p>
<h3 id="8-5-网络地址转换NAT"><a href="#8-5-网络地址转换NAT" class="headerlink" title="8.5 网络地址转换NAT"></a>8.5 网络地址转换NAT</h3><p>专用网内部主机想要和互联网上的主机进行通讯时即要使用NAT进行IP地址的转换，把本地IP转为全球IP。</p>
<h3 id="8-6-路由选择协议"><a href="#8-6-路由选择协议" class="headerlink" title="8.6 路由选择协议"></a>8.6 路由选择协议</h3><p>内部路由选择协议有<u>RIP</u>和<u>OSPF</u>协议。RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。为了克服RIP的缺点而开发了OSPF协议，即开放最短路径优先。</p>
<p>外部路由选择协议有<u>BGP</u>协议——边界网关协议。</p>
<h2 id="9-数据链路层（帧）"><a href="#9-数据链路层（帧）" class="headerlink" title="9.数据链路层（帧）"></a>9.数据链路层（帧）</h2><h3 id="9-1-基本问题"><a href="#9-1-基本问题" class="headerlink" title="9.1 基本问题"></a>9.1 基本问题</h3><p><strong>封装成帧</strong>：链路层以帧的形式进行传输，需要将网络层的分组添加首部和尾部用于标记帧的开始和结束。</p>
<p><strong>透明传输</strong>：如果帧内部有首部或尾部相同的内容就容易错误定位帧的位置，所以需要在帧内部添加响应的<u>转义字符</u>以解决该问题。</p>
<p><strong>差错检测</strong>：目前使用最广泛的是<u>CRC</u>（循环冗余检验）来检查比特差错。</p>
<h3 id="9-2-信道分类"><a href="#9-2-信道分类" class="headerlink" title="9.2 信道分类"></a>9.2 信道分类</h3><p>分为广播信道和点对点信道，广播信道是一对多通信，采用<u>CSMA/CD协议</u>，表示载波监听多点接入/碰撞检测；点对点信道是一对一通信，采用<u>PPP协议</u>，这是一种用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p>
<h3 id="9-3-信道复用技术"><a href="#9-3-信道复用技术" class="headerlink" title="9.3 信道复用技术"></a>9.3 信道复用技术</h3><p>包括频分复用、时分复用、波分复用、码分复用。</p>
<h3 id="9-4-局域网、以太网与虚拟局域网"><a href="#9-4-局域网、以太网与虚拟局域网" class="headerlink" title="9.4 局域网、以太网与虚拟局域网"></a>9.4 局域网、以太网与虚拟局域网</h3><p>局域网是一种<u>广播信道</u>，以太网是<u>特殊的局域网</u>。局域网的特点为网络是一个单位所拥有，且地理位置和站点数目均有限。按照拓扑结构可将局域网分为<u>星型、环形、直线型</u>；以太网是一种星型局域网，早期使用集线器作为传输数据的物理设备，作用于比特而非帧，现在使用<u>交换机</u>，这是一种链路层设备。交换机具有学习功能，学习交换表的内容，交换表存储着MAC地址到接口的映射。<u>虚拟局域网</u>建立了与物理位置无关的逻辑组，只有在同一个虚拟局域网内的成员才能收到链路层广播信息。</p>
<h2 id="10-物理层"><a href="#10-物理层" class="headerlink" title="10.物理层"></a>10.物理层</h2><h3 id="10-1-通信方式"><a href="#10-1-通信方式" class="headerlink" title="10.1 通信方式"></a>10.1 通信方式</h3><p>根据信息的传输方向分为单工通信（单向传输）、半双工通信（双向交替传输）、全双工通信（双向同时传输）。</p>
<h3 id="10-2-带通调制"><a href="#10-2-带通调制" class="headerlink" title="10.2 带通调制"></a>10.2 带通调制</h3><p>带通调制将离散的数字信号转为连续的模拟信号。</p>
]]></content>
      <categories>
        <category>计算机基础复习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>前端面试</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象思想知识点</title>
    <url>/2021/12/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<hr>
<p><em>本文来源于<a href="https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82%E5%B9%B6%E4%B8%94%E5%9B%A0%E4%B8%BA%E6%9C%AC%E6%AC%A1%E5%A4%8D%E4%B9%A0%E6%98%AF%E4%BA%89%E5%AF%B9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E4%BC%9A%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%88%BB%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%AA%E4%BC%9A%E7%B2%97%E7%95%A5%E6%89%AB%E8%BF%87">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过</a></em>。</p>
<hr>
<h2 id="1-三大特性"><a href="#1-三大特性" class="headerlink" title="1.三大特性"></a>1.三大特性</h2><p><strong>封装</strong>：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。具有<u>减少耦合、减轻维护负担、提高软件可重用性</u>等特点。</p>
<p><strong>继承</strong>：继承实现了 <u>IS-A</u> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>
<p><strong>多态</strong>：分为<u>编译时多态</u>和<u>运行时多态</u>。编译时多态主要指方法重载，运行时多态指程序中定义对象引用所指的具体类型在运行期间才确定。</p>
<h2 id="2-类图"><a href="#2-类图" class="headerlink" title="2.类图"></a>2.类图</h2><p>类图用来描述实体之间的关系，在类途中存在以下几种关系：</p>
<p><strong>泛化关系</strong>：用来描述<u>继承</u>关系，在 Java 中使用 extends 关键字，如下图所示。</p>
<p><img src="/images/2021122106.png"></p>
<p><strong>实现关系</strong>：用来实现一个<u>接口</u>，在 Java 中使用 implements 关键字，如下图所示。</p>
<p><img src="/images/2021122107.png"></p>
<p><strong>聚合关系</strong>：表示整体由部分组成，但是整体和部分<u>不是强依赖</u>的，整体不存在了部分还是会存在，如下图所示。</p>
<p><img src="/images/2021122108.png"></p>
<p><strong>组合关系</strong>：组合中整体和部分是<u>强依赖</u>的，整体不存在了部分也不存在了，如下图所示。</p>
<p><img src="/images/2021122109.png"></p>
<p><strong>关联关系</strong>：表示不同类对象之间有关联，这是一种<u>静态关系</u>，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示，如下图所示。</p>
<p><img src="/images/2021122110.png"></p>
<p><strong>依赖关系</strong>：依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：A 类是 B 类方法的局部变量；A 类是 B 类方法的参数；A 类向 B 类发送消息，从而影响 B 类发生变化，如下图所示。</p>
<p><img src="/images/2021122110.png"></p>
<h2 id="3-设计原则"><a href="#3-设计原则" class="headerlink" title="3.设计原则"></a>3.设计原则</h2><p><strong>S.O.L.I.D</strong>：分别为单一责任原则、开放封闭原则、里氏替换原则、接口分离原则、依赖倒置原则。</p>
]]></content>
      <categories>
        <category>计算机基础复习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>前端面试，面向对象思想</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器中JavaScript执行机制</title>
    <url>/2021/12/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%ADJavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<hr>
<p><em>本文来源于<a href="http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82">http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程<a href="https://time.geekbang.org/column/intro/216">《浏览器工作原理与实践》_-极客时间</a>。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。</a></em></p>
<hr>
<h2 id="1-变量提升"><a href="#1-变量提升" class="headerlink" title="1.变量提升"></a>1.变量提升</h2><p>使用过JavaScipt的程序员都清除JavaScipt是按顺序执行的，不过看以下代码的输出结果，就会发现似乎并没有按’顺序’执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">showName()<br><span class="hljs-built_in">console</span>.log(myname)<br><span class="hljs-keyword">var</span> myname = <span class="hljs-string">&#x27;极客时间&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;函数showName被执行&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行结果如下图所示：</p>
<p><img src="/images/react/2021122701.png"></p>
<p>据图可知，在变量和函数进行声明之前就调用了它们，但是依旧能够执行。并且函数能够正常执行但是变量却是<code>underfined</code>。如果删掉变量声明，即上述代码的第三行，那么执行结果又会是什么呢？如下图所示，代码会报错。</p>
<p><img src="/images/react/2021122702.png"></p>
<p>可见如果在下文定义了变量和函数，那么在上文中使用该变量和函数时不会报错，不过函数可以顺利输出结果，但是变量却是<code>underfined</code>，而如果在下文没有定义，则会报错。这种情况被称为<u>变量提升</u>。</p>
<h3 id="1-1-什么是变量提升"><a href="#1-1-什么是变量提升" class="headerlink" title="1.1 什么是变量提升"></a>1.1 什么是变量提升</h3><p>首先先要了解<u>声明和赋值</u>的概念，对于下面这行代码：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">varname</span> = <span class="hljs-string">&#x27;name&#x27;</span><br></code></pre></td></tr></table></figure>

<p>其实可以分为两个阶段，即变量的声明阶段和变量赋值阶段：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> <span class="hljs-keyword">name</span> = underfined<br><span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;name&#x27;</span><br></code></pre></td></tr></table></figure>

<p>而争对函数可以看下段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>&#125;<span class="hljs-comment">//这个函数定义本身就是函数声明</span><br><br><span class="hljs-keyword">var</span> bar=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bar&#x27;</span>)<br>&#125;<br><span class="hljs-comment">//变量声明 var bar = underfined</span><br><span class="hljs-comment">//变量赋值 var = function()&#123; ... &#125;</span><br></code></pre></td></tr></table></figure>

<p>可见对于函数来说，<u>函数声明</u>就是函数定义本身。</p>
<p>变量提升就是在JavaScipt代码执行过程中，把变量和函数的声明部分提到代码开头的行为，对于变量声明会设置默认值即<code>underfined</code>。</p>
<p>如下图所示，就是我们的第一段代码进行变量提升后造成的效果。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//先进行变量提升，即提取变量和函数的声明</span><br><span class="hljs-selector-tag">var</span> myname = underfined<br>function showName()&#123;<br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;showName被调用&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">//再是代码的可执行部分</span><br><span class="hljs-function"><span class="hljs-title">showName</span><span class="hljs-params">()</span></span><br>console<span class="hljs-selector-class">.log</span>(myname)<br>myname=<span class="hljs-string">&#x27;极客时间&#x27;</span><span class="hljs-comment">//去掉原来的var变量声明，变成变量赋值操作</span><br></code></pre></td></tr></table></figure>

<p>上面就是变量提升带来的效果，其实一共就是两个步骤：1.提取变量和函数的声明放在代码顶部，对于变量声明进行<code>underfined</code>赋值。2.再执行代码可执行部分，对于原先的声明进行去除操作。</p>
<h3 id="1-2-Java代码的执行流程"><a href="#1-2-Java代码的执行流程" class="headerlink" title="1.2 Java代码的执行流程"></a>1.2 Java代码的执行流程</h3><p>在了解什么是变量声明后，我们会以为变量声明的过程中是将代码的顺序进行改变的过程，但其实并不是，<u>实际上代码的位置并没有改变</u>，变量和函数声明的位置也没有变。JavaScipt的执行流程如下图所示：</p>
<p><img src="/images/react/2021122703.png"></p>
<p>其中，变量提升的实现其实是在<u>编译阶段</u>实现的。输入一段代码，经过编译后会生成两部分内容：执行上下文和可执行代码。如下图所示：</p>
<p><img src="/images/react/2021122704.png"></p>
<p>据图可知，在执行上下文中会保存代码的<u>环境变量</u>，其中就包括变量声明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">showName()<br><span class="hljs-built_in">console</span>.log(myname)<br><span class="hljs-keyword">var</span> myname = <span class="hljs-string">&#x27;极客时间&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;函数showName被执行&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于这段代码，编辑阶段的JavaScript引擎会对其进行分析处理，第1行第2行代码因为不是变量？函数声明则不进行处理，第3行是变量声明，于是JavaScipt引擎会在环境对象中创造一个myname的属性并初始化为<code>underfined</code>，第4行则是一个函数声明，JavaScript引擎会将函数定义存储岛堆中，并在环境对象中创建一个showName属性，将该属性指向堆中函数的位置。接下来JavaScipt会将声明以外的代码编译成字节码。这样就有了包含环境对象（变量声明）的执行上下文和可执行代码了。</p>
<p>接下来就是进行执行阶段。在执行阶段，JavaScipt引擎是按照可执行代码的顺序一步一步执行的，争对上面这段代码的可执行部分就是：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">showName</span><span class="hljs-params">()</span></span><br>console<span class="hljs-selector-class">.log</span>(myname)<br>myname=<span class="hljs-string">&#x27;极客时间&#x27;</span><br></code></pre></td></tr></table></figure>

<p>执行第1行时，JavaScript引擎会先在执行上下文的变量环境中寻找与此函数同名的属性，如果找到，就输出该属性的引用结果。</p>
<p>执行第2行时，JavaScipt引擎同理在变量环境中查找<code>myname</code>属性，找到后就输出该属性值。</p>
<p>执行第3行时，会将变量环境中的<code>myname</code>属性的值改为“极客时间”。</p>
<p>以上就是变量提升在JavaScipt实际编译流程中的实现原理。</p>
<p>3.代码中出现相同的变量/函数怎么办</p>
<p>如下列代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;极客邦&#x27;</span>);<br>&#125;<br>showName();<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;极客时间&#x27;</span>);<br>&#125;<br>showName(); <br></code></pre></td></tr></table></figure>

<p>实际上在编译阶段获取变量环境时就会将已有的showName属性在第一次定义后进行第二次修改，或者是覆盖第一次定义。所以实际运行时两个函数输出的结果是相同的，都是‘极客时间’。</p>
<h2 id="2-调用栈"><a href="#2-调用栈" class="headerlink" title="2.调用栈"></a>2.调用栈</h2><p>上面一节通过变量提升的概率了解了JavaScipt引擎的编译过程，接下来具体深入该过程，这一节了解的是调用栈这一概念。</p>
<h3 id="2-1-什么是函数调用"><a href="#2-1-什么是函数调用" class="headerlink" title="2.1 什么是函数调用"></a>2.1 什么是函数调用</h3><p>函数调用就是运行一个函数，如下列代码所示：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span><br>function add()&#123;<br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-number">10</span><br>return  a+<span class="hljs-selector-tag">b</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>其中<code>add()</code>就是一个函数调用。根据这段代码按照上一节所学的可以知道，再进行add函数调用前会创建<u>执行上下文</u>，其中包括了变量环境，但这就涉及到了全局变量和局部变量的问题，在函数内部定义的变量又是怎么进行执行上下文创建的呢。</p>
<p>这就是一个顺序问题，首先获得这段JavaScript代码，JavaScript引擎会先创建一个<u>全局执行上下文</u>。在全局执行上下文中有变量环境如下所示：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">VariableEnvironment：<br>    <span class="hljs-keyword">a</span> -&gt; underfined,<br>    <span class="hljs-built_in">add</span> -&gt; <span class="hljs-function"><span class="hljs-keyword">function</span>: &#123;</span><br>    var b=<span class="hljs-number">10</span><br>    <span class="hljs-literal">return</span> <span class="hljs-keyword">a</span>+b<br>&#125;<br></code></pre></td></tr></table></figure>

<p>搭建好全局的执行上写文后就进行全局的可执行代码执行，此时调用add函数，又要建立<u>函数内的执行上下文</u>，函数内的环境变量如下所示：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl">VariableEnvironment：<br>    <span class="hljs-function"><span class="hljs-title">b</span> -&gt;</span> underfined<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后再执行函数内的可执行代码。具体的流程如下图所示：</p>
<p><img src="/images/react/2021122705.png"></p>
<p>这其中就需要建立两个执行上下文，但JavaScript是怎么不把它们弄混的呢？这就涉及到了<u>栈</u>的概念。栈就是一种<u>先入后出</u>的结构。</p>
<h3 id="2-2-什么是JavaScript的调用栈"><a href="#2-2-什么是JavaScript的调用栈" class="headerlink" title="2.2 什么是JavaScript的调用栈"></a>2.2 什么是JavaScript的调用栈</h3><p>JavaScript引擎就是利用栈的结构来管理执行上下文的，在执行上下文创建好后会将其压入栈中，这样的栈就叫做调用栈。</p>
<p>看下面这段代码：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">var a = <span class="hljs-number">2</span><br><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(b,c)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">b+c</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title">addAll</span>(b,c)&#123;<br>var d = 10<br>result = add(b,c)<br><span class="hljs-keyword">return</span>  <span class="hljs-type">a+result+d</span><br>&#125;<br>addAll(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure>

<p>这段代码的执行过程为第一步，创建全局上下文，并将其压入栈底，如下图所示：</p>
<p><img src="/images/react/2021122706.png"></p>
<p>然后执行全局代码。</p>
<p>当运行到调用addAll函数时进行第二步，创建该函数的执行上下文，并将其压入栈中，如下图所示：</p>
<p><img src="/images/react/2021122707.png"></p>
<p>之后就进入该函数代码的执行阶段。</p>
<p>当执行到add函数的调用语句时就进行到第三步，为其创建执行上下文，并压入栈中，如下图所示：</p>
<p><img src="/images/react/2021122708.png"></p>
<p>当ad函数返回时，调用栈会将顶部的执行上下文弹出，然后继续执行，直到返回到只剩下全局执行上下文为止。调用栈是JavaScript引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能追踪到哪个函数正在被执行以及各函数之间的调用关系。</p>
<h3 id="2-3-在开发中使用调用栈"><a href="#2-3-在开发中使用调用栈" class="headerlink" title="2.3 在开发中使用调用栈"></a>2.3 在开发中使用调用栈</h3><p>利用浏览器查看调用栈：比如打开Chrome的开发者工具，在Sources中打开页面，在相关的JavaScript上设置断点，并且刷新运行，然后在右侧的call stack中就可以看到调用栈。如下图所示。</p>
<p><img src="/images/react/2021122709.png"></p>
<p>在call stack中最底层的(anonymous)就是全局执行上下文。</p>
<p>使用<code>console.trace()</code>来输出当前函数的调用关系，如下段代码所示：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span><br>function add(<span class="hljs-selector-tag">b</span>,c)<br>&#123; console<span class="hljs-selector-class">.trace</span>()<span class="hljs-comment">//输出当前函数的调用关系</span><br>  return b+c<br>&#125;<br>function addAll(<span class="hljs-selector-tag">b</span>,c)&#123;<br><span class="hljs-selector-tag">var</span> d = <span class="hljs-number">10</span><br>result = add(<span class="hljs-selector-tag">b</span>,c)<br>return  a+result+d<br>&#125;<br><span class="hljs-function"><span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)</span></span><br></code></pre></td></tr></table></figure>

<p>上面代码的输出结果如下图所示。</p>
<p><img src="/images/react/2021122710.png"></p>
<h3 id="2-4-栈溢出"><a href="#2-4-栈溢出" class="headerlink" title="2.4 栈溢出"></a>2.4 栈溢出</h3><p>需要知道的是调用栈是有大小的，所以当栈内的执行上下文数量超过一定值时，JavaScript引擎就会报错，这种情况就叫做<u>栈溢出</u>。</p>
<p>如下段代码所示：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">division</span>(a,b)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">division(a,b)</span><br>&#125;<br>console.log(division(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure>

<p>执行后会出下如图所示报错：</p>
<p><img src="/images/react/2021122711.png"></p>
<p>解决栈溢出的问题是<u>尽量避免回调函数的方法</u>，可以使用循环语句来代替回调函数。</p>
<p>如下端代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runStack</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>  <span class="hljs-keyword">return</span> runStack( n- <span class="hljs-number">2</span>);<br>&#125;<br>runStack(<span class="hljs-number">50000</span>)<br><span class="hljs-comment">//这段代码就会产生栈溢出的问题，可以进行以下优化</span><br><br><br><span class="hljs-comment">// 优化</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runStack</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 防止陷入死循环</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>        &#125;<br><br>        n = n - <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(runStack(<span class="hljs-number">50000</span>));<br></code></pre></td></tr></table></figure>

<p>上面这段代码的优化就是使用了while循环来代替了递归函数。</p>
<h2 id="3-块级作用域"><a href="#3-块级作用域" class="headerlink" title="3.块级作用域"></a>3.块级作用域</h2><p>在上面两节中提到了JavaScript的变量提升现象，这会造成很多误解问题，为了解决这种缺陷ES6引入了<u>let和cons</u>t来解决。let&amp;const使用块级作用域来解决了这个问题。</p>
<h3 id="3-1-作用域"><a href="#3-1-作用域" class="headerlink" title="3.1 作用域"></a>3.1 作用域</h3><p>作用域就是变量能够访问的范围，JavaScript只有两种作用域：<u>全局作用域、函数作用域</u>。而其他许多语言则还有<u>块级作用域</u>，即用<code>&#123;&#125;</code>包围的区间就可以称为一个块级作用域，比如在Java中以下代码都是块级作用域：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//if块</span><br><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>&#123;&#125;<br><br><span class="hljs-comment">//while块</span><br><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>&#123;&#125;<br><br><span class="hljs-comment">//函数块</span><br>function foo()&#123;<br><br><span class="hljs-comment">//for循环块</span><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(let i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++)</span></span>&#123;&#125;<br><br><span class="hljs-comment">//单独一个块</span><br>&#123;&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-2-ES6中的let和const"><a href="#3-2-ES6中的let和const" class="headerlink" title="3.2 ES6中的let和const"></a>3.2 ES6中的let和const</h3><p>因为JavaScript的最初设计理念比较简单，所以它存在很多由于没有块级作用域带来的问题，为了解决这些问题，ES6引用了let和const关键字，让其也能像其他语言一样拥有块级作用域。</p>
<p>let和const分别是定义变量和常量的关键字，如下列代码所示，使用这两个关键字就能够使用块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">letTest</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 不同的变量</span><br>    <span class="hljs-built_in">console</span>.log(x);  <span class="hljs-comment">// 2</span><br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(x);  <span class="hljs-comment">// 1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果使用var，则两个输出的都是2 。</p>
<h3 id="3-3-JavaScript如何支持块级作用域"><a href="#3-3-JavaScript如何支持块级作用域" class="headerlink" title="3.3 JavaScript如何支持块级作用域"></a>3.3 JavaScript如何支持块级作用域</h3><p>我们已知JavaScript实现变量提升的原理，那它又是怎么在此基础上又可以实现支持块级作用域的呢？看以下代码来进行解释分析。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">function foo()&#123;<br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">1</span><br>    let <span class="hljs-selector-tag">b</span> = <span class="hljs-number">2</span><br>    &#123;<br>      let <span class="hljs-selector-tag">b</span> = <span class="hljs-number">3</span><br>      <span class="hljs-selector-tag">var</span> c = <span class="hljs-number">4</span><br>      let d = <span class="hljs-number">5</span><br>      console<span class="hljs-selector-class">.log</span>(a)<br>      console<span class="hljs-selector-class">.log</span>(b)<br>    &#125;<br>    console<span class="hljs-selector-class">.log</span>(b) <br>    console<span class="hljs-selector-class">.log</span>(c)<br>    console<span class="hljs-selector-class">.log</span>(d)<br>&#125;   <br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>当进入这个foo函数时，会创建该函数的执行上下文，首先会将所有的var变量定义存储在执行上下文的变量环境中，同时将属于函数作用域的let or const 变量存储在执行上下文的词法环境中，如图所示。</p>
<p><img src="/images/react/2022011001.png"></p>
<p>此时该函数的执行上下文环境已经定义完成，就需要使用JavaScript引擎执行代码，当执行到函数内部的第一个块级作用域<code>&#123;&#125;</code>时，foo函数的执行上下文如图所示。</p>
<p><img src="/images/react/2022011002.png"></p>
<p>此时var变量a和let变量b已经被赋值。而由于进入了let的作用域，而在词法环境中创建了一个新栈，存储该块级作用域中的变量。</p>
<p>之后当执行到块级作用域中的<code>console.log(a)</code>时，JavaScript引擎就会按照以下步骤来搜索变量。</p>
<p><img src="/images/react/2022011003.png"></p>
<p>当执行完块级作用域时，词法环境中相应区间就会从栈顶弹出，如图所示。</p>
<p><img src="/images/react/2022011004.png"></p>
<p>如下截图所示为改代码的输出结果。</p>
<p><img src="/images/react/2022011005.png"></p>
<p>最后因为块级作用域所占内存已经销毁，所以找不到该let变量。</p>
<h3 id="3-4-思考题"><a href="#3-4-思考题" class="headerlink" title="3.4 思考题"></a>3.4 思考题</h3><p>观察以下代码的输出结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> myname= <span class="hljs-string">&#x27;极客时间&#x27;</span><br>&#123;<br>  <span class="hljs-built_in">console</span>.log(myname) <br>  <span class="hljs-keyword">let</span> myname= <span class="hljs-string">&#x27;极客邦&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>会出现以下报错。</p>
<p><img src="/images/react/2022011006.png"></p>
<p>因为在块级作用域中，从<code>开始到let myname= &#39;极客邦&#39;</code>代码之间会形成一个暂时性死区，如果中间去访问变量<code>myname</code>，会报初始化之前不能访问<code>myname</code>的错误。</p>
<h2 id="4-作用域链和闭包"><a href="#4-作用域链和闭包" class="headerlink" title="4.作用域链和闭包"></a>4.作用域链和闭包</h2><h3 id="4-1-作用域链"><a href="#4-1-作用域链" class="headerlink" title="4.1 作用域链"></a>4.1 作用域链</h3><p>当涉及到多个作用域中访问变量的情况就要提到作用域链。像以下代码。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">function</span> <span class="hljs-function"><span class="hljs-title">bar</span>() &#123;</span><br><span class="hljs-function">    <span class="hljs-variable">console.log</span>(<span class="hljs-variable">myName</span>)</span><br>&#125;<br><span class="hljs-variable">function</span> <span class="hljs-function"><span class="hljs-title">foo</span>() &#123;</span><br><span class="hljs-function">    <span class="hljs-variable">var</span> <span class="hljs-variable">myName</span> = <span class="hljs-string">&quot; 极客邦 &quot;</span></span><br><span class="hljs-function">    <span class="hljs-title">bar</span>()</span><br>&#125;<br><span class="hljs-variable">var</span> <span class="hljs-variable">myName</span> = <span class="hljs-string">&quot; 极客时间 &quot;</span><br><span class="hljs-function"><span class="hljs-title">foo</span>()</span><br></code></pre></td></tr></table></figure>

<p>该代码在bar函数中会输出myName的值，根据上面几节所学，该代码会生成以下的执行上下文调用栈。</p>
<p><img src="/images/react/2022011007.png"></p>
<p>在执行代码阶段，bar函数的执行上下文中没有的变量myName应该在哪里找呢，这里其实每一个执行上下文的环境变量中都有一个称为<code>outer</code>的外部引用，当该作用域中没有需要的变量，则会向<code>outer</code>指向的作用域中去查找。那么bar函数的<code>outer</code>会指向哪里呢？如下图所示为各个执行上下文的变量环境outer的指向。</p>
<p><img src="/images/react/2022011008.png"></p>
<p>为什么bar函数的outer指向的不是foo函数而是全局呢？这就涉及到<u>函数声明的位置</u>。函数声明的位置觉得了该函数的outer指向，根据该定理观察该代码，可以看出bar和foo函数的声明位置都是在全局，所以它们的outer指向也都是全局。如果bar函数在foo函数内部定义，则它的outer会指向foo函数。这涉及到了<u>词法作用域</u>。</p>
<p>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</p>
<p>如下图所示。</p>
<p><img src="/images/react/2022011009.png"></p>
<p>该图所示的词法作用域链顺序是：foo 函数作用域—&gt;bar 函数作用域—&gt;main 函数作用域—&gt; 全局作用域。</p>
<h3 id="4-2-块级作用域中的变量查找"><a href="#4-2-块级作用域中的变量查找" class="headerlink" title="4.2 块级作用域中的变量查找"></a>4.2 块级作用域中的变量查找</h3><p>观察以下代码：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">function bar() &#123;<br>    var <span class="hljs-attr">myName</span> = <span class="hljs-string">&quot; 极客世界 &quot;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">test1</span> = <span class="hljs-number">100</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-attr">myName</span> = <span class="hljs-string">&quot;Chrome 浏览器 &quot;</span><br>        console.log(test)<br>    &#125;<br>&#125;<br>function foo() &#123;<br>    var <span class="hljs-attr">myName</span> = <span class="hljs-string">&quot; 极客邦 &quot;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">test</span> = <span class="hljs-number">2</span><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-attr">test</span> = <span class="hljs-number">3</span><br>        bar()<br>    &#125;<br>&#125;<br>var <span class="hljs-attr">myName</span> = <span class="hljs-string">&quot; 极客时间 &quot;</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">myAge</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">test</span> = <span class="hljs-number">1</span><br>foo()<br></code></pre></td></tr></table></figure>

<p>分析其调用栈结构如下图所示：</p>
<p><img src="/images/react/2022011010.png"></p>
<p>图中标出的顺序就是其查找变量的顺序。</p>
<h3 id="4-3-闭包"><a href="#4-3-闭包" class="headerlink" title="4.3 闭包"></a>4.3 闭包</h3><p>观察以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 极客时间 &quot;</span><br>    <span class="hljs-keyword">let</span> test1 = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">const</span> test2 = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">var</span> innerBar = &#123;<br>        <span class="hljs-attr">getName</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(test1)<br>            <span class="hljs-keyword">return</span> myName<br>        &#125;,<br>        <span class="hljs-attr">setName</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newName</span>)</span>&#123;<br>            myName = newName<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> innerBar<br>&#125;<br><span class="hljs-keyword">var</span> bar = foo()<br>bar.setName(<span class="hljs-string">&quot; 极客邦 &quot;</span>)<br>bar.getName()<br><span class="hljs-built_in">console</span>.log(bar.getName())<br></code></pre></td></tr></table></figure>

<p>其中，当执行代码时，会运行函数foo，也就会生成foo的执行上下文，但是执行完后foo的执行上下文就会在<u>内存中销毁</u>。但是在后面两行中却调用了foo的内部方法setName和getName，而这两个方法则使用了其外部函数foo函数的变量，此时变量myName和test1不会被销毁，而变成了<u>专属</u><code>bar.setName</code>和<code>bar.getName</code>方法能使用的变量，这种情况就可以把这些只能够被特定函数访问的变量集合称之为<u>闭包</u>。</p>
<p><img src="/images/react/2022011011.png"></p>
<p>那这些闭包是如何使用的呢？如下图所示：</p>
<p><img src="/images/react/2022011012.png"></p>
<p>据图可知其执行顺序为setName函数执行上下文-&gt;该函数的闭包-&gt;全局执行上下文。</p>
<p>也可以利用浏览器中的开发者工具来跟踪其查找变量顺序，如图所示。</p>
<p><img src="/images/react/2022011013.png"></p>
<h3 id="4-4-闭包回收"><a href="#4-4-闭包回收" class="headerlink" title="4.4 闭包回收"></a>4.4 闭包回收</h3><p>如果引用闭包的函数是全局变量，那么该闭包就会一直存在直到页面关闭，如果引用闭包的函数是局部变量，那么该闭包会随着函数的销毁而销毁。所以使用闭包需要注意：<u>当闭包会一直使用则定义其函数为全局变量，否则就定义为局部变量。</u></p>
<h3 id="4-5-思考题"><a href="#4-5-思考题" class="headerlink" title="4.5 思考题"></a>4.5 思考题</h3><p>观察下面代码，其输出结果是什么，会形成闭包吗？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> bar = &#123;<br>    <span class="hljs-attr">myName</span>:<span class="hljs-string">&quot;time.geekbang.com&quot;</span>,<br>    <span class="hljs-attr">printName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(myName)<br>    &#125;    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> myName = <span class="hljs-string">&quot; 极客时间 &quot;</span><br>    <span class="hljs-keyword">return</span> bar.printName<br>&#125;<br><span class="hljs-keyword">let</span> myName = <span class="hljs-string">&quot; 极客邦 &quot;</span><br><span class="hljs-keyword">let</span> _printName = foo()<br>_printName()<br>bar.printName()<br></code></pre></td></tr></table></figure>

<p>这道题其实是个障眼法，只需要确定好函数调用栈就可以很轻松的解答，调用了foo()后，返回的是bar.printName，后续就跟foo函数没有关系了，所以结果就是调用了两次bar.printName()，根据词法作用域，<u>结果都是“极客邦”，也不会形成闭包</u>。</p>
<p>如下图所示。</p>
<p><img src="/images/react/2022011014.png"></p>
<p>（其实我也有点糊涂了。）</p>
<h2 id="5-this"><a href="#5-this" class="headerlink" title="5.this"></a>5.this</h2><h3 id="5-1-JavaScript中的this是什么？"><a href="#5-1-JavaScript中的this是什么？" class="headerlink" title="5.1 JavaScript中的this是什么？"></a>5.1 JavaScript中的this是什么？</h3><p>this其实和执行上下文有关，执行上下文一共有三种，分别是<u>全局执行上下文、函数执行上下文和eval执行上下文</u>。每个执行上下文中都包括我们已经知道的变量环节、词法环境以及outer。除此之外，this也包含在执行上下文中。所以根据不同的执行上下文，this也有所不同。</p>
<h3 id="5-2-全局执行上下文中的this"><a href="#5-2-全局执行上下文中的this" class="headerlink" title="5.2 全局执行上下文中的this"></a>5.2 全局执行上下文中的this</h3><p>直接在浏览器的开发者工具控制台中输入<code>console.log(this)</code>，可以看到输出的是window对象，因此可知，<u>全局执行上下文中的this指向window对象</u>，这也是this和作用域链的唯一交点，作用域链最底端包含了window对象。</p>
<h3 id="5-3-函数执行上下文中的this"><a href="#5-3-函数执行上下文中的this" class="headerlink" title="5.3 函数执行上下文中的this"></a>5.3 函数执行上下文中的this</h3><p>观察以下这段代码：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">function</span> <span class="hljs-function"><span class="hljs-title">foo</span>()&#123;</span><br><span class="hljs-function">  <span class="hljs-variable">console.log</span>(<span class="hljs-variable">this</span>)</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">foo</span>()</span><br></code></pre></td></tr></table></figure>

<p>观察输出结果会发现，这个this依旧是指向window。那么可以改变函数内的this指向吗？可以的，有以下几种方法。</p>
<p><strong>1.通过函数的call方法设置</strong></p>
<p>如下列代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> bar = &#123;<br>  <span class="hljs-attr">myName</span> : <span class="hljs-string">&quot; 极客邦 &quot;</span>,<br>  <span class="hljs-attr">test1</span> : <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">this</span>.myName = <span class="hljs-string">&quot; 极客时间 &quot;</span><br>&#125;<br>foo.call(bar)<br><span class="hljs-built_in">console</span>.log(bar)<br><span class="hljs-built_in">console</span>.log(myName)<br></code></pre></td></tr></table></figure>

<p>通过<code>foo.call(bar)</code>使得foo函数执行上下文中的this指向了bar。除了<u>call方法</u>，也可以使用<u>bind和apply方法</u>来设置函数执行上下文中的this。</p>
<p><strong>2.通过对象调用方法设置</strong></p>
<p>如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObj = &#123;<br>  <span class="hljs-attr">name</span> : <span class="hljs-string">&quot; 极客时间 &quot;</span>, <br>  <span class="hljs-attr">showThis</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>  &#125;<br>&#125;<br>myObj.showThis()<br></code></pre></td></tr></table></figure>

<p>当执行<code>myObj.showThis()</code>时就会使得<code>showThis</code>中的<code>this</code>指向<code>myObj</code>对象。</p>
<p><strong>3.通过构造函数中设置</strong></p>
<p>如下代码所示：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CreateObj</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">this</span>.name = <span class="hljs-string">&quot; 极客时间 &quot;</span><br>&#125;<br><span class="hljs-keyword">var</span> myObj = <span class="hljs-keyword">new</span> CreateObj()<br></code></pre></td></tr></table></figure>

<p>使用<code>new</code>关键字来使函数中的this指向了新对象本身。</p>
<h3 id="5-3-this的涉及缺陷以及应对方案"><a href="#5-3-this的涉及缺陷以及应对方案" class="headerlink" title="5.3 this的涉及缺陷以及应对方案"></a>5.3 this的涉及缺陷以及应对方案</h3><p>比方说嵌套函数中的this<u>没有继承关系</u>，如段代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObj = &#123;<br>  <span class="hljs-attr">name</span> : <span class="hljs-string">&quot; 极客时间 &quot;</span>, <br>  <span class="hljs-attr">showThis</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)&#125;<br>    bar()<br>  &#125;<br>&#125;<br>myObj.showThis()<br></code></pre></td></tr></table></figure>

<p>直觉上我们会以为bar函数内部的this也是指向showThis也就是它的外部函数，但其实它指向的是window，解决方法有两种，第一种是在bar函数外使用<code>var that=this</code>，在bar函数内使用that就代指showThis中的this，如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObj = &#123;<br>  <span class="hljs-attr">name</span> : <span class="hljs-string">&quot; 极客时间 &quot;</span>, <br>  <span class="hljs-attr">showThis</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>    <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>&#123;<br>      that.name = <span class="hljs-string">&quot; 极客邦 &quot;</span><br>    &#125;<br>    bar()<br>  &#125;<br>&#125;<br>myObj.showThis()<br><span class="hljs-built_in">console</span>.log(myObj.name)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.name)<br></code></pre></td></tr></table></figure>

<p>第二个方法是使用ES6中的<u>箭头函数</u>来声明bar函数，如下段代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObj = &#123;<br>  <span class="hljs-attr">name</span> : <span class="hljs-string">&quot; 极客时间 &quot;</span>, <br>  <span class="hljs-attr">showThis</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>    <span class="hljs-keyword">var</span> bar = <span class="hljs-function">()=&gt;</span>&#123;<br>      <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot; 极客邦 &quot;</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>    &#125;<br>    bar()<br>  &#125;<br>&#125;<br>myObj.showThis()<br><span class="hljs-built_in">console</span>.log(myObj.name)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.name)<br></code></pre></td></tr></table></figure>

<p>因为箭头函数不会创建自身的执行上下文。</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>JavaScript</tag>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>宏观视角下的浏览器</title>
    <url>/2021/12/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<hr>
<p><em>本文来源于<a href="http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。">http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。</a></em></p>
<hr>
<h2 id="1-浏览器发展史"><a href="#1-浏览器发展史" class="headerlink" title="1.浏览器发展史"></a>1.浏览器发展史</h2><h3 id="1-1-单进程浏览器"><a href="#1-1-单进程浏览器" class="headerlink" title="1.1 单进程浏览器"></a>1.1 单进程浏览器</h3><p>2007年之前，市面上的浏览器都是单进程的，单进程浏览器把需要运行的所有功能模块都放在一个进程里，而模块分为几个线程在进程里运行，这会导致如下几个问题。</p>
<p><strong>不稳定问题</strong>：一个线程崩溃就会导致整个进程崩溃，也就是整个浏览器崩溃。</p>
<p><strong>不流畅问题</strong>：单进程浏览器中，页面模块在一个线程中运行，如果该线程中有一个<u>无限循环的脚本</u>，那页面的其他模块就无法运行，会导致页面无法加载的问题。除此之外，单进程浏览器很容易出现页面<u>内存泄漏</u>从而导致计算机内存占用越来越高，浏览器运行越来越慢的问题。</p>
<p><strong>不安全问题</strong>：在单进程浏览器中很容易让一些<u>恶意插件或脚本</u>释放病毒，获得计算机重要信息。</p>
<h3 id="1-2-早期多进程浏览器"><a href="#1-2-早期多进程浏览器" class="headerlink" title="1.2 早期多进程浏览器"></a>1.2 早期多进程浏览器</h3><p>2008年Chrome的发布宣告浏览器进入多进程时代，早期的浏览器多进程架构是将各个插件从浏览器主进程中分离开独立成单个的进程，也将每个页面线程从主进程分离变成独立的每个渲染进程。这些被分割的进程都运行在<u>沙箱</u>中，进程之间通过<u>IPC</u>（进程间通信）进行通信。这种多进程模块的好处是让各个功能模块相互隔离，这样一个模块的问题导致的奔溃不会导致整个浏览器崩溃，解决了不稳定性问题。并且也因为独立的进程，使得一个页面脚本出现问题时不会影响整个浏览器以及独立的其他页面的运行（每个页面都是一个渲染进程），争对内存泄漏也可以通过关闭一个页面回收内存的方式解决，这就解决了不稳定性问题。此外，因为独立出来的功能模块进程都在sandbox（沙箱）中运行，受到一定的限制，无法读取计算机敏感位置的数据，所以安全性问题也得到了解决。</p>
<h3 id="1-3-目前多进程浏览器"><a href="#1-3-目前多进程浏览器" class="headerlink" title="1.3 目前多进程浏览器"></a>1.3 目前多进程浏览器</h3><p>对比于早期的多进程架构，目前的Chrome又独立于浏览器主进程之外还多出了几个进程，包括<u>GPU进程、网络服务进程、缓存服务进程、备用渲染进程</u>。</p>
<p>打开Chrome的任务管理器，下面显示的就是chrome浏览器中运行的进程，如图所示：</p>
<p><img src="/images/react/2021122201.png"></p>
<p>多进程模型提高了浏览器的稳定性、流畅性以及安全性，但也带来了一定的问题，比如它占用了更高的资源，因为每个进程都会包含公共基础结构的副本；以及该模型有着更复杂的体系架构，这意味着浏览器各模块之间的<u>耦合性高、扩展性差</u>等问题。面对这些问题，现在的浏览器公司一直都在寻找更好的处理方法。</p>
<h3 id="1-4-未来面向服务的架构"><a href="#1-4-未来面向服务的架构" class="headerlink" title="1.4 未来面向服务的架构"></a>1.4 未来面向服务的架构</h3><p>在2016年，Chrome团队就使用<u>面向服务架构</u>（SOA）的思想设计了新的Chrome架构，也就是说未来的浏览器会朝着SOA的方向发展，原来的各个模块会被重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务就必须使用定义好的接口，这样就可以建立一个<u>更加内聚、更低的耦合度，更加易于维护和扩展</u>的系统。但这必将是一个漫长的过程。</p>
<h2 id="2-数据包从服务端完整传达给客服端浏览器的过程"><a href="#2-数据包从服务端完整传达给客服端浏览器的过程" class="headerlink" title="2.数据包从服务端完整传达给客服端浏览器的过程"></a>2.数据包从服务端完整传达给客服端浏览器的过程</h2><p>打开一个网页会显示各种信息，这些信息都是从这个网站的服务器端发送过来的，那么这些信息又是怎么包装完整地传达到客户端的浏览器上的呢？</p>
<h3 id="2-1-数据包从服务端送达到目的主机"><a href="#2-1-数据包从服务端送达到目的主机" class="headerlink" title="2.1 数据包从服务端送达到目的主机"></a>2.1 数据包从服务端送达到目的主机</h3><p>数据必定是先从服务器运输到客户端的主机，才能从主机上升到具体的应用程序。两个主机之间的信息通信在网络体系模型的<u>网络层</u>中实现的，其中数据的运输则依靠于网络层中的<u>IP协议</u>。网络层传输的数据是以“分组”形式存在的，每一个分组都有一个头部，头部包含了源主机和目的主机的<u>IP地址</u>，依靠IP地址就可以实现两个主机之间的通信。</p>
<h3 id="2-2-数据包从客户端主机到应用进程"><a href="#2-2-数据包从客户端主机到应用进程" class="headerlink" title="2.2 数据包从客户端主机到应用进程"></a>2.2 数据包从客户端主机到应用进程</h3><p>通过网络层的IP协议可以实现主机之间的网络通信，但是IP协议是个相对底层的协议，无法实现应用进程之间的通信，这需要通过网络层上一层的<u>传输层</u>才能实现通信。传输层通常有两个常用的协议，分别是<u>UDP协议</u>和<u>TCP协议</u>，通过两个协议在传输层产生的数据包都有一个头部，头部都包含了<u>源端口号和目的端口号</u>的信息，这个端口号就是具体的应用程序在主机上的端口号，根据端口号就可以实现数据包从客户端主机到应用进程的运输。</p>
<h3 id="2-3-数据包可靠完整地被传达"><a href="#2-3-数据包可靠完整地被传达" class="headerlink" title="2.3 数据包可靠完整地被传达"></a>2.3 数据包可靠完整地被传达</h3><p>上节提到的UDP协议和TCP协议都是在传输层的协议，它们之间的区别是：UDP协议追求的是<u>快速</u>地传输，而TCP协议追求的是<u>完整</u>地传输，这就会导致UDP协议传输的数据很容易丢失，而TCP协议却保护了数据的完整性。在浏览器中运用到的应用层协议，无论是http协议还是WebSocket协议都使用TCP协议传输数据，从而保证了数据的完整性。那么TCP协议是如何做到完整传输数据的呢？</p>
<p>区别于UDP协议，基于TCP协议有更复杂更加多数据的头部，包括数据包序号、确认号、数据偏移等信息，这些信息能够将混乱的数据包组合成一个完整的文件，并且对于缺失的数据包，TCP提供了重传机制。</p>
<p>此外，为了保证数据传输的可靠性，进行TCP协议实际数据的传输前后分别由“三次握手”和“四次挥手来进行可靠的连接建立和断开。</p>
<p>TCP协议需要进行三次握手的原因是为了防止失效的连接请求到达服务器，让服务器错误打开连接（具体详细解析可见”计算机网络基础知识点“的7.4节）。</p>
<h2 id="3-HTTP请求流程"><a href="#3-HTTP请求流程" class="headerlink" title="3.HTTP请求流程"></a>3.HTTP请求流程</h2><p>HTTP协议是<u>应用层</u>协议，是浏览器使用最广泛的协议，通过它可以实现浏览器向服务器获取相关资源。HTTP协议建立在TCP协议基础之上，上一节已经知道通过TCP协议实现数据从服务器传输到浏览器中，那么浏览器又是怎么通过HTTP协议发送请求的呢？这节主要讲HTTP请求的具体流程。</p>
<h3 id="3-1-构建请求"><a href="#3-1-构建请求" class="headerlink" title="3.1 构建请求"></a>3.1 构建请求</h3><p>通常访问一个网站的第一步就是在浏览器的地址栏中输入一个网站地址并点击跳转，这时就会构建一个请求，但是这个请求还在浏览器端，并没有开始运输。</p>
<h3 id="3-2-查找缓存"><a href="#3-2-查找缓存" class="headerlink" title="3.2 查找缓存"></a>3.2 查找缓存</h3><p>在发送请求之前，浏览器会根据已经构建好的请求的基本数据在<u>缓存</u>中进行查找，如果有所需的数据，则它会直接拦截结束该请求，直接使用缓存中的副本，这样就能缓解服务器压力，也加快了浏览器上资源加载速度。</p>
<h3 id="3-3-获取服务端的IP地址和端口"><a href="#3-3-获取服务端的IP地址和端口" class="headerlink" title="3.3 获取服务端的IP地址和端口"></a>3.3 获取服务端的IP地址和端口</h3><p>如果缓存中没有所需的数据，则要开始发送请求，但是根据第2节可知，实现一个数据包的运输需要知道对方主机的IP地址和端口号，所以需要先获取IP地址以及端口号。如何通过一个URL网址获得IP地址就要涉及<u>DNS协议</u>，浏览器已知的URL又被称为域名，域名和IP地址呈现一对一映射关系，通过DNS协议访问<u>域名服务器</u>可以获得所需要的IP地址，或者如果之前该浏览器访问过某网页，那么缓存中可能会存有该网络的IP地址。对于端口号，如果URL中没有特别指明端口号，那么HTTP协议默认的端口号是<u>80</u> 。</p>
<h3 id="3-4-等待TCP队列，建立TCP连接"><a href="#3-4-等待TCP队列，建立TCP连接" class="headerlink" title="3.4 等待TCP队列，建立TCP连接"></a>3.4 等待TCP队列，建立TCP连接</h3><p>浏览器一般都有一个限制，即同一域名同时只能建立一定数量的TCP连接，如果超过这个数量，只能进入队列进行等待，若未超过这个数量，则能直接建立TCP连接，TCP连接的具体方式如第2大节所示。</p>
<h3 id="3-5-发送HTTP请求"><a href="#3-5-发送HTTP请求" class="headerlink" title="3.5 发送HTTP请求"></a>3.5 发送HTTP请求</h3><p>建立了TCP连接，实现了TCP的三次握手，才能真正的发送HTTP请求。一个HTTP请求报文由<u>请求行、请求头部和请求体</u>组成，具体如下图所示：</p>
<p><img src="/images/react/2021122202.png"></p>
<p>其中，请求行包括了<u>请求方法</u>（GET/POST/DELETE…）、<u>请求URL</u>以及<u>HTTP协议版本号</u>。请求头部包括了一些基础信息，比如浏览器所使用的操作系统、浏览器内核等信息。</p>
<h3 id="3-6-服务器返回请求响应"><a href="#3-6-服务器返回请求响应" class="headerlink" title="3.6 服务器返回请求响应"></a>3.6 服务器返回请求响应</h3><p>服务器接收到浏览器的HTTP请求后，则会处理相应请求，如果服务器选择响应某些请求，就会发送客户端浏览器以HTTP响应数据信息，其中包括<u>响应行、响应头部和具体的响应体</u>。</p>
<p>其中响应行包括<u>HTTP协议版本</u>和<u>状态码</u>信息，比如状态码为200则表示处理成功，状态码为404则表示没有响应页面。</p>
<h3 id="3-7-断开连接"><a href="#3-7-断开连接" class="headerlink" title="3.7 断开连接"></a>3.7 断开连接</h3><p>通常情况下，一旦服务器向客户端返回了请求数据，就会断开TCP协议，如果浏览器或服务器在其HTTP请求头部或者响应头部中加上了<code>Connection:keep-alive</code>，则该TCP连接就会保持打开状态。</p>
<h3 id="3-8-重定向"><a href="#3-8-重定向" class="headerlink" title="3.8 重定向"></a>3.8 重定向</h3><p>有时候会出现这种情况：用户在浏览器的地址栏中输入的URL在网页打开后会变成另外一个，这就涉及到了重定向。比如在我的火狐浏览器的地址栏中输入<code>sixteentime.github.io</code>，但是它马上跳转成网站<code>sixteentime.xyz</code>，这就是一个重定向的过程，可以打开该网站打开时的第一个响应报文，观察其响应头信息中有这样一行信息:<code>Location: http://sixteentime.xyz/ </code>这就执行了一个重定向流程，具体如下图所示：</p>
<p><img src="/images/react/2021122203.png"></p>
<h3 id="3-9相关问题"><a href="#3-9相关问题" class="headerlink" title="3.9相关问题"></a>3.9相关问题</h3><p><strong>为什么很多网站第二次打开的速度会很快？</strong></p>
<p>这是上面提到的浏览器<u>缓存机制</u>的原因。当网站第一次打开网站时，浏览器里没有该网站的缓存，浏览器则会发送请求给服务端请求数据，服务端返回数据给浏览器时，浏览器也会把页面数据存入缓存，然后在缓存的<u>生命周期</u>内再次打开该页面时，浏览器就不会发送请求给服务器而是直接使用缓存资源，这样就会使网站运行速度加快；若超过了这个生命周期，那么浏览器会担心这个缓存数据可能会过期，就会发送请求给服务器，如果服务器返回该缓存数据没有过期，那么浏览器会继续使用缓存数据加载页面，这样的加载速度也会相对较快。</p>
<p>当然，浏览器的缓存中还有域名与IP地址的映射信息，第二次打开页面不需要发送请求到域名服务器获取域名对应的IP地址，也可以加快网页的加载速度。</p>
<p><strong>网站的登录状态是如何保持的？</strong></p>
<p>一般而言，服务器为了防止非系统用户的恶意攻击，对系统的访问方法都需要用户登陆信息，可是在浏览器中操作的用户只在最开始的时候输入账号密码进行登陆，之后在浏览器中的相关操作产生的请求都没有输入账号密码来证明信息，那么服务器是如何知道是哪个用户在进行请求访问呢？这就涉及到了HTTP的<u>Cookie</u>功能。</p>
<p>当用户登陆网站输入账号密码信息并发送访问请求时，服务器收到相关数据会进行验证，若身份验证成功则会在返回的响应数据的响应头中字段<code>Set-Cookie</code>添加相关内容来表示用户身份信息，浏览器收到响应数据后会把对应的Cookie信息保存在本地。当用户登陆成功后在该网页进行其他操作而产生请求时，产生的请求报文的请求头上就会有<code>Cookie</code>字段信息，服务器接收到请求报文后，当核实Cookie内的字段能够核实用户身份，并且判断该用户处于登陆状态后，就会成功返回相关的数据信息。这就是网站通过Cookie保持用户登陆状态的原因。</p>
<h2 id="4-从浏览器中输入URL到页面展示这中间发送了什么？"><a href="#4-从浏览器中输入URL到页面展示这中间发送了什么？" class="headerlink" title="4.从浏览器中输入URL到页面展示这中间发送了什么？"></a>4.从浏览器中输入URL到页面展示这中间发送了什么？</h2><p>这同时也是个常见的面试问题。</p>
<p>上一大节中虽然详细讲述了HTTP协议请求发送和接收的流程，但是在上一节的描述中把浏览器的相关行为当成一个整体行为，从第一大节中我们可以了解到现在的浏览器是多进程模式，浏览器主进程负责其他子进程的管理、用户交互和文件储存的功能。从输入URL到页面展示的过程中主要涉及了三个进程之间的交互和运行，分别是<u>浏览器主进程、网络进程以及渲染进程</u>。</p>
<p>具体这三个进程在这个过程中的运行和交互如下图所示：</p>
<p><img src="/images/react/2021122204.png"></p>
<p>根据这张图引出一个新概念：导航。用户发出URL请求到页面开始解析的这个过程，就叫做导航。接下来将根据这张图，详细解析这一过程到底发生了什么。</p>
<h3 id="4-1-用户输入"><a href="#4-1-用户输入" class="headerlink" title="4.1 用户输入"></a>4.1 用户输入</h3><p>用户在地址栏中可能会输入一个网站地址或者只是单纯搜索一些关键词。浏览器主进程会解析用户输入的内容，如果不符合URL规范，则会使用浏览器的默认搜索引擎来合成新的带搜索内容的URL；如果符合URL规范，则会根据规则加上相关协议，比如http://或者https://，合成完整的URL。</p>
<p>当用户输入完成并敲击回车键后，浏览器并没有直接跳转到相关页面，中间有一段过渡时期，如下图所示：</p>
<p><img src="/images/react/2021122205.png"></p>
<p>在该图的操作中，在浏览器地址栏中已经输入新的地址并键入回车，标签栏中可以看见页面正在加载的状态，但是网页内容并没有更新，还是原网页，这是因为直到浏览器等待到确认提交文档阶段，页面内容才会被替换成新的页面。</p>
<h3 id="4-2-URL请求过程"><a href="#4-2-URL请求过程" class="headerlink" title="4.2 URL请求过程"></a>4.2 URL请求过程</h3><p>键入URL后就进入了请求过程，这也是导航流程的起始阶段。浏览器主进程通过IPC把URL请求发送至<u>网络进程</u>，在网络进程中真正的发送URL请求。</p>
<p>首先，网络进程收到URL请求后，会先在浏览器<u>缓存</u>中查找是否有需要的资源，若有则把该资源直接返回给浏览器主进程，若没有再进行网络请求流程。</p>
<p>在真正进入网络请求时先要进行<u>DNS解析</u>，通过浏览器缓存或者请求域名服务器获得URL的域名对应的IP地址。如果建立的是HTTPS请求，还需要先建立TLS连接。</p>
<p>然后就是建立<u>TCP连接</u>，成功连接后，网络进程真正发送HTTP请求信息给服务器，服务器接收到请求进行对应处理后会返回响应数据给<u>网络进程</u>，网络进程收到数据后开始解析响应数据内容。</p>
<p>如果服务器返回的响应数据的状态码是<u>301或302</u>，则表示当前的URL需要<u>重定位</u>到其他的URL，这时候网络进程根据响应数据头部的<code>Location</code>字段信息获取重定位地址，再次发送HTTP请求。</p>
<p>如果服务器返回的响应数据的状态码是<u>200</u>，则说明服务器成功返回了相关的数据信息，浏览器可以继续处理请求。这时网络进程会分析响应数据的<u>类型</u>，一般来说接收到的响应数据有两种类型，查看响应头上的<code>Content-Type</code>字段，这个字段决定了响应数据的类型，若该字段的内容是<code>application/octet-stream</code>，则说明是字节流类型数据，这种情况下，浏览器会按照下载类型来处理，同时URL请求的导航流程也就结束了。如果收到的信息是<code>Content-Type: text/html </code>，则说明该数据是html格式数据，网络进程会通知<u>浏览器主进程</u>进行渲染准备，浏览器就会继续进行导航流程。</p>
<h3 id="4-3-准备渲染进程"><a href="#4-3-准备渲染进程" class="headerlink" title="4.3 准备渲染进程"></a>4.3 准备渲染进程</h3><p>一般情况下浏览器会给每一张页面分配一个渲染进程，但是有些浏览器会给属于同一站点的页面，并且后一张页面是在前面那张页面内打开的这样的情况下给这些页面分配同一个渲染进程。所以如果浏览器主进程接收到了网络进程需要准备渲染的信号，则会判断是否需要新增一个渲染进程，还是使用原来已有的渲染进程。</p>
<h3 id="4-4-提交文档"><a href="#4-4-提交文档" class="headerlink" title="4.4 提交文档"></a>4.4 提交文档</h3><p>这里所谓的“文档”是指URL请求的<u>响应体数据</u>。由浏览器主进程向渲染进程发出<u>“提交文档”</u>消息，<u>渲染进程</u>接收到消息后会和<u>网络进程</u>建立传输数据的“管道”。等文档数据从网络进程到渲染进程传输完成后，渲染进程会返回<u>“确认提交”</u>消息给浏览器主进程，当浏览器主进程接收到这个消息后，会更新浏览器界面状态，包括<u>安全状态、地址栏URL、前进后退历史状态、并且更新Web页面</u>。</p>
<h3 id="4-5-渲染阶段"><a href="#4-5-渲染阶段" class="headerlink" title="4.5 渲染阶段"></a>4.5 渲染阶段</h3><p>当渲染进程发送“确认提交”的信息后，它便开始对收到的数据进行页面分析和资源加载，一旦页面生成完成，渲染进程会发送一个消息给浏览器主进程，浏览器主进程接收到消息后，就会停止标签栏上的<u>加载动画</u>。这样，一个完整的页面就展示完成了。</p>
<h3 id="4-6-总结"><a href="#4-6-总结" class="headerlink" title="4.6 总结"></a>4.6 总结</h3><p>简化这个过程来回答这个问题，可以这样总结回答：</p>
<p><strong>第一步</strong>是用户在地址栏中的<u>输入</u>，浏览器主进程会根据输入的消息自动完善或者转化URL地址，生成对应的<u>HTTP请求报文</u>。<strong>第二步</strong>浏览器主进程将请求发送给<u>网络进程</u>，网络进程先判断<u>缓存</u>中是否有需要的资源，若有则返回该资源给浏览器主进程，若无则准备发送HTTP请求。<strong>第三步</strong>在发送请求之前先确认服务器的<u>IP地址</u>，在缓存中寻找域名映射IP地址信息，若没有需要的数据则发送请求到域名服务器获取需要的IP地址，如果是URL中显示是HTTPS协议，则还要先建立TLS连接。<strong>第四步</strong>建立<u>TCP</u>连接，等待TCP连接成功后真正发送HTTP请求到服务端，并等待服务端返回响应包，若响应数据中的<u>状态码</u>是301或者302则说明需要<u>重定向</u>URL，则根据响应头里的<code>Locstion</code>的URL再次发送HTTP请求。若成功返回所需的响应包，先分析该响应数据的<u>数据格式</u>，网络进程需要解析响应头部的<code>Content-Type</code>字段，若是字节流类型，则会当作是需要下载的资源进行下载，则该流程结束；若是html类型则要通知浏览器主进程进行<u>渲染准备</u>。<strong>第五步</strong>浏览器主进程会检查url是否和之前打开的渲染进程有相同的根域名，若相同则复用原来的进程，不同则开启新的进程（这一步因浏览器而异，而且现在的浏览器好像只要是新的页面都会分配一个新的渲染进程）。<strong>第六步</strong>浏览器会发送<u>“提交文档”</u>消息给相应的渲染进程，渲染进程接收到后就会和网络进程建立传输数据的“管道”。直到它接受完数据后，渲染进程会向浏览器主进程发送<u>“确认提交”</u>消息，浏览器主进程接收到该消息后会更新浏览器界面的一些状态包括安全状态、地址栏url、前进后退的历史状态以及Web界面。到这里导航流程就结束了，直到渲染进程完全解析和加载完资源，成功渲染页面之后会发送消息通知浏览器主进程，浏览器主进程收到消息后就会停止标签栏中加载动画，这样一个页面就完成展示了。</p>
<h2 id="5-页面渲染流程"><a href="#5-页面渲染流程" class="headerlink" title="5.页面渲染流程"></a>5.页面渲染流程</h2><p>上一节我们了解了从输入URL到生成一张页面的导航阶段的流程，导航阶段之后则是页面的渲染流程，此时渲染进程已经获取了生成一张页面所需要的资源包括HTML、CSS和JavaScript，那么这些文件又是如何被解析生成一张可视化页面的呢？</p>
<p>由于渲染机制非常复杂，渲染模块会在执行的过程中被划分为很多子阶段，最后输出像素，这一过程被称为渲染流水线。按照渲染的时间顺序可以将该流水线分为这几个子阶段：<u>构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化以及合成显示</u>。值得注意的是，每个子阶段都有其<u>输入</u>和<u>输出</u>内容以及处理过程（我觉得这句话像句废话，但是看到最后我发现这句话很重要）。</p>
<h3 id="5-1-构建DOM树"><a href="#5-1-构建DOM树" class="headerlink" title="5.1 构建DOM树"></a>5.1 构建DOM树</h3><p>浏览器无法直接理解HTML文件，需要将HTML转化成其能够理解的DOM树结构，可见下图所示。</p>
<p><img src="/images/react/2021122301.png"></p>
<p>DOM树区分于HTML的是，DOM树是保持在内存中的树状结构，可以通过JavaScipt来查询或修改其内容。</p>
<p>可以在Chrome浏览器中打开一张页面的开发者工具，点击控制台，在控制台中输入<code>document</code>并敲击回车键，就会呈现该页面HTML对应的DOM树，也可以在控制台中通过获取DOM树的某一节点来修改它的值，如下图所示。</p>
<p><img src="/images/react/2021122302.png"></p>
<h3 id="5-2-样式计算"><a href="#5-2-样式计算" class="headerlink" title="5.2 样式计算"></a>5.2 样式计算</h3><p>样式计算是为了计算每一个DOM节点每个元素的具体样式。</p>
<p>首先先要<strong>把CSS转化为浏览器能够理解的结构</strong>。CSS在一张网页中可能有多种呈现方式，包括引用外部css文件，在标签<code>&lt;style&gt;</code>中的CSS，以及在元素的<code>style</code>属性中填写的CSS。当渲染引擎接收到CSS文本时，会将其转化为浏览器可以理解的<u>styleSheets</u>结构，如下图所示，在控制台中输入<code>document.styleSheets</code>可以查看styleSheets结构。</p>
<p><img src="/images/react/2021122303.png"></p>
<p>然后<strong>将样式表中的属性值转化为标准形式</strong>。比方说表达颜色可以有多种方式，例如<code>red</code>、<code>rgb(255,0,0)</code>，<code>#ff0000</code>都可以表示红色，所以为了统一展示需要将这些值标准化。</p>
<p>最后<strong>计算出DOM树中每个节点的具体样式</strong>，由于CSS具有<u>继承性</u>，即子节点会继承父节点的样式，以及CSS的其他<u>层叠规则</u>，所以需要计算每个节点最后真正的样式值。这里的层叠规则是CSS的核心，之后具体复习CSS时会展开讲。</p>
<h3 id="5-3-布局阶段"><a href="#5-3-布局阶段" class="headerlink" title="5.3 布局阶段"></a>5.3 布局阶段</h3><p>上面两小节以及完成了DOM树的构建以及DOM树中元素对应样式表的构建，接下来要进行布局阶段，要获得每个可见节点在页面上的具体位置。</p>
<p><strong>创建布局树</strong>：在构建DOM树中会发现有很多标签如<code>head</code>标签都是不可见的，以及在创建样式表时也发现有一些元素带有例如<code>display:none</code>的属性，也是不可见的，所以需要建立一个只包含可见元素的布局树，如下图所示，就是通过DOM树和对应的样式表创建出的布局树。</p>
<p><img src="/images/react/2021122304.png"></p>
<p><strong>布局计算</strong>：现在已有一棵布局树，然后就要进行布局计算，这一过程比较复杂，后面的章节会详细分析，总之在进行布局计算后会把运算结果重新写回布局树中。所以<u>这一阶段布局树既是输入内容又是输出结果</u>。</p>
<h3 id="5-4-分层"><a href="#5-4-分层" class="headerlink" title="5.4 分层"></a>5.4 分层</h3><p>因为页面中有很多复杂的效果，比如页面滚动、3D转换等，所以为了方便实现这些效果，渲染引擎还需要生成一棵<u>图层树（LayerTree）</u>。打开Chrome的开发者工具，选择”Layers“标签，若没有该标签，则按下图所示操作添加该标签：</p>
<p><img src="/images/react/2021122305.png"></p>
<p>比如，下面这个页面就有5个图层，如下图所示。</p>
<p><img src="/images/react/2021122306.png"></p>
<p>不是布局树上的每一个节点都会被分配一个图层的，如果某些节点没有被分配图层，那它就属于父节点的图层，所以最终每个布局树上的节点都会直接或间接地从属于某一图层。符合以下两个条件之一的元素可以被提升为单独一个图层。</p>
<p><strong>拥有层叠上下文属性的元素</strong>：比如定义position属性、z-index属性、filter属性以及opacity属性。</p>
<p><strong>需要裁剪的元素</strong>：当元素里的内容超出元素本身大小时就需要被裁剪。</p>
<p>确定好哪些节点会被分配新的图层后，就会生成一个图层树。图层树不一定和布局树的节点一一对应，但是<u>布局树上的每个节点一定都属于某一个图层</u>。</p>
<h3 id="5-5-绘制"><a href="#5-5-绘制" class="headerlink" title="5.5 绘制"></a>5.5 绘制</h3><p>渲染引擎是通过构建<u>绘制列表</u>来实现具体的图层绘制过程的。绘制列表中每一个指令都代表一个绘制操作，通常要完成绘制一个元素需要好几条指令，因为通常一个元素会有背景、前景、边框等属性都需要单独的指令来实现。</p>
<h3 id="5-6-分块"><a href="#5-6-分块" class="headerlink" title="5.6 分块"></a>5.6 分块</h3><p>绘制列表只是用来记录绘制指令的列表，实际完成绘制操作的是渲染进程中的<u>合成线程</u>。当在渲染进程的主线程上完成绘制列表后，它会把该列表提交给合成线程。</p>
<p>这里先引入一个<u>”视口“</u>的概念。一般一些页面是超过浏览器窗口大小的，它们也许会很长，也许会很宽，而视口就是窗口上可见的页面区域。如果一张页面非常长而视口非常小，而要完整绘制该页面的所有图层内容是没必要的，这会引起很大开销。基于这个原因，合成线程将图层划分为许多<u>图块(tile)</u>，这些图块的大小通常是256x256或者512x512。</p>
<h3 id="5-7-栅格化操作"><a href="#5-7-栅格化操作" class="headerlink" title="5.7 栅格化操作"></a>5.7 栅格化操作</h3><p>渲染进程中的合成线程会将分解出来的图块发送到<u>栅格化线程池</u>中，由一系列<u>栅格化线程</u>对这些图块进行处理。<u>栅格化</u>就是指将图块转化为<u>位图</u>，图块是栅格化执行的最小操作。而通常栅格化的过程会使用<u>GPU</u>加速实现，前面第一大节提过GPU有独立的进程，所以这涉及了跨进程操作。具体的处理交互过程如图所示。</p>
<p><img src="/images/react/2021122307.png"></p>
<p>如图可知，位图是在GPU进程中生成并且保存的。</p>
<h3 id="5-8-合成和显示"><a href="#5-8-合成和显示" class="headerlink" title="5.8 合成和显示"></a>5.8 合成和显示</h3><p>当所有图块都被光栅化成位块后，渲染进程的合成线程会发生给浏览器主进程一个绘制图块命令——“<u>DrawQuad</u>“。浏览器主进程里有个叫viz的组件，用来接收该命令，然后根据该命令将页面内容绘制到内存中，最后将内存显示在屏幕上。</p>
<h3 id="5-9-重排、重绘与合成"><a href="#5-9-重排、重绘与合成" class="headerlink" title="5.9 重排、重绘与合成"></a>5.9 重排、重绘与合成</h3><p>以上就已经讲述了渲染流水线的具体过程，接下来提出三个重要概念，这些概念在之后的<u>Web优化</u>中非常重要，也经常被面试官提及。</p>
<p><strong>重排</strong>：顾名思义，就是重新排列了元素的布局。在实际情况中就是改变了元素的样式中几何位置相关的属性，比如<code>weight</code>、<code>height</code>、<code>margin</code>等。修改了这些属性，那么渲染流水线从样式计算到后面的布局阶段、分层阶段以及绘制等都需要改变，如下图所示。</p>
<p><img src=""></p>
<p>根据该图也可以看出重排的开销非常大。</p>
<p><strong>重绘</strong>：顾名思义是改变某些元素的某些颜色，比如背景、字体颜色等样式。因为不会引起布局的变动所以重绘之后会直接跳过布局阶段和分层阶段，但绘制列表是需要改变的，具体如下图所示。</p>
<p><img src="/images/react/2021122309.png"></p>
<p>虽然重绘也有一定大的开销，但是相比于重排开销会有所减少。</p>
<p><strong>合成</strong>：如果改变一些既不要布局也不需要绘制的属性，比如改变translate属性，渲染引擎就会直接跳过布局和绘制，而只执行后面的合成操作，具体如下图所示：</p>
<p><img src="/images/react/2021122310.png"></p>
<p>根据上图可以得知，合成对比于重排和重绘开销最小。</p>
<h3 id="5-10-渲染流水线总结"><a href="#5-10-渲染流水线总结" class="headerlink" title="5.10 渲染流水线总结"></a>5.10 渲染流水线总结</h3><p>上面已经分析了渲染流水线的每一个具体过程，现在可以根据以下这张图来概括性地说明从HTML到一张页面经历了什么。</p>
<p><img src="/images/react/2021122311.png"></p>
<p>渲染进程获得所需的HTML、CSS、JavaScript等资源后，1.将<u>HTML内容</u>转化为可以理解的<u>DOM树</u>。2.将有关的<u>CSS内容</u>转为能够理解的styleSheets格式，对其进行标准化处理，并且计算出每个DOM节点的样式值，生成DOM树每个元素的<u>样式表</u>。3.根据<u>DOM树和对应的样式表</u>创建DOM可见节点的布局树，并且计算节点的布局信息，生成一棵<u>布局树</u>。4.对<u>布局树</u>进行分层，生成<u>图层树</u>。5.为<u>每个图层</u>生成绘制列表，并且提交<u>绘制列表</u>给渲染进程的合成线程。6.合成线程将<u>图层</u>分为<u>图块</u>。7.合成线程再将生成的<u>图块</u>在光栅化线程池中将转化成<u>位图</u>，这里会使用GPU而和GPU进程进行交互。8.完成<u>位图</u>制作后，合成线程会发送绘制图块命令DrawQuad给浏览器主进程，浏览器主进程根据消息生成<u>页面</u>，并展示到显示器上。</p>
<p>可以看出每一个阶段都是有输入输出的，这样一张页面的渲染流程也展示完成了。</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>前端面试</tag>
      </tags>
  </entry>
</search>
