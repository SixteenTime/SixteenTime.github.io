---
title: 宏观视角下的浏览器
date: 2021-12-22 08:35:11
tags: [前端面试,浏览器]
categories:
- 浏览器
---

------

*本文来源于http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。*

------

## 1.浏览器发展史

### 1.1 单进程浏览器

2007年之前，市面上的浏览器都是单进程的，单进程浏览器把需要运行的所有功能模块都放在一个进程里，而模块分为几个线程在进程里运行，这会导致如下几个问题。

**不稳定问题**：一个线程崩溃就会导致整个进程崩溃，也就是整个浏览器崩溃。

**不流畅问题**：单进程浏览器中，页面模块在一个线程中运行，如果该线程中有一个<u>无限循环的脚本</u>，那页面的其他模块就无法运行，会导致页面无法加载的问题。除此之外，单进程浏览器很容易出现页面<u>内存泄漏</u>从而导致计算机内存占用越来越高，浏览器运行越来越慢的问题。

**不安全问题**：在单进程浏览器中很容易让一些<u>恶意插件或脚本</u>释放病毒，获得计算机重要信息。

### 1.2 早期多进程浏览器

2008年Chrome的发布宣告浏览器进入多进程时代，早期的浏览器多进程架构是将各个插件从浏览器主进程中分离开独立成单个的进程，也将每个页面线程从主进程分离变成独立的每个渲染进程。这些被分割的进程都运行在<u>沙箱</u>中，进程之间通过<u>IPC</u>（进程间通信）进行通信。这种多进程模块的好处是让各个功能模块相互隔离，这样一个模块的问题导致的奔溃不会导致整个浏览器崩溃，解决了不稳定性问题。并且也因为独立的进程，使得一个页面脚本出现问题时不会影响整个浏览器以及独立的其他页面的运行（每个页面都是一个渲染进程），争对内存泄漏也可以通过关闭一个页面回收内存的方式解决，这就解决了不稳定性问题。此外，因为独立出来的功能模块进程都在sandbox（沙箱）中运行，受到一定的限制，无法读取计算机敏感位置的数据，所以安全性问题也得到了解决。

### 1.3 目前多进程浏览器

对比于早期的多进程架构，目前的Chrome又独立于浏览器主进程之外还多出了几个进程，包括<u>GPU进程、网络服务进程、缓存服务进程、备用渲染进程</u>。

打开Chrome的任务管理器，下面显示的就是chrome浏览器中运行的进程，如图所示：

![](/images/react/2021122201.png)

多进程模型提高了浏览器的稳定性、流畅性以及安全性，但也带来了一定的问题，比如它占用了更高的资源，因为每个进程都会包含公共基础结构的副本；以及该模型有着更复杂的体系架构，这意味着浏览器各模块之间的<u>耦合性高、扩展性差</u>等问题。面对这些问题，现在的浏览器公司一直都在寻找更好的处理方法。

### 1.4 未来面向服务的架构

在2016年，Chrome团队就使用<u>面向服务架构</u>（SOA）的思想设计了新的Chrome架构，也就是说未来的浏览器会朝着SOA的方向发展，原来的各个模块会被重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务就必须使用定义好的接口，这样就可以建立一个<u>更加内聚、更低的耦合度，更加易于维护和扩展</u>的系统。但这必将是一个漫长的过程。

## 2.数据包从服务端完整传达给客服端浏览器的过程

打开一个网页会显示各种信息，这些信息都是从这个网站的服务器端发送过来的，那么这些信息又是怎么包装完整地传达到客户端的浏览器上的呢？

### 2.1 数据包从服务端送达到目的主机

数据必定是先从服务器运输到客户端的主机，才能从主机上升到具体的应用程序。两个主机之间的信息通信在网络体系模型的<u>网络层</u>中实现的，其中数据的运输则依靠于网络层中的<u>IP协议</u>。网络层传输的数据是以“分组”形式存在的，每一个分组都有一个头部，头部包含了源主机和目的主机的<u>IP地址</u>，依靠IP地址就可以实现两个主机之间的通信。

### 2.2 数据包从客户端主机到应用进程

通过网络层的IP协议可以实现主机之间的网络通信，但是IP协议是个相对底层的协议，无法实现应用进程之间的通信，这需要通过网络层上一层的<u>传输层</u>才能实现通信。传输层通常有两个常用的协议，分别是<u>UDP协议</u>和<u>TCP协议</u>，通过两个协议在传输层产生的数据包都有一个头部，头部都包含了<u>源端口号和目的端口号</u>的信息，这个端口号就是具体的应用程序在主机上的端口号，根据端口号就可以实现数据包从客户端主机到应用进程的运输。

### 2.3 数据包可靠完整地被传达

上节提到的UDP协议和TCP协议都是在传输层的协议，它们之间的区别是：UDP协议追求的是<u>快速</u>地传输，而TCP协议追求的是<u>完整</u>地传输，这就会导致UDP协议传输的数据很容易丢失，而TCP协议却保护了数据的完整性。在浏览器中运用到的应用层协议，无论是http协议还是WebSocket协议都使用TCP协议传输数据，从而保证了数据的完整性。那么TCP协议是如何做到完整传输数据的呢？

区别于UDP协议，基于TCP协议有更复杂更加多数据的头部，包括数据包序号、确认号、数据偏移等信息，这些信息能够将混乱的数据包组合成一个完整的文件，并且对于缺失的数据包，TCP提供了重传机制。

此外，为了保证数据传输的可靠性，进行TCP协议实际数据的传输前后分别由“三次握手”和“四次挥手来进行可靠的连接建立和断开。

TCP协议需要进行三次握手的原因是为了防止失效的连接请求到达服务器，让服务器错误打开连接（具体详细解析可见”计算机网络基础知识点“的7.4节）。

## 3.HTTP请求流程

HTTP协议是<u>应用层</u>协议，是浏览器使用最广泛的协议，通过它可以实现浏览器向服务器获取相关资源。HTTP协议建立在TCP协议基础之上，上一节已经知道通过TCP协议实现数据从服务器传输到浏览器中，那么浏览器又是怎么通过HTTP协议发送请求的呢？这节主要讲HTTP请求的具体流程。

### 3.1 构建请求

通常访问一个网站的第一步就是在浏览器的地址栏中输入一个网站地址并点击跳转，这时就会构建一个请求，但是这个请求还在浏览器端，并没有开始运输。

### 3.2 查找缓存

在发送请求之前，浏览器会根据已经构建好的请求的基本数据在<u>缓存</u>中进行查找，如果有所需的数据，则它会直接拦截结束该请求，直接使用缓存中的副本，这样就能缓解服务器压力，也加快了浏览器上资源加载速度。

### 3.3 获取服务端的IP地址和端口

如果缓存中没有所需的数据，则要开始发送请求，但是根据第2节可知，实现一个数据包的运输需要知道对方主机的IP地址和端口号，所以需要先获取IP地址以及端口号。如何通过一个URL网址获得IP地址就要涉及<u>DNS协议</u>，浏览器已知的URL又被称为域名，域名和IP地址呈现一对一映射关系，通过DNS协议访问<u>域名服务器</u>可以获得所需要的IP地址，或者如果之前该浏览器访问过某网页，那么缓存中可能会存有该网络的IP地址。对于端口号，如果URL中没有特别指明端口号，那么HTTP协议默认的端口号是<u>80</u> 。

### 3.4 等待TCP队列，建立TCP连接

浏览器一般都有一个限制，即同一域名同时只能建立一定数量的TCP连接，如果超过这个数量，只能进入队列进行等待，若未超过这个数量，则能直接建立TCP连接，TCP连接的具体方式如第2大节所示。

### 3.5 发送HTTP请求

建立了TCP连接，实现了TCP的三次握手，才能真正的发送HTTP请求。一个HTTP请求报文由<u>请求行、请求头部和请求体</u>组成，具体如下图所示：

![](/images/react/2021122202.png)

其中，请求行包括了<u>请求方法</u>（GET/POST/DELETE...）、<u>请求URL</u>以及<u>HTTP协议版本号</u>。请求头部包括了一些基础信息，比如浏览器所使用的操作系统、浏览器内核等信息。

### 3.6 服务器返回请求响应

服务器接收到浏览器的HTTP请求后，则会处理相应请求，如果服务器选择响应某些请求，就会发送客户端浏览器以HTTP响应数据信息，其中包括<u>响应行、响应头部和具体的响应体</u>。

其中响应行包括<u>HTTP协议版本</u>和<u>状态码</u>信息，比如状态码为200则表示处理成功，状态码为404则表示没有响应页面。

### 3.7 断开连接

通常情况下，一旦服务器向客户端返回了请求数据，就会断开TCP协议，如果浏览器或服务器在其HTTP请求头部或者响应头部中加上了`Connection:keep-alive`，则该TCP连接就会保持打开状态。

### 3.8 重定向

有时候会出现这种情况：用户在浏览器的地址栏中输入的URL在网页打开后会变成另外一个，这就涉及到了重定向。比如在我的火狐浏览器的地址栏中输入`sixteentime.github.io`，但是它马上跳转成网站`sixteentime.xyz`，这就是一个重定向的过程，可以打开该网站打开时的第一个响应报文，观察其响应头信息中有这样一行信息:`Location: http://sixteentime.xyz/ `这就执行了一个重定向流程，具体如下图所示：

![](/images/react/2021122203.png)

### 3.9相关问题

**为什么很多网站第二次打开的速度会很快？**

这是上面提到的浏览器<u>缓存机制</u>的原因。当网站第一次打开网站时，浏览器里没有该网站的缓存，浏览器则会发送请求给服务端请求数据，服务端返回数据给浏览器时，浏览器也会把页面数据存入缓存，然后在缓存的<u>生命周期</u>内再次打开该页面时，浏览器就不会发送请求给服务器而是直接使用缓存资源，这样就会使网站运行速度加快；若超过了这个生命周期，那么浏览器会担心这个缓存数据可能会过期，就会发送请求给服务器，如果服务器返回该缓存数据没有过期，那么浏览器会继续使用缓存数据加载页面，这样的加载速度也会相对较快。

当然，浏览器的缓存中还有域名与IP地址的映射信息，第二次打开页面不需要发送请求到域名服务器获取域名对应的IP地址，也可以加快网页的加载速度。

**网站的登录状态是如何保持的？**

一般而言，服务器为了防止非系统用户的恶意攻击，对系统的访问方法都需要用户登陆信息，可是在浏览器中操作的用户只在最开始的时候输入账号密码进行登陆，之后在浏览器中的相关操作产生的请求都没有输入账号密码来证明信息，那么服务器是如何知道是哪个用户在进行请求访问呢？这就涉及到了HTTP的<u>Cookie</u>功能。

当用户登陆网站输入账号密码信息并发送访问请求时，服务器收到相关数据会进行验证，若身份验证成功则会在返回的响应数据的响应头中字段`Set-Cookie`添加相关内容来表示用户身份信息，浏览器收到响应数据后会把对应的Cookie信息保存在本地。当用户登陆成功后在该网页进行其他操作而产生请求时，产生的请求报文的请求头上就会有`Cookie`字段信息，服务器接收到请求报文后，当核实Cookie内的字段能够核实用户身份，并且判断该用户处于登陆状态后，就会成功返回相关的数据信息。这就是网站通过Cookie保持用户登陆状态的原因。

## 4.从浏览器中输入URL到页面展示这中间发送了什么？

这同时也是个常见的面试问题。

上一大节中虽然详细讲述了HTTP协议请求发送和接收的流程，但是在上一节的描述中把浏览器的相关行为当成一个整体行为，从第一大节中我们可以了解到现在的浏览器是多进程模式，浏览器主进程负责其他子进程的管理、用户交互和文件储存的功能。从输入URL到页面展示的过程中主要涉及了三个进程之间的交互和运行，分别是<u>浏览器主进程、网络进程以及渲染进程</u>。

具体这三个进程在这个过程中的运行和交互如下图所示：

![](/images/react/2021122204.png)

根据这张图引出一个新概念：导航。用户发出URL请求到页面开始解析的这个过程，就叫做导航。接下来将根据这张图，详细解析这一过程到底发生了什么。

### 4.1 用户输入

用户在地址栏中可能会输入一个网站地址或者只是单纯搜索一些关键词。浏览器主进程会解析用户输入的内容，如果不符合URL规范，则会使用浏览器的默认搜索引擎来合成新的带搜索内容的URL；如果符合URL规范，则会根据规则加上相关协议，比如http://或者https://，合成完整的URL。

当用户输入完成并敲击回车键后，浏览器并没有直接跳转到相关页面，中间有一段过渡时期，如下图所示：

![](/images/react/2021122205.png)

在该图的操作中，在浏览器地址栏中已经输入新的地址并键入回车，标签栏中可以看见页面正在加载的状态，但是网页内容并没有更新，还是原网页，这是因为直到浏览器等待到确认提交文档阶段，页面内容才会被替换成新的页面。

### 4.2 URL请求过程

键入URL后就进入了请求过程，这也是导航流程的起始阶段。浏览器主进程通过IPC把URL请求发送至<u>网络进程</u>，在网络进程中真正的发送URL请求。

首先，网络进程收到URL请求后，会先在浏览器<u>缓存</u>中查找是否有需要的资源，若有则把该资源直接返回给浏览器主进程，若没有再进行网络请求流程。

在真正进入网络请求时先要进行<u>DNS解析</u>，通过浏览器缓存或者请求域名服务器获得URL的域名对应的IP地址。如果建立的是HTTPS请求，还需要先建立TLS连接。

然后就是建立<u>TCP连接</u>，成功连接后，网络进程真正发送HTTP请求信息给服务器，服务器接收到请求进行对应处理后会返回响应数据给<u>网络进程</u>，网络进程收到数据后开始解析响应数据内容。

如果服务器返回的响应数据的状态码是<u>301或302</u>，则表示当前的URL需要<u>重定位</u>到其他的URL，这时候网络进程根据响应数据头部的`Location`字段信息获取重定位地址，再次发送HTTP请求。

如果服务器返回的响应数据的状态码是<u>200</u>，则说明服务器成功返回了相关的数据信息，浏览器可以继续处理请求。这时网络进程会分析响应数据的<u>类型</u>，一般来说接收到的响应数据有两种类型，查看响应头上的`Content-Type`字段，这个字段决定了响应数据的类型，若该字段的内容是`application/octet-stream`，则说明是字节流类型数据，这种情况下，浏览器会按照下载类型来处理，同时URL请求的导航流程也就结束了。如果收到的信息是`Content-Type: text/html `，则说明该数据是html格式数据，网络进程会通知<u>浏览器主进程</u>进行渲染准备，浏览器就会继续进行导航流程。

### 4.3 准备渲染进程

一般情况下浏览器会给每一张页面分配一个渲染进程，但是有些浏览器会给属于同一站点的页面，并且后一张页面是在前面那张页面内打开的这样的情况下给这些页面分配同一个渲染进程。所以如果浏览器主进程接收到了网络进程需要准备渲染的信号，则会判断是否需要新增一个渲染进程，还是使用原来已有的渲染进程。

### 4.4 提交文档

这里所谓的“文档”是指URL请求的<u>响应体数据</u>。由浏览器主进程向渲染进程发出<u>“提交文档”</u>消息，<u>渲染进程</u>接收到消息后会和<u>网络进程</u>建立传输数据的“管道”。等文档数据从网络进程到渲染进程传输完成后，渲染进程会返回<u>“确认提交”</u>消息给浏览器主进程，当浏览器主进程接收到这个消息后，会更新浏览器界面状态，包括<u>安全状态、地址栏URL、前进后退历史状态、并且更新Web页面</u>。

### 4.5 渲染阶段

当渲染进程发送“确认提交”的信息后，它便开始对收到的数据进行页面分析和资源加载，一旦页面生成完成，渲染进程会发送一个消息给浏览器主进程，浏览器主进程接收到消息后，就会停止标签栏上的<u>加载动画</u>。这样，一个完整的页面就展示完成了。

### 4.6 总结

简化这个过程来回答这个问题，可以这样总结回答：

**第一步**是用户在地址栏中的<u>输入</u>，浏览器主进程会根据输入的消息自动完善或者转化URL地址，生成对应的<u>HTTP请求报文</u>。**第二步**浏览器主进程将请求发送给<u>网络进程</u>，网络进程先判断<u>缓存</u>中是否有需要的资源，若有则返回该资源给浏览器主进程，若无则准备发送HTTP请求。**第三步**在发送请求之前先确认服务器的<u>IP地址</u>，在缓存中寻找域名映射IP地址信息，若没有需要的数据则发送请求到域名服务器获取需要的IP地址，如果是URL中显示是HTTPS协议，则还要先建立TLS连接。**第四步**建立<u>TCP</u>连接，等待TCP连接成功后真正发送HTTP请求到服务端，并等待服务端返回响应包，若响应数据中的<u>状态码</u>是301或者302则说明需要<u>重定向</u>URL，则根据响应头里的`Locstion`的URL再次发送HTTP请求。若成功返回所需的响应包，先分析该响应数据的<u>数据格式</u>，网络进程需要解析响应头部的`Content-Type`字段，若是字节流类型，则会当作是需要下载的资源进行下载，则该流程结束；若是html类型则要通知浏览器主进程进行<u>渲染准备</u>。**第五步**浏览器主进程会检查url是否和之前打开的渲染进程有相同的根域名，若相同则复用原来的进程，不同则开启新的进程（这一步因浏览器而异，而且现在的浏览器好像只要是新的页面都会分配一个新的渲染进程）。**第六步**浏览器会发送<u>“提交文档”</u>消息给相应的渲染进程，渲染进程接收到后就会和网络进程建立传输数据的“管道”。直到它接受完数据后，渲染进程会向浏览器主进程发送<u>“确认提交”</u>消息，浏览器主进程接收到该消息后会更新浏览器界面的一些状态包括安全状态、地址栏url、前进后退的历史状态以及Web界面。到这里导航流程就结束了，直到渲染进程完全解析和加载完资源，成功渲染页面之后会发送消息通知浏览器主进程，浏览器主进程收到消息后就会停止标签栏中加载动画，这样一个页面就完成展示了。

## 5.页面渲染流程

上一节我们了解了从输入URL到生成一张页面的导航阶段的流程，导航阶段之后则是页面的渲染流程，此时渲染进程已经获取了生成一张页面所需要的资源包括HTML、CSS和JavaScript，那么这些文件又是如何被解析生成一张可视化页面的呢？

由于渲染机制非常复杂，渲染模块会在执行的过程中被划分为很多子阶段，最后输出像素，这一过程被称为渲染流水线。按照渲染的时间顺序可以将该流水线分为这几个子阶段：<u>构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化以及合成显示</u>。值得注意的是，每个子阶段都有其<u>输入</u>和<u>输出</u>内容以及处理过程（我觉得这句话像句废话，但是看到最后我发现这句话很重要）。

### 5.1 构建DOM树

浏览器无法直接理解HTML文件，需要将HTML转化成其能够理解的DOM树结构，可见下图所示。

![](/images/react/2021122301.png)

DOM树区分于HTML的是，DOM树是保持在内存中的树状结构，可以通过JavaScipt来查询或修改其内容。

可以在Chrome浏览器中打开一张页面的开发者工具，点击控制台，在控制台中输入`document`并敲击回车键，就会呈现该页面HTML对应的DOM树，也可以在控制台中通过获取DOM树的某一节点来修改它的值，如下图所示。

![](/images/react/2021122302.png)

### 5.2 样式计算

样式计算是为了计算每一个DOM节点每个元素的具体样式。

首先先要**把CSS转化为浏览器能够理解的结构**。CSS在一张网页中可能有多种呈现方式，包括引用外部css文件，在标签`<style>`中的CSS，以及在元素的`style`属性中填写的CSS。当渲染引擎接收到CSS文本时，会将其转化为浏览器可以理解的<u>styleSheets</u>结构，如下图所示，在控制台中输入`document.styleSheets`可以查看styleSheets结构。

![](/images/react/2021122303.png)

然后**将样式表中的属性值转化为标准形式**。比方说表达颜色可以有多种方式，例如`red`、`rgb(255,0,0)`，`#ff0000`都可以表示红色，所以为了统一展示需要将这些值标准化。

最后**计算出DOM树中每个节点的具体样式**，由于CSS具有<u>继承性</u>，即子节点会继承父节点的样式，以及CSS的其他<u>层叠规则</u>，所以需要计算每个节点最后真正的样式值。这里的层叠规则是CSS的核心，之后具体复习CSS时会展开讲。

### 5.3 布局阶段

上面两小节以及完成了DOM树的构建以及DOM树中元素对应样式表的构建，接下来要进行布局阶段，要获得每个可见节点在页面上的具体位置。

**创建布局树**：在构建DOM树中会发现有很多标签如`head`标签都是不可见的，以及在创建样式表时也发现有一些元素带有例如`display:none`的属性，也是不可见的，所以需要建立一个只包含可见元素的布局树，如下图所示，就是通过DOM树和对应的样式表创建出的布局树。

![](/images/react/2021122304.png)

**布局计算**：现在已有一棵布局树，然后就要进行布局计算，这一过程比较复杂，后面的章节会详细分析，总之在进行布局计算后会把运算结果重新写回布局树中。所以<u>这一阶段布局树既是输入内容又是输出结果</u>。

### 5.4 分层

因为页面中有很多复杂的效果，比如页面滚动、3D转换等，所以为了方便实现这些效果，渲染引擎还需要生成一棵<u>图层树（LayerTree）</u>。打开Chrome的开发者工具，选择”Layers“标签，若没有该标签，则按下图所示操作添加该标签：

![](/images/react/2021122305.png)

比如，下面这个页面就有5个图层，如下图所示。

![](/images/react/2021122306.png)

不是布局树上的每一个节点都会被分配一个图层的，如果某些节点没有被分配图层，那它就属于父节点的图层，所以最终每个布局树上的节点都会直接或间接地从属于某一图层。符合以下两个条件之一的元素可以被提升为单独一个图层。

**拥有层叠上下文属性的元素**：比如定义position属性、z-index属性、filter属性以及opacity属性。

**需要裁剪的元素**：当元素里的内容超出元素本身大小时就需要被裁剪。

确定好哪些节点会被分配新的图层后，就会生成一个图层树。图层树不一定和布局树的节点一一对应，但是<u>布局树上的每个节点一定都属于某一个图层</u>。

### 5.5 绘制

渲染引擎是通过构建<u>绘制列表</u>来实现具体的图层绘制过程的。绘制列表中每一个指令都代表一个绘制操作，通常要完成绘制一个元素需要好几条指令，因为通常一个元素会有背景、前景、边框等属性都需要单独的指令来实现。

### 5.6 分块

绘制列表只是用来记录绘制指令的列表，实际完成绘制操作的是渲染进程中的<u>合成线程</u>。当在渲染进程的主线程上完成绘制列表后，它会把该列表提交给合成线程。

这里先引入一个<u>”视口“</u>的概念。一般一些页面是超过浏览器窗口大小的，它们也许会很长，也许会很宽，而视口就是窗口上可见的页面区域。如果一张页面非常长而视口非常小，而要完整绘制该页面的所有图层内容是没必要的，这会引起很大开销。基于这个原因，合成线程将图层划分为许多<u>图块(tile)</u>，这些图块的大小通常是256x256或者512x512。

### 5.7 栅格化操作

渲染进程中的合成线程会将分解出来的图块发送到<u>栅格化线程池</u>中，由一系列<u>栅格化线程</u>对这些图块进行处理。<u>栅格化</u>就是指将图块转化为<u>位图</u>，图块是栅格化执行的最小操作。而通常栅格化的过程会使用<u>GPU</u>加速实现，前面第一大节提过GPU有独立的进程，所以这涉及了跨进程操作。具体的处理交互过程如图所示。

![](/images/react/2021122307.png)

如图可知，位图是在GPU进程中生成并且保存的。

### 5.8 合成和显示

当所有图块都被光栅化成位块后，渲染进程的合成线程会发生给浏览器主进程一个绘制图块命令——"<u>DrawQuad</u>"。浏览器主进程里有个叫viz的组件，用来接收该命令，然后根据该命令将页面内容绘制到内存中，最后将内存显示在屏幕上。

### 5.9 重排、重绘与合成

以上就已经讲述了渲染流水线的具体过程，接下来提出三个重要概念，这些概念在之后的<u>Web优化</u>中非常重要，也经常被面试官提及。

**重排**：顾名思义，就是重新排列了元素的布局。在实际情况中就是改变了元素的样式中几何位置相关的属性，比如`weight`、`height`、`margin`等。修改了这些属性，那么渲染流水线从样式计算到后面的布局阶段、分层阶段以及绘制等都需要改变，如下图所示。

![]()

根据该图也可以看出重排的开销非常大。

**重绘**：顾名思义是改变某些元素的某些颜色，比如背景、字体颜色等样式。因为不会引起布局的变动所以重绘之后会直接跳过布局阶段和分层阶段，但绘制列表是需要改变的，具体如下图所示。

![](/images/react/2021122309.png)

虽然重绘也有一定大的开销，但是相比于重排开销会有所减少。

**合成**：如果改变一些既不要布局也不需要绘制的属性，比如改变translate属性，渲染引擎就会直接跳过布局和绘制，而只执行后面的合成操作，具体如下图所示：

![](/images/react/2021122310.png)

根据上图可以得知，合成对比于重排和重绘开销最小。

### 5.10 渲染流水线总结

上面已经分析了渲染流水线的每一个具体过程，现在可以根据以下这张图来概括性地说明从HTML到一张页面经历了什么。

![](/images/react/2021122311.png)

渲染进程获得所需的HTML、CSS、JavaScript等资源后，1.将<u>HTML内容</u>转化为可以理解的<u>DOM树</u>。2.将有关的<u>CSS内容</u>转为能够理解的styleSheets格式，对其进行标准化处理，并且计算出每个DOM节点的样式值，生成DOM树每个元素的<u>样式表</u>。3.根据<u>DOM树和对应的样式表</u>创建DOM可见节点的布局树，并且计算节点的布局信息，生成一棵<u>布局树</u>。4.对<u>布局树</u>进行分层，生成<u>图层树</u>。5.为<u>每个图层</u>生成绘制列表，并且提交<u>绘制列表</u>给渲染进程的合成线程。6.合成线程将<u>图层</u>分为<u>图块</u>。7.合成线程再将生成的<u>图块</u>在光栅化线程池中将转化成<u>位图</u>，这里会使用GPU而和GPU进程进行交互。8.完成<u>位图</u>制作后，合成线程会发送绘制图块命令DrawQuad给浏览器主进程，浏览器主进程根据消息生成<u>页面</u>，并展示到显示器上。

可以看出每一个阶段都是有输入输出的，这样一张页面的渲染流程也展示完成了。