---
title: 浏览器中的页面循环系统
date: 2022-01-24 14:57:20
tags: [前端面试,浏览器]
categories:
- 浏览器
---

---

*本文来源于[http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程](http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82)[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。*

---

我们已经知道每个渲染进程都有一个主进程，它需要处理DOM、计算样式、处理布局以及处理JavaScript的各种任务，工作特别繁忙，那么这些任务是如何有条不紊地被主进程处理的呢？这就涉及到了浏览器的休息队列和事件循环系统。

## 1.消息队列和事件循环

### 1.1 单线程处理任务结构

主线程会有一个事件处理的<u>消息队列</u>，那些需要执行的任务会逐个加入消息队列当中，按照先进先出的顺序被主线程去执行。

但是主线程在运行过程中如何接收新的任务呢？这就涉及到了<u>事件循环机制</u>，在主线程中添加一个循环语句实时监听新任务的产生。

不过在这样的结构下主线程处理的所有任务都是内部任务，而有一些IO任务比如接收键盘消息等外部任务又如何添加到渲染进程的主线程当中呢？IO任务是由<u>IO线程</u>来管理的，当IO线程接收到这些处理事件时会将其添加到主线程的消息队列中，这样渲染主线程就能接收这些外部任务了。

在此基础上渲染进程还会经常接收其他进程的交互处理信息例如网络进程、浏览器进程的相关信息，这些进程产生的事件又是如何添加到渲染进程的消息队列中进行处理的呢？如下图所示，这些跨进程任务和渲染进程的IO线程进行沟通交互来进行任务的传送。

![](/images/react/2022012401.png)

当需要退出页面时，则会考虑到安全退出渲染进程主线程的问题，chrome会在主线程中设置一个<u>退出标志变量</u>，主线程每次执行完一个任务时都会判断退出标志是否有变化。如果有则会安全推出线程。

### 1.2 该结构的缺点

单线程以及先入先出的结构会产生两个问题。

第一：<u>如何处理高优先级任务</u>。比方说DOM节点变化渲染就是个需要优先处理的任务，针对这个情况，<u>微任务</u>就诞生了。我们将消息队列中的任务称为宏任务，每个宏任务都有一个微任务队列。在主线程执行某个宏任务的过程中如果监听接收到哪些需要优先处理的任务，就会把这些任务添加到当前的微任务队列中，当当前的宏任务执行结束后就执行微任务队列中的所有微任务，再继续执行下一个宏任务。

第二：<u>如何解决单个任务执行时长过久的情况</u>。因为是单线程执行，一次只能执行一个任务，当一个任务执行过久就会让人视觉上感受到页面卡顿的效果，针对这种情况，JavaScript采用<u>回调功能</u>来规避问题。

### 1.3 浏览器中的页面

可以再chrome的开发者工具中，点击“Performance"标签来查看页面加载的事件执行情况，如下图所示。

![](/images/react/2022012402.png)

## 2.Webapi：setTimeout

setTimeout是一个<u>定时器</u>，用来指定某个函数在多少毫秒之后执行，它会返回一个整数来表示定时器的编号，利用该编号可以取消定时器。以下为使用代码。

```
function showName(){
  console.log(" 极客时间 ")
}
var timerID = setTimeout(showName,200);
```

### 2.1 setTimeout的实现

定时器的作用就是为了在指定时间内执行某任务，如果将定时器放在普通的消息队列中，有可能在执行该定时器时就已经超过了任务时长。为了解决该问题，JavaScript又引入了<u>延迟队列机制</u>。

当JavaScript创建一个定时器时，渲染经常会将该定时器的回调任务添加到延迟队列当中，其中包括回调任务函数名称、发起时间、延迟执行时间。在主线程中每当处理完一个宏任务就会去执行延迟队列当中那些已经到期的任务。

### 2.2 使用setTimeout的注意事项

<u>如果当前任务执行时间过久，会影响延迟到期任务执行。</u>因为每次执行延迟队列中的任务都是在执行完一个宏任务之后的事情，如果该宏任务占用太多时间也有可能超过延迟队列中的任务定时时间。

<u>如果setTimeout存在嵌套调用，那么系统会设置最短时间为4ms 。</u>当setTimeout的嵌套函数调用超过5次以上，后面每次调用的最小时间间隔为4ms 。所以一些实时性较高的需求不太适合使用setTime。比如JavaScript动画。

<u>延迟执行时间有最大值。</u>定时器的执行延迟时间的最大值一般都为2147483647ms (大约24.8天，根据浏览器而异)，如果超出该值则会溢出，所以延迟时间的取值不能超过该值。

使用setTimeout设置的回调函数中的this不符合直觉。

比如以下这段代码的this就是指向全局，输出为1 。

```
var name= 1;
var MyObj = {
  name: 2,
  showName: function(){
    console.log(this.name);
  }
}
setTimeout(MyObj.showName,1000)
```

## 3.Webapi : XMLHttpRequest

XMLHttpRequest这个api的引入使得更新网络数据时无需刷新整张页面而直接操作DOM来更新页面内容。在深入理解XMLHttpRequest之前先理解<u>同步回调</u>和<u>异步回调</u>两个概念。

### 3.1 回调函数VS系统调用栈

将一个函数作为参数传递给另一个函数，那么作为参数的这个函数就是回调函数（其他情况也可以是回调函数，不一定必须是参数）。回调函数分为同步回调和异步回调，同步回调函数是指在主函数返回之前执行的函数，异步回调则是在主函数外部执行的回调函数，如下代码所示。

```
//同步回调
let callback = function(){
    console.log('i am do homework')
}
function doWork(cb) {
    console.log('start do work')
    cb()
    console.log('end do work')
}
doWork(callback)

//异步回调
let callback = function(){
    console.log('i am do homework')
}
function doWork(cb) {
    console.log('start do work')
    setTimeout(cb,1000)   
    console.log('end do work')
}
doWork(callback)
//异步回调
```

在页面的事件循环系统中，每一个消息队列中的任务都有一个系统调用栈，这个类似于JavaScript的调用栈，在当前任务被执行的过程中，同步回调就是在当前主函数的上下文中执行回调函数。异步回调会有两种处理方式：第一种是将异步函数做成一个任务添加到信息队列尾部；2.第二种是异步函数添加到维任务队列中，就可以在当前任务的末尾执行微任务。

### 3.2 XMLHttpRequest运行机制

首先通过以下图片可以了解XMLHttpRequest的实行机制。

![](/images/react/2022012403.png)

先从 XMLHttpRequest 的用法开始，首先看下面这样一段请求代码：

```
 function GetWebData(URL){
    /**
     * 1: 新建 XMLHttpRequest 请求对象
     */
    let xhr = new XMLHttpRequest()

    /**
     * 2: 注册相关事件回调处理函数 
     */
    xhr.onreadystatechange = function () {
        switch(xhr.readyState){
          case 0: // 请求未初始化
            console.log(" 请求未初始化 ")
            break;
          case 1://OPENED
            console.log("OPENED")
            break;
          case 2://HEADERS_RECEIVED
            console.log("HEADERS_RECEIVED")
            break;
          case 3://LOADING  
            console.log("LOADING")
            break;
          case 4://DONE
            if(this.status == 200||this.status == 304){
                console.log(this.responseText);
                }
            console.log("DONE")
            break;
        }
    }

    xhr.ontimeout = function(e) { console.log('ontimeout') }
    xhr.onerror = function(e) { console.log('onerror') }

    /**
     * 3: 打开请求
     */
    xhr.open('Get', URL, true);// 创建一个 Get 请求, 采用异步


    /**
     * 4: 配置参数
     */
    xhr.timeout = 3000 // 设置 xhr 请求的超时时间
    xhr.responseType = "text" // 设置响应返回的数据格式
    xhr.setRequestHeader("X_TEST","time.geekbang")

    /**
     * 5: 发送请求
     */
    xhr.send();
}
```

在封装请求时的第一步，创建XMLHttpRequest对象，第二步为xhr对象注册回调函数，第三步配置基础的请求信息，第四步发起请求。

### 3.3 XMLHttpRequest使用过程中的”坑“

**跨域问题**：默认情况下，跨域请求是不被允许的。

**HTTPS混合内容问题**：HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。通常，如果 HTTPS 请求页面中使用混合内容，浏览器会针对 HTTPS 混合内容显示警告，用来向用户表明此 HTTPS 页面包含不安全的资源。

## 4.宏任务与微任务

### 4.1 宏任务

页面中大部分任务都是在渲染进程的主线程上执行的，包括渲染事件（解析DOM、计算布局、绘制），用户交互事件、JavaScript脚本执行事件，网络请求完成，文件读写完成事件等。为了让这些任务有条不紊在主线程上执行而引入了消息队列和事件循环机制，在消息队列中的任务就是宏任务。

### 4.2 微任务

微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前。有两种方式可以创造微任务，分别是使用<u>MutationObserver</u>以及使用<u>Promise</u>。从V8引擎上分析，在执行一段JavaScript任务时JavaScript引擎会创建一个全局执行上下文，这个执行上下文中就包括微任务队列，在该JavaScript脚本执行结束前即即将销毁其执行上下文时会先检测其为任务队列，直到为任务队列彻底没有内容后才会销毁。

### 4.3 监听DOM变化方法演变

监听DOM变化是前端工程师一项非常核心的需求。一开始监听DOM的变化是设置<u>setTimeout或者setInterval</u>来定时检测DOM是否有变化，这个问题会有事件间隔长短以及资源消耗等问题，2000年的时候引入了<u>Mutation Event</u>，这个方法采用观察者设计模式，当DOM有变动时就会立刻触发相应的事件，采用的方法是同步回调。但是Mutation Event让每一次DOM发送变化要立刻调用JavaScript接口，这种实时性造成严重的性能问题，为了解决其同步回调产生的性能问题而引入了<u>MutionObserver</u>。它采用”异步+微任务“的策列来解决这些问题。

## 5.Promise和async await

### 5.1 异步编码问题

Promise解决了异步编码风格的问题。看普通的异步回调情况，如下代码所示。

```
// 执行状态
function onResolve(response){console.log(response) }
function onReject(error){console.log(error) }
 
let xhr = new XMLHttpRequest()
xhr.ontimeout = function(e) { onReject(e)}
xhr.onerror = function(e) { onReject(e) }
xhr.onreadystatechange = function () { onResolve(xhr.response) }
 
// 设置请求类型，请求 URL，是否同步信息
let URL = 'https://time.geekbang.com'
xhr.open('Get', URL, true);
 
// 设置参数
xhr.timeout = 3000 // 设置 xhr 请求的超时时间
xhr.responseType = "text" // 设置响应返回的数据格式
xhr.setRequestHeader("X_TEST","time.geekbang")
 
// 发出请求
xhr.send();
```

这一个网络请求多次使用了异步回调，使得代码逻辑显得不连贯和不线性。所以可以封装该请求使得符合我们的观看直觉。但即使封装之后也会出现低于回调的问题，这使得代码陷入一个非常混乱的局面，引入promise就可以很好解决低于回调的问题。（其实promise我也研究不是很透彻，包括后面的async await ，以后有时间仔细学习，这里就不细讲了）

### 5.2 async await

即使promise能够解决异步回调编码风格问题使其看起来更能理解，但是过多的<u>then方法</u>依旧似乎有着语义化不明显的问题，所以<u>ES7</u>引入了<u>async await</u>很好解决了这个问题。async await使得异步回掉函数的写法和同步回调几乎一样，视觉上一目了然非常简介。

async await其实背后的技术就是promise和生成器的应用。如下代码所示就是一个生成器的应用。

```
function* genDemo() {
    console.log(" 开始执行第一段 ")
    yield 'generator 2'
 
    console.log(" 开始执行第二段 ")
    yield 'generator 2'
 
    console.log(" 开始执行第三段 ")
    yield 'generator 2'
 
    console.log(" 执行结束 ")
    return 'generator 2'
}
 
console.log('main 0')
let gen = genDemo()
console.log(gen.next().value)
console.log('main 1')
console.log(gen.next().value)
console.log('main 2')
console.log(gen.next().value)
console.log('main 3')
console.log(gen.next().value)
console.log('main 4')
```

执行这个函数观察输出结果可以发现genDemo并不是一次执行完成的，全局代码和genDemo代码交易执行，这就是<u>生成器函</u>数的特性。

这里就涉及到了<u>协程</u>的概念，我们已经知道进程和线程的概念，一个进程里有多个线程，相类似的一个线程里也有多个协程，并且同一时间只能执行一个协程。如果从A协程启动了B协程，那么我们就将A协程称为B协程的<u>父协程</u>。如上代码就是执行在一个线程内的程序，但是它有两个协程，全局的父协程以及genDemo所对应的子协程。他们的连接和应用关系如下图所示。

![](/images/react/2022012404.png)

我们可以知道：第一、在生成器函数内部执行一段代码，如果遇到<u> yield </u>关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。外部函数可以通过<u> next</u> 方法恢复函数的执行。

我们必须知道一个线程中的协程是<u>交互执行</u>而不是并发执行的，它们的切换是通过yield和gen.next来配合完成的。另外，当gen协程中调用了yied方法时，JavaScript引擎就会保留gen协程当前的<u>调用栈</u>信息，并恢复父协程的调用栈信息；同样当父协程中执行gen.next时也会保留父协程的调用栈信息而恢复gen协程的调用栈信息，可以参考下图所示。

![](/images/react/2022012405.png)
