---

---

# 前端相关问题

## HTML

### SEO（搜索引擎优化，Search Engine Optimization）相关方法

- 语义化的HTML代码

- 重要内容不要用js输出，爬虫不会执行js获取内容

- 非装饰性图片必须加上alt,alt是图像替代文本。

### html5有哪些新特性

- 新增了媒体播放的video和audio

- 新增了本地存储localStorage和sessionStorage

- 新增了绘画canvas功能

### 行内元素有哪些、块级元素有哪些、空元素有哪些

- 行内元素有 `a span img input  select strong`，行内元素不可以设置宽高，不独占一行。

- 块级元素有` div ul li dl h1 h2 h3 p`，块级元素可以设置宽高，独占一行。

- 空元素有` br hr img input link meta`。

### meta标签

- meta标签可以实现自动跳转功能，如下代码所示：

- ```
  <meta http-equiv="Refresh" content="5;URL=page2.html">
  ```

- 去掉URL可以实现自动刷新功能。

### HTML全局属性有哪些

- class 、data-*、id、style等

### 语义化相关问题

- 语义化就是让标签有含义，使得代码结构清晰、可读性好、无障碍阅读、便于开发和维护、有利于搜索引擎

- img的alt就是图片的替代文字，当不能显示图片的情况就会显示alt的内容，有助于搜索引擎；title只是图片的补充说明文字，当鼠标移动到图片上时会显示。

- strong粗体强调标签，有语义化作用，b只是加粗效果。

- em斜体强调标签，有语义化作用，i只是斜体展示。

- h1表示标题样式，有语义化作用，title没有明确意义只表示是个标题。

## CSS问题

### CSS Sprite是什么，有什么优缺点

- 雪碧图，就是一张大图是由很多小图合成，通过`background-position`和元素尺寸调节需要显示的背景图案。

- 优点是减少了http请求次数，只需要请求一张图片。

- 缺点是图片合成麻烦，图片维护麻烦。

### `display: none;`与`visibility: hidden;`的区别

- 两者都能让元素不可见。

- display:none;改变的是布局，它能让元素从渲染树上消失，需要重新布局，会导致文档重排，是非继承属性。

- visibility:hidden;不会改变布局，元素依旧存在渲染树上，只是重绘的效果，是可继承属性。

### link和@import的区别

- link是html的元素来引用外部资源，@import是在css文件中引用外部资源。

- link最大限度支持并行下载，而@import过多嵌套导致串行下载。

### 什么时候FOUC?如何避免

- `flash of unstyled content` ： 用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再重新显示文档，造成页面闪烁。

### 如何创建会块级格式上下文（BFC）

- BFC是一个独立的渲染区域，让处于BFC内部的元素和外部的元素相互隔离，使得内外元素的定位不会相互影响。

- 触发条件：`float`的值不为`none;` `overflow`的值不为`visible;` `display`的值不为`inline-block`或`table-xxx;` `position`的值不为`static`或`relative`。

### 清除浮动的几种方式

- 父级`div`定义`height`

- 父级`div`定义伪类 `:after`和`zoom`

- 父级`div`定义`overflow:hidden`

### 初始化CSS样式

- 为什么要初始化CSS样式：因为不同的浏览器对标签的默认值是不同的，初始化CSS可以使得任意浏览器显示的页面样式相同。

### CSS3的新特性

- 弹性盒子 `dispaly:flex;`

- 颜色透明度 `color:rgba(0,0,0,0.5);`

- 圆角 `border-radius:5px；`

- 文字溢出 `text-overflow:ellipsis;`

### display有哪些值

- 设置元素浮动后，元素的display自动会变成block
- block 转化为块状元素
- inline 转化为行内元素
- none 设置元素为不可见
- inline-block 转化为行内块状元素
- table 块级表格元素
- inherit 继承父元素display属性值

### position的值

- static 默认值，没有定位，元素出现在正常流中。

- absolute 绝对定位元素，相对于父元素定位

- fixed 相对于窗口进行绝对定位

- relative 相对于当前位置的相对定位

- inherit 继承父级属性值。

### 标准的CSS盒子模型和低版本IE盒子模型

- 盒子模型都是由content内容，padding内边距,border边框，margin外边距组成，标准盒子模型内容不包括内边距，IE盒子模型内容包括外边距。对于标准盒子模型的元素总宽度是：width+padding+border+margin。

### CSS优先级算法计算

- 优先级：imortant>Html行内样式>id样式>类\伪类样式>元素样式

- 权重相同的元素后面定义的覆盖前面定义的

### PNG/GIF/JPG区别和选择

- GIF是动画，PNG和JPG是静态图片，JPG有损压缩，PNG适合小图标。

### ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用

- 单冒号表示伪类，双冒号表示伪元素

- 伪元素，在内容元素的前后插入额外的元素或样式，但这些元素实际上并不在文档中生成，只在外部显示可见，有content的用法。

- 伪类，将特殊效果添加到特定选择器上，是已有元素上添加类别，不会产生新的元素。

### 可以改变页面布局的属性

- position、display、float、width、height等（这个可能可以联系到之前学过的渲染原理篇）

### CSS性能优化方法

- CSS文件放在head里，不要用！import。

- 多个css合并，尽量减少http请求

- 选择器优化嵌套，尽量避免层次过深

- 属性为0时不加单位

### CSS3动画相关属性

- transition

- transform

- animation

### base64的原理及优缺点

- 优点：加密，减少了http请求；缺点是需要消耗cpu进行编解码。

- 适用于小图片，base64的体积约为原图4/3

### 几种常见的CSS布局

- 浮动布局，使用float

- 圣杯布局，三列布局，中间主体内容。

- flex布局

### 外边距重叠

- 两个外边距的单位相同（都是正或负），取绝对值的最大值，反之则相加。

### rgba()和opacity的透明效果区别

- 两者皆能透明，但是前者只作用于元素的颜色或背景色，没有继承性，后者作用于元素本身，其子元素也会透明。

### px和em的区别

- 都是长度单位

- px的值是固定的，指定是多少就是多少，计算比较容易，相对于显示器屏幕分辨率。

- em的值不是固定的，会继承父级元素的字体大小。em = 像素值 / 父级font-size

- 浏览器的默认字体高是16px，所以未经调整的浏览器都符合1em=16px。

### Sass和LESS

- 它们是CSS预处理器，是CSS上的一种抽象层，它们是一种特俗的语法/语言编译成CSS。

### 水平居中的方法

- 元素为行内元素，设置父元素 text-align:center

- 元素宽度固定，设置左右margin为auto

- 采用flex-box布局，justify-content为center

### 垂直居中的方法

- 采用flex-box布局，align-item:center

- 绝对定位中设置bottom:0;top:0，设置marhin:auto

- 绝对定位中设置高度为top:50%,margin-top为自身高度的一半的负值。

### 重绘与回流（重排）

- 重绘：当渲染树中的元素外观改变时但不影响布局时，产生重绘。

- 重排（回流）：当渲染树中的元素布局改变（比如位置、尺寸、隐藏/显示状态），产生重排，重排必然导致重绘。

### 如何实现小于12px的字体效果

- transform:scale()

### CSS有哪些继承属性

- 文本相关的属性，比如font-size,text-align等。颜色相关属性比如color。

### 用纯CSS创建一个三角形

```
#demo{
    width:0;
    height:0;
    border-width:20px;
    border-style:solid;
    border-color:transparent transparent red transparent;
}
```

### 隐藏元素的方法

- visibility:hidden;

- opacity:0设置一个元素完全透明

- display:none

- height:0;border:0;

### 什么是响应式设计？响应式设计的基本原理是？如何兼容低版本IE？

- 响应式设计就是网站能够兼容多个终端

- 基本原理是利用CSS3媒体查询，为不同尺寸设备适配不同版本

- 对于低版本IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容。

### a标签上四个伪类的执行顺序是什么？

- link>visited>hover>active

## JavaScript部分

### 闭包

- 闭包指有权访问另一个函数作用域中变量的函数，创建闭包最常见的方式就是一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用链域。

- 闭包的特性：函数内再嵌套函数，内部函数可以引用外层的参数和变量；参数和变量不会被垃圾回收机制回收。

### 作用域链

- 作用域就是变量和函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期

- 作用域链的作用是抱着执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止。

### JavaScript原型、原型链

- 每个对象都会在其内部初始化一个属性，就是prototype（原型），当我们访问一个对象的某个属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，这样一直找下去就形成了原型链的概念。

### 事件代理

- 事件代理指把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。

### JavaScript继承

- 构造继承

- ```
  function Parent(value){
      this.val=value
  }
  Parent.prototype.getValue=function(){
      console.log(this.val)
  }
  function Child(value){
      Parent.call(this,value)
  }
  Child.prototype=new Parent()
  const child=new Child(1)
  child.getValue()//1
  child instanceof Parent //true
  ```

- 原型继承

### This对象的理解

- 再函数定义中，this的指向是无法确定的，只有再函数执行时才能确定，this往往指向那个调用它的对象。

- 对于匿名函数或者直接调用函数来说，this指向全局上下文（window）。

- 对于es6的箭头函数，this的指向取决于该箭头函数声明的位置，在那里声明就指向谁。

- 如果有new关键字，this被永远绑定在new出来的那个对象。

- call、apply、bind中的this被强绑定在指定的那个对象上。

### call、apply、bind方法对比分析

- 这三个方法都是挂在function对象上的方法，都可以强行改变function中this的指向。

- ```
  func.call(thisArg,param1,param2,...)
  //call方法直接执行
  func.apply(thisArg,[param1,param2,...])
  //apply方法直接执行
  func.bind(thisArg,param1,param2,...)()
  //bind方法返回待执行函数
  ```

### new操作符

- 创建一个空对象，并且this变量引用该对象，同时继承了该函数的原型，属性和方法被加入到this引用的对象中，新创建的对象由this所引用，斌且最后隐式返回this。

### Ajax原理

- Ajax的原理就是在用户和服务器之间加一个中间层，通过XMLHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面，使得用户操作和服务器响应异步化。

### 如何解决跨域问题

- nginx代理跨域

- nodejs中间件代理跨域

### 异步加载JS的方式

- 设置<script>属性 async="async"

- XmlHttpRequest脚本注入

### 哪些操作会造成内存泄漏

- 内存泄漏指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收

- 不正确引用闭包函数

- 未使用var声明的全局变量

### XML和JSON的区别

- 数据体积方面，JSON相对于XML来讲，数据的体积小，传递的速度更快些。

- 数据交互方面，JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。

- 传输速度方面，JSON的速度要远快于XML。

- JSON是一种轻量级的数据交换格式，是基于JavaScript的一个子集。

### webpack的看法

- webpack是一个模块打包工具，可以使用webpack管理你的模块以来、并编译输出模块所需的静态文件。能够很好的管理、打包web开发中所用到的HTML、JavaScript、CSS以及各种静态文件，让开发过程更加高效。

### 常见的Web安全及防护原理

- 不要信任用户输入，用户的输入需要校验

- 永远不要使用管理员权限的数据库连接，未每个应用使用单独的权限有限的数据库连接

- 不要把机密信息明文存放，请加密或hash掉密码和敏感信息

### 为什么会有同源限制

- 同源策略是指协议、域名、端口相同，同源策略是一种安全协议，如果没有该策略黑客就可以轻易将病毒脚本插入到你的网站上盗取重要信息或者改变页面骗取用户

### JavaScript有哪些方法定义（创建）对象

- 使用var obj={};

- 使用 var obj = new Object();

- 使用var obj = Object.create(Object.prototype)；

### 对promise的理解

- Promise对象代表未来将要发生的事件，用来传递异步操作的消息。

- 有了Promise对象，就可以将异步操作以同步操作的流程表现出来，避免了层层嵌套的回调函数（解决了回调地狱的问题）。

- Promise对象的状态不受外界影响，有三种状态：Pending初始状态；fulfilled意味着操作成功完成状态；rejected意味着操作失败状态。一旦执行Promise就无法中途取消。

### async/await

- await相比promise来说，优势在于处理then的调用链，能够清晰准确写出代码。缺点在于滥用await会导致性能问题，因为await会阻塞代码。

- 一个函数如果加上async，那么该函数就会返回一个Promise。

- 清楚以下代码的执行顺序

- ```
  var a = 0
  var b = async () => {
    a = a + await 10
    console.log('2', a) // -> '2' 10
    a = (await 10) + a
    console.log('3', a) // -> '3' 20
  }
  b()
  a++
  console.log('1', a) // -> '1' 1
  ```

### Node的应用场景

- Node是一个JavaScript运行环境，依赖于Chrome V8引擎进行代码解释。它的优点是高并发，缺点是只支持单核CPU，不能充分利用CPU。

### JS的基本数据类型和引用数据类型

- 基本数据类型：underfined、null、boolean、number、string、symbol（存放在栈stack里）

- 引用数据类型：object（存放在堆heap里）

### JS数据类型检测

- typeof对于原始数据来说，对于null返回的是object，其他都能显示正确的类型。对于引用数据来说，除了函数都会显示object。

- instanceof可以正确判断对象类型，作用是检测当前实例是否属于某个类，但是它不能精准判断基础数据类型。

### ==和===的应用实例

- 只能转化为布尔值/数字/字符串

- 其他规则见原文档

### 四则运算

- 运算中其中一方为字符串，那么就会把另一方也转换为字符串

- 如果一方不是字符串或数字，那么会将它转换为数字或字符串

- 对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。

### 强制类型转换

- Number()

- parseInt()

- parseFloat()

- toString()

- String()

- Boolean()

### js里有哪些内置对象

- Object是所有对象的父对象

- 数据封装类对象：Object、Array、Boolean、Number等。

- 其他对象：Function

### JavaScript的基本规范

- 不要在同一行声明多个变量

- 请使用===/!==来比较true/false或者数值。==，当等号两边的类型相同时直接比较是否相等，若类型不相同则先转化为类型相同的值再进行比较（规则：null和undefined相等，等号两边一个是数值，则把其他类型转化为数字再进步比较，NaN和任何值包括NaN都不想动）。

- if语句必须使用大括号

### null和undefined的区别

- undefined表示不存在这个值，是一个表示“缺省值”的原始值，表示没有定义。如果变量被声明但是没有赋值时就等于undefined。

- null表示一个对象被定义为“空值”，它是一个对象，在验证null时需要用===而不是==。

### 同步和异步的区别

- 同步：浏览器访问服务器请求，用户看得见页面刷新，重新发请求，等请求完，页面刷新，新内容出现，用户看得见新内容，进行下一步操作。同步就是必须先完成前意见事情才能按照顺序完成后一件顺序。

- 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新新内容也会出现，用户能看到新的内容。异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

### defer和async

- defer并行加载js文件，会按照页面上的script标签的顺序执行。

- async并行加载js文件，下载完成立即执行，不会按照页面上script标签顺序执行。

### Ajax

- 它是一种异步通信的方法，通过直接由js脚本向服务器发起http通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。

### ES6相关

- 新增箭头函数

- ES6将promise对象纳入规范，提供原生promise对象

- 增加let和const命令用来声明变量（let变量增加了块级作用域）

### 面向过程编程和面向对象编程

- 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。

- 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事务在整个解决问题的步骤中的行为。面向对象是以功能来划分问题，而不是步骤。

- 面向对象的编程思想：基本思想是使用了对象、类、继承、封装等基本概念来进行程序设计。

### 事件机制

- 问题：事件的触发过程是怎么样的？知道什么是事件代理嘛？

- 事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在DOM中两种不同的传播方法。事件流有三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。

- 事件捕获就是当鼠标点击或者触发DOM事件时，浏览器会从根节点开始由外向内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定事件。

- 事件冒泡的顺序是由内到外直到根节点的传播。

### 如何通过js判断一个数组

```
//instanceof方法
var arr=[];
return arr instanceof Array==true

//constructor方法
return arr.constructor == Array


//isArray()方法
return Array.isArray(arr) == true
```

### let、var、const

- let和var都可以定义变量，const定义常量

- let和const是在es6中推出的

- let命令不存在变量提升，使用let和const命令会形成封闭作用域。

- let和const不允许重复声明

### map和forEach的区别

- forEach方法是最基本的遍历循环方法，map方法和forEach一致但是它会返回一个新的数组，所以在callback需要有return值，如果没有，会返回undefined。

### 箭头函数和普通函数的区别

- 箭头函数体内的this对象指向定义时所在的对象而不是使用时所在的对象

- 箭头函数不可以当作构造函数，不能使用new命令

### 异步编程实现方法

- 回调函数

- 事件监听

- 发布/订阅（观察者模式）

- Promise对象

- async对象

### js动画和css动画的区别及相应实现

- CSS3的动画在性能上会稍微好一点，代码相对简单，但是在动画控制上不够灵活。JavaScript的动画控制能力强大。

### JS数组和对象的遍历方式

- for循环、for in循环、forEach循环

### Vue的双向绑定数据的原理

- Vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter,getter，在数据变动时发布消息给订阅者，触发响应的监听回调。

### 快速让一个数组乱序

```
var arr=[1,2,3,4,5];
arr.sort(function(){
    return Math.random()-0.5;
})
console.log(arr);
```

### 数组去重方法

```
//1
function unique(arr){
    return Array.from(new Set(arr))
}
//2
function unique(arr){
    for(var i=0;i<arr.length;i++){
        for(var j=i+1;j<arr.length;j++){
        if(arr[i]===arr[j]){
            arr.splice(j,1)
            }
        }
    }
}
//利用sort先排序后比较
```

### JS中的全局变量和全局函数

- 全局变量：NaN\undefined等

- 全局函数：isNaN()、Number()、parseFloat()等

### 项目性能优化方法

- 减少HTTP请求数

- 避免重定向

- 压缩JavaScript、CSS、图片等

- 把JavaScript放在页面底部

### 浏览器缓存

- 浏览器缓存分为强缓存和协商缓存，当客户端请求某个资源时，获取缓存的流程如下为先根据这个资源的一些http header判断它是否命中强缓存，如果命中则直接从本地获取缓存资源，如果没有命中，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，如果命中，服务器会返回请求但不反悔资源来告诉客户端直接从缓存中获取。

### WebSocket

- 由于http存在一个明显的弊端（消息只能有客户端推送到服务端），导致服务器如果有连续变化就只能使用轮询，轮询效率过低，并不适合。所以WebSocket被发明出来。

- 对比HTTP，它支持双向通信，实时性强，可以发送文本和二进制文件。无跨域问题。

### 深浅拷贝

```
let a={ age:1 }
let b=a
a.age=2
console.log(b.age)//2
```

- 在上面这个例子中，给一个变量赋值一个对象，那么两者引用的就是同一个值，一方改变另一方也会改变。面对上面这个简单的情况，即只有一层对象可以用浅拷贝来解决问题。

- 浅拷贝用Object.assign来解决。

- ```
  let b=Object.assign({},a)
  
  //也可以用展开运算符来解决
  let b={...a}
  ```

- 如果是多层对象则需要用深拷贝来解决。

- ```
  let a={age:1,
         jobs:{first:'FE'}  
        }
  let b=JSON.parse(JSON.stringify(a))
  //JSON.stringify()将js转json
  //JSON.parse()将json转js
  ```

- 但是这个方法也是有局限的，它会忽略undefined，不能序列化函数，不能解决循环引用对象。

### 防抖/节流

- 防抖动是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行

### 作用域和变量提升

- 除了全局执行环境外，每当执行一个函数时也会创建一个新的执行环境，在生成新的执行环境时，会有两个阶段，第一个阶段就是创建的阶段，JS解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存，变量只声明并且赋值underfined，第二个阶段才是代码执行阶段。在变量提升过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升。

### MVVM模型

- MVVM是Model-View-ViewModel的缩写，也就是把MVC的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定倒ViewModel层并自动将数据渲染倒页面中，视图变化的时候会通知ViewModel层更新数据。

- Model:代表数据模型，数据层，它仅仅关注数据本身而不关心任何行为。

- View：用户操作界面，当ViewModel对Model进行更新时，会通过数据绑定更新到View。

- ViewModel：业务逻辑层，View需要什么数据，ViewModel要提供这个数据，View有某些操作，ViewModel就要响应这些操作。

### 请简单实现双向数据绑定

```
<input id="input"/>
```

```
const data={};
const input = document.getElementById('input');
Object.defineProperty(data, 'text', {
    set(value){
    input.value = value;
    this.value = value;
}
});
input.onChange = function(e){
    data.text = e.target.value;
}
```

### 微任务和宏任务

- JavaScript是单线程，为了协调任务有条不紊的运行页面进程引入了消息队列和事件循环机制，在主线程的消息队列中的任务叫做宏任务。比如 script、setTimeout、I/0
- 在当前宏任务执行结束之前执行的任务一般都是微任务。比如process.nextTick、promise

### JavaScript的组成

- ECMAScript（核心）：JavaScript语言基础

- DOM（文档对象模型）：规定了访问HTML和XML的接口

- BOM(浏览器对象模型)：提供了浏览器窗口之间进行交互的对象和方法。

### script的位置是否会影响首屏显示时间

- 在解析HTML生成DOM过程中，js文件的下载是并行的，不需要DOM处理到script节点。因此，script的位置不影响首屏显示的开始时间。

- 浏览器解析HTML是自上而下线性过程，script作为HTML的一部分同样遵循这个原则，因此，script会延迟DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间。

### 介绍DOM的发展

- DOM：文档对象模型，定义了访问HTML和XML文档的标准，与编程语言及平台无关。

- DOM0：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。

- DOM1：W3C提供标准。

### key属性的作用

- 由于在浏览器中操作DOM是很昂贵的，频繁操作DOM，会产生一定的性能问题，Key是元素的唯一标识符，设置key是未来尽可能复用DOM，从而高效更新虚拟DOM。

### 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”

- 客户区坐标：鼠标指针在可视区中水平坐标（clientX）和垂直坐标（clientY）。

- 页面坐标：鼠标指针在页面布局中的水平坐标（pageX）和垂直坐标（pageY）。

- 屏幕坐标：设备物理屏幕的水平坐标（screenX）和垂直坐标（screenY）。

### JavaScript垃圾回收方法

- 标记清除：这是JavaScript最常见的垃圾回收方式，当变量进入执行环境时，垃圾回收器会将其标记为“进入环境”，当变量离开环境时将其标记为“离开环境”。垃圾回收器会去除已经离开环境的变量。

- 引用计数：跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收。

### 如何删除一个cookie

- 将时间设为当前时间往前一点。

### JavaScript数组和对象有哪些原生的方法

- 数组：`arr.concat(arr1,arr2,arr3)`合并几个数组返回一个新的数组。  `arr.join(",")`将数组作为字符串返回，中间以都好分隔。`arr.sort(func) `以func的方式进行数组排序。`arr.pop()`删除数组最后一个元素。 `arr.shift()`删除数组第一个元素。`arr.push(e1,e2)`从数组的末尾添加元素。`arr.unshift(e1,e2)`从数组的开头添加元素。`arr.reverse()`反转数组元素顺序。`arr.slice(start,end) `返回选定的元素组成的数组。`arr.splice(index,count,e1,e2,en)`改变原始数组，用于添加或删除数组元素，从下标Index开始数count个元素替换为e1,e2,en，返回的是被删除的数组。`arr.indexOf(el)`返回元素所在的下标。`arr.includes(el)`判断数组是否包含该元素，返回true/false。

- 对象：`object.hasOwnProperty(prop)`判断该对象是否含有对应属性。`object.valueOf()`返回该对象的原始值。`object.toString()`返回一个表示该对象的字符串。

## 微信小程序

### 微信小程序有几个文件

- 包括app.js、app.json、app.wxss以及关于页面的文件是WXML+WXSS+JS+JSON。

### 微信小程序怎么样实现事件传值

- 给WXML元素添加`data-*`属性来传递需要的值，然后通过e.currentTarget.dataset或者onload的param参数获取。

### 小程序的wxss和css有什么区别

- wxss的图片引入需使用外链地址。

- 没有Body；样式可直接使用import导入。

### 微信小程序与vue的区别

- 生命周期不一样，微信小程序生命周期比较简单

- 数据绑定不一样，微信小程序数据绑定直接使用{{}}，vue直接使用:就可以。

- 显示和隐藏元素，vue中，使用v-if和v-show控制元素的显示和隐藏。小程序中使用wx-if和hidden控制元素的显示和隐藏。

- 数据处理不同，小程序中，全用bindtap或者catchtap绑定事件。vue中使用von或@event绑定事件。

### 微信小程序的生命周期

- onLoad：首次进入页面加载时触发，一张页面只进行一次。

- onShow：加载完成后、后台切到前台或者重新进入页面时触发。

- onReady：页面首次渲染完成时触发。

- onHide：从前台切换到后台或者进入其他页面时触发

- onUnload“页面卸载时触发。

## Vue

### Vue响应式原理（双向数据绑定）

- Vue的响应式原理的核心是通过Object.defindeProperty中访问器属性的get和set方法，data中声明的属性都被添加了访问器属性，当读取data中数据时自动调用get方法，修改data的数据时自动调用set方法。检测到数据的变化，会通知观察者Wacher，观察者自动触发重新render（粉刷、渲染）当前组件，生成新的虚拟DOM书，Vue框架会便利并对比新的虚拟DOM书和旧的虚拟DOM书中每个节点的差别，并记录下来。最后加载操作，将所有记录的不同点、局部修改到真实的DOM树上。

- Object.denfineProperty()可以检测到对象中数据发生修改，但是无法深度监听复杂的对象。

- Vue3.x中改用Proxy替代Object。defineProperty。因为Proxy可以直接监听对象和数组的变化。不需要深度遍历监听。Proxy是ES6中新增的功能，可以用来自定义对象的操作。

- Vue采用数据劫持结合发布-订阅模式的方法来实现数据响应。数据劫持就是Object.defineProperty()来劫持各个属性的setter,getter。

### 发布订阅模式和观察者模式

- 发布/订阅模式：假设有一个信号中心。当某个任务执行完成就向信号中心发布（Publish）一个信号，其他任务可以向信号中心定和约（subscribe）这个信号，从而知道什么时候自己可以开始执行。发布/订阅模式由统一调度中心调用，因此发布者和订阅者不需要知道对方存在。

- 观察者模式：当事件发生时，发布者通知自己所有的观察者，观察者获得信号就做需要做的事情。观察者模式是由具体的目标调度，比如当事件触发，Dep就会去调用观察者的方法，所以观察者模式的订阅者和发布者之间是存在依赖的。

### 虚拟DOM

- 虚拟DOM是用js对象模拟的，保存当前视图内所有DOM节点对象基本描述属性和节点间关系的树结构。

- 虚拟DOM的好处是当状态改变时不需要立即更新DOM，只需要创建一个虚拟树来描述DOM，虚拟DOM可以维护程序状态，跟踪上一次的状态，最后通过前后两个虚拟DOM的对比差异来更新真实DOM。

### Vue VS React

- 相同点：数据驱动页面都提供响应式的视图组件；都有virtual DOM,组件化的开发；数据流动单向，都支持服务器的渲染SSR，都有支持native的方法。

- 不同点：数据绑定上Vue实现双向数据绑定，React数据流动是单向的；对于大规模的数据渲染React要更快；在使用场景上React配合Redux架构适合大规模多人协作复杂项目，Vue适合小块的项目。开发风格上React推荐做法jsx+inline style把html和css都写在js了。vue是采用webpack+vue-loader单文件组件格式，html,js,css同一个文件。

### Vue的生命周期

- Vue2的生命周期函数顺序：beforeCreate（实例刚创建）、created（实例创建完成，属性已经绑定，但未生成真实DOM）、beforeMount（模板编译/挂载之前）、mounted（生成真实的DOM并替换到DOM Tree中，组件已挂载）、beforeUpdate（通知所有依赖项更新UI）、updated（组件已更新）、beforeDestroy（销毁开始）、destroyed（完成销毁）。

- Vue3的生命周期函数顺序：onBeforeMount、onMounted、onBeforeUpdate、onUpdated、onBeforeUnmount、onUnmounted。

### vue-router

- 路由就是指向的意思，对应页面中点击图标跳转页面的作用。路由有三个基本概念：route,routes,router。route是一条路由，routes是一组路由，router是一个机制，相当于一个管理者，它用来管理路由。

- 在vue中实现路由很简单，因为所有页面内容都是组件化的，所以只需要把路径和组件对应起来就行了，然后把组件渲染出来。

- 先使用`<router-view>`标签来定义显示部分，再用`<router-link>`来对应点击本分，再js中配置路由，首先可以定义所有的单条路由route，再组合成路由组routes，最后创建router来对路由组进行管理。

### VueX

- Vuex是一个专为Vue.js应用程序开发的状态管理模式+库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

### Vue3

- Vue3带来的新特性：压缩包体积更小；object.defineProperty改成Proxy等；重构Virtual DOM。

### computed的理解

- computed本质是一个惰性求值的观察者computed watcher。其内部通过this.dirty属性标记计算属性是否需要重新求值。

- computed有缓存性，在computed中定义的变量会判断它是否和之前的值有变化，若发生改变则会重新渲染，若没有改变则调用上一次计算缓存的数据，对比methods每调用一次就会重新计算而言提高了程序的性能。

### watch的理解

- watch没有缓存性，更多的是观察的作用，只有当监听的数据产生变化时才会执行对应的程序。

### keep-alive的理解

- keep-alive是Vue提供的一个抽象组件，用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在v页面渲染完毕后不会被渲染成一个DOM元素。

### Diff算法

- 在新老虚拟DOM对比时使用Diff算法

- 搜先对比节点本身，判断是否为同一节点，如果不为相同节点就删除该节点重新创建节点进行替换。

- 若为相同节点就判断如何对该节点的子节点进行处理，先判断一方有子节点一方无子节点的情况，再判断两方都有子节点的情况。

- 在diff中，只对同层子节点进行比较放弃跨级的节点比较，使得时间复杂度从O(N^3)转化为O(N)。

## React

### 对React的理解

- React是一个网页UI框架，通过组件化方式解决视图层开发复用问题，本质上是一个组件化框架，它的核心设计思路分别是声明式、组件化和通用性。声明式优势在于直观与组合，组件化的优势在于视图的拆分与模块复用，可以更容易做到高内聚低耦合，通用性在于一次学习随处编写。

## Http和浏览器

### 浏览器架构演变

- 一开始浏览器是单进程的，里面有很多线程比如说网络线程、页面线程等

- 后来变成了多进程浏览器，进程之间相互隔离提高了性能。Chrome浏览器有一个浏览器主进程、一个GPU进程、一个网络进程、多个渲染进程和多个插件进程。

### 进程和线程

- 进程（process）是CPU资源分配的最小单位（是能拥有资源和独立运行的最小单位）

- 线程（thread）是CPU调度的最小单位（是建立在进程基础的一次程序运行单位）

### HTTP的几种请求

- GET方法：发送请求获取服务器资源

- POST方法：提交服务器某数据

- PUT方法：PUT和POST不同的是，它制定了资源在服务器上的位置。

- DELETE方法：删除服务器上某数据

- OPTIONS方法，获取当前URL支持的所有方法。

### HTTP状态码及其含义

- 1XX：信息状态码。比如100表示继续，一般发送post请求时回返回该码。

- 2XX：成功状态码。

- 3XX：重定向。

- 4XX：客户端错误。

- 5XX：服务端错误。

### HTTP版本

- HTTP/0.9是个简单的文本协议，只能获取文本资源。只有一个命令GET。

- HTTP/1.0确定了大部分现在的实用技术，设立请求/响应报文的头部字段，但它不是正是标准。除了GET命令外还引入了POST和HEAD命令。请求消息中URL并没有传递主机名。

- HTTP/1.1是目前互联网上使用最广泛的协议，功能也非常完善，建立了长连接进行服用，对于TCP和HTTP的长连接。引入管道机制，即在同一个TCP连接中，客户端可以同时发送多个请求。HTTP请求头部信息增加了很多字段。新增了很多请求方法比如PUT、DELETE等。

- HTTP/2基于Google的SPDY协议，注重性能改善，但未普及。头部压缩、多路复用等。

- HTTP/3基于Google的QUIC协议，是将来的发展方向。

### HTTP之URL

- URL是用来唯一标记服务器上资源的一个字符串。

- scheme :// host:port path ?query

- scheme是协议名

- host:port是资源所在服务器主机号和端口号

- path标记资源所在的位置/

- query为对资源附加额外要求

### HTTP分层

- OSI分为七层，分别是物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。

- TCP/IP分为四层，分别是链接层，网络层，传输层和应用层。

- 在网络层实现IP协议，在传输层实现TCP/UDP协议，在应用层实现HTTP等协议。

### HTTP优缺点

- 优点：灵活可扩展、请求-应答模式、可靠传输。

- 缺点：无状态、明文传输、队头阻塞：当http开启长连接时，公用一个TCP连接，当某个请求时间过长，其他的请求只能处于阻塞状态。

### HTTP和HTTPS的区别

- HTTPS就是HTTP加上一个SSL或TLS，SSL/TLS协议是TCP和HTTP之间的协议。

- SSL:安全套接层

- TLS:传输层安全

### 从浏览器地址栏输入URL到显示页面的步骤

- 在地址栏中输入URL，首先会在浏览器的缓存中查找是否有对应资源，若有则直接返回给用户，若无则继续发送新的请求。

- 若继续发送新的请求，则根据URL获取对应的域名，端口号等信息，并且组装一个HTTP(GET)请求报文。

- 还需要获取服务端的IP地址，可以依次从浏览器的缓存、本机缓存、hosts文件、路由器缓存、DNS缓存中查找，若缓存中都没有就会从DNS服务器查找ip地址。

- 此时先建立TCP连接，需要实现三次握手。

- TCP链接建立后就发送之前已经组装的HTTP请求报文给服务器。

- 服务器受到请求后会返回对应的数据给客户端，会按情况将资源存进缓存。

- 可以根据情况关闭TCP连接，这时会有四次握手。

- 浏览器收到资源会先进行解码。

- 获得解析资源后第一步先根据html文件构建DOM树，根据CSS文件构建CSSOM树，两个数结合构建渲染树。

- 解析中途遇到其他资源比如js等可以进行下载，之后进行js解析，最后生成页面，并显示在浏览器上。

### DNS

- DNS的工作就是通过域名查询到具体的IP。DNS协议提供的是一种主机名到IP地址的转换服务，通常该协议运行在UDP协议上使用的端口是53端口号。

- 客户端先从浏览器缓存中查找对应IP，若无再查操作系统缓存，若无再找Host文件缓存，若无会直接去DNS跟服务器查询，然后依次传递查询一级域名服务器、二级域名服务器，三级域名服务器最后返回对应的查询结果。递归查询。

### TCP建立连接的三次握手

- 第一次握手：客服端向服务端发送请求报文，其中ACK=0,SYN=1。握手成功服务端知道了客户端具有发送能力。不懈怠数据。

- 第二次握手：服务端返回客服端一个响应报文，其中SYN=1,ACK=1。握手成功客户端直到服务端具有接收和发送能力。不懈怠数据。

- 第三次握手：客服端向服务端发送确认报文，其中SYN=0,ACK=1。握手成功，服务端知道客户端具有接受能力，已经准备好了。可以携带数据。

- 三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。如果没有三次握手，会出现这种现象，客户端发送请求访问报文给服务端，但是这个报文在网络中受阻延迟没有及时传达到，而超时后客户端会再次发送请求报文给服务端，此时服务端就会收到并且要处理先后两条请求报文，有了三次握手，客户端会忽略服务器发送的第二条响应请求报文，不会进行第三次握手。三次握手的主要目的是为了确认双方发送和接受能力是否正常。三次握手是因为二次握手后，服务器还没有确定客户端是否准备好。

### TCP释放连接的四次挥手

- 第一次挥手：客户端向服务端发送释放请求报文，其中FIN=1

- 第二次挥手：TCP处于半关闭状态，客户端无法再发送报文给服务端，服务端可以向客户端发送服务器端发送还未传送完毕的数据。

- 第三次挥手：服务端向客户端发送释放报文，FIN=1

- 第四次挥手：客户端向服务端发送确认报文，等待2MSL后释放应用。服务端收到确认报文后释放应用。

- 客户端发送释放报文后，TCP处于半关闭状态，这个状态能让服务端继续发送未传送完毕的数据，数据传完后，服务器会发送释放报文。

### UDP和TCP的区别

- TCP协议再传送数据段时要给段标号，UDP不用。

- TCP可靠，UDP不可靠。

- TCP速度慢，UDP速度快。

- TCP面向连接，UDP面向非连接。

- TCP应用于传输大量数据，UDP应用于传输少量数据。

### 如何进行网站性能优化

- 减少http请求，对资源进行压缩，使用link代替@import，删除不必要的代码等。

### 对于浏览器内核的理解

- 浏览器主要分为两个部分，渲染引擎和JS引擎，前者主要负责网页内容的渲染工作，后者主要负责解析和指向js文件。浏览器内核主要倾向于指渲染引擎

- Trident内核（IE、360、搜狗等浏览器）

- Webkit内核（Safari、Chrome浏览器等）

### 请描述cookies、sessionStorage和localStorage的区别

- cookie是网站为了标示用户身份而存储在客户端上的数据，cookie数据始终在同源的http请求中携带，会在浏览器和服务器中来回传递。

- sessionStorage和localStorage不会自动把数据发给服务器，仅保存在本地。

- 在存储大小上：cookie数据大小不超过4K，sessionStorage和localStorage可以达到5M或更大。

- 在有效时间上，localStorage存储持久数据，浏览器关闭后数据不会丢失除非主动删除，sessionStorage在浏览器窗口关闭就会自动删除，cookie数据在其设置的过期时间之前一直有效，即使浏览器关闭。

### 渲染优化

- 少使用gif图片实现loading效果（降低CPU消耗）、使用CSS3代码代替JS动画（尽量避免重绘重排）、对于一些小图标，使用base64编码代替网络连接以减少网络请求等。

### 为什么利用多个域名来存储网站资源会更有效

- 节约主域名的连接数，优化页面响应速度

### 优化图片加载的方法

- 如果是幻灯片、相册等可以使用图片预加载技术，优先下载当前图片前后的图片；如果图片是css图片可以采用CSSsprite以减少网络请求

### web开发中会话跟踪的方法

- 使用cookie

- url重写

### HTTP request报文结构是怎样的

- 首行是Request-Line包括请求方法、请求URL、协议版本。之后是请求头，包括很多词组信息、之后是请求体。

### HTTPresponse报文结构是怎样的

- 首行是状态行包括HTTP版本、状态码、状态描述。之后是响应头，再之后是响应体。

### git fetch和git pull的区别

- git pull相当于是从远程获取最新版本并merge到本地，`git fetch`相当于是从远程获取最新版本到本地，不会自动Merge。

### 跨域方案

- 所有方案都是为了搞定同源政策，比如ifram、script、图片ping

### XSS和CSRF

- CSS攻击就是攻击者想尽一切办法将可以执行的代码注入到网页中。可以分为持久型和非持久型，前者是攻击的代码被服务器端写入数据库，后者是通过修改URL参数的方式加入攻击代码。防范方法是不该信任任何用户的输入，对用户输入进行排查筛选。

- CSRF攻击是跨站请求伪造，简单说就是诱惑用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。防范方法是组织第三方网站请求接口，不让第三方网站访问到用户Cookie。

## 算法和编程

### 数组

- 初始化数组 `const arr= new Array(7)`；简单填充数组 `const arr=(new Array(7)).fill(1)`。

- 数组的遍历 for方法、forEach方法、map方法

### 二叉树

- 二叉树的遍历：先序遍历（根左右）、中序遍历（左根右）、后序遍历（左右根）

## 综合

### WebPack

- 一个模块打包器，能将多个js文件合成一个，增加文档解析效率。

### 重构

- 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，也就是说在不改变UI的情况下对网站进行优化。

- 比如针对SEO进行优化、表格table布局改DIV+CSS、升级第三方依赖、加入响应式布局、使用HTML5、CSS3、ES6新特性等。

### 什么样的前端代码是好的

- 高复用低耦合、遵循设计模式六大原则等。

### 前端工程师这个职业

- 前端是最贴近用户的程序员，比后端、数据库、产品经历、运营都要近。

- 前端工程的价值体现在为简化用户使用提供技术支持、为多个浏览器兼容性提供支持、为提高用户浏览速度提供支持等。

### 平时如何管理你的项目

- 先确定好全局样式、公共脚本

- 杨哥要求代码注释

- 严格要求静态资源存放路径

- Git提交必须填写说明

### web前端开发注意事项

- 多机型、多尺寸、多系统覆盖测试

## 人文相关

### 如何简单全面自我介绍

- 我叫邵美芝，来自浙大城市学院软件工程专业。虽然我主修的方向是大数据和人工智能方向，但是一直以来对软件开发也有浓厚的兴趣。大二的暑假我开始自学微信小程序的前端开发，并且和同学一起申请了一个创新创业项目，我们开发的产品名称叫做“基于传感器技术的智能植物养护系统”，我主要负责的是前端微信小程序开发以及AI花卉识别技术的实现。该项目最后也获得了省级创新创业大赛铜奖，之后我负责编写软著申请材料并且成功申请到了两篇软著，并且也成功发表了两篇论文，其中我为第一作者发表的技术类论文发表在了《计算机时代》这个期刊中。在之后在大三暑假需要实习的时候，我被老师介绍进她的合办公司进行前端开发工作，也因此学习到了除了微信小程序之外的技术，包括vue、un-app技术，并且都运用在了实际开发中。在今年的寒假我也在主动学习React技术。

### 对未来三到五年的规划

- 我知道自己现在的能力相对比较薄弱，所以在未来的一到二年中，我觉得以学习为主是最重要的，我希望在前两年里能够在团队里

### 你的优缺点是什么

- 关于优点，我曾经在学校项目和课程中多次担任小组组长，自认为具有担当力和执行力，有较好的任务规划能力，也能努力脚踏实地地完成自己的任务。

- 关于缺点，我不是一个活泼好动的人，做事比较内敛，很多事情喜欢自己先去琢磨和专研，直到实在无能为力才会寻求他人帮助，这样使得自己有时候会缺少和别人及时沟通而减缓了工作的效率。

### 这份工作能带给你什么

微信小程序复习

wx:if view bindtap image src data-* {{}} wx.showToast this.setData

wx.navigateTo({url:'...'}) wx.reLauch({}) 为什么要有key wx.request

key有什么作用

账号加密处理  使用MD5加密

网络请求包装

```
var util=require('../utils/util.js')
var requestHandler={
url:'',
method:'',
params:{},
success:function(res){
},
fail:function(res){
},
}
var app=getApp()
function GET(requestHandler){
request("GET",requestHandler)}
function POST(requestHandler){
request("POST",requestHandler)}
function request(method,requestHandler){
var ARI_URL=requestHandler.url;
var params=requestHandler.params;
wx.request({
url:API_URL,
data:params,
method:method,
header:{},
success:function(res){
requestHandler.success(res)
}
fail:function(res){
requestHandler.fail(res)
}
})
}
module.exports={
GET:GET,
POST:POST}
```

“一耕 GAP”农事记载平台2.0

这是一款面向农户的良好农产品认证以及农产品管理平台。它有两大模块，面向农户的用户模式和面向农科院相关人员的管理员模式。

用户模式主要有两大功能，第一就是农户为自己的产品申请良好农产品认证，需要用户填写包括自己的基本信息，生存产品的基本信息以及相关证明材料。第二就是当认证通过后用户能够为自己申请的产品进行相关管理，总共分为好几大模块，包括种植管理、农场基础信息管理、环境管理、畜牧管理、员工管理等。拥有不同产品的不同农户的农事管理页面也不相同，会根据农户的产品进行对应调配。

管理员模式其实主要是在web端进行的，主要进行的是对农户申请认证信息的审核、以及农户管理产品信息等情况，但是根据甲方需求需要在移动端也增加一个简易版本的管理模块，所以微信小程序上也有了管理员模块。主要有主体信息管理和农事记录管理模块，主体信息管理就是争对每个农户以及他的整体产业的管理、农事记录管理是针对每一次农户记录在案的农事操作比如灌溉、播种等操作记录的管理。具体包括搜索、筛选、查看详情等操作。

遇到过哪些问题

原生组件不能满足需求，只能自己创建组件（picker组件只能支持三列选择，自己创建了五列选择）

以及甲方一些需求，比如说管理端和用户端使用同一个微信小程序但是两个界面的底部导航条就是不一样的，所以就只能将四张页面集中写在一个page上来解决问题。

vue

element-ui v-if v-model @click : v-for="(item,index) in list"

浙江省农科院样品管理系统

这是一款面对浙江省农科院成员的平台，主要作用是线上管理农科院里的样品。主要包括三大模块，分别是被试物管理、对照物管理、参照物和标准物管理，其实这三个管理的流程是基本一致的。用户成员主要分为普通成员和样品管理员，当有新的样品进入农科院时，样品管理员就能在该平台上登记添加新的样品信息并依次分批使其入库，普通成员能够申请库中还有的样品，当样品管理员通过申请时普通成员就能使用该样品，最后使用完后普通成员需要申请样品归还，样品管理员审核归还的样品信息后会将归还的样品再次入库，最后样品管理员有权利作废样品。

遇到过哪些问题

这个项目只需要清楚业务逻辑就没有很大的问题，所以没有遇到什么比较困难的问题，一直都是根据甲方的需求更改一些功能和细节。比方说甲方希望能够有缓存功能就不用每次都输入很长的样品名称于是就设置了localStorage，甲方说直接在申请页面就能归还就在申请页面也增加了归还的接口等一些小细节问题。
