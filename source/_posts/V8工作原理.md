---
title: V8工作原理
date: 2022-01-11 15:29:49
tags: [浏览器, JavaScript, 前端面试]
categories:
- 浏览器
---

---

*本文来源于[http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程](http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82)[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。*

---

V8是谷歌团队研发的一种JavaScript引擎。本文将从数据存储、数据回收、编译机制三个角度来分析JavaScript。

## 1.数据存储

### 1.1 JavaScript是什么类型的语言

如C语言、Java语言就是在定义变量时就<u>需要声明变量类型</u>的语言，这种语言称为<u>静态语言</u>，像Python、JavaScript语言就是定义变量时无需声明变量类型的语言，这种语言叫做<u>动态语言</u>。如下段代码就是静态语言和动态语言的案例对比。

```
//静态语言-C语言
int main()
{
   int a = 1;
   char* b = " 极客时间 ";
   bool c = true;
   return 0;
}

//动态语言-JavaScript语言
var a=1
console.log(a,typeof(a))
```

如C语言、JavaScript语言又可称为<u>弱类型语言</u>，弱类型语言是指可以<u>支持隐式类型转换</u>的语言。反之，不支持隐式类型转换的语言就是<u>强类型语言</u>，如Java、Python。

所以，JavaScript是一种动态的、弱类型的语言。

### 1.2 JavaScript的数据类型

JavaScript一共有<u>8种</u>数据类型，这8种类型可以分为两大类型，分别是<u>基础类型（原始类型）和引用类型</u>。基础类型包括Boolean布尔类型、Null空值、Underfined未定义类型、Nubmber基于IEEE754标准的双精度64位数据类型、BigInt可以曹处Number的安全整数范围限制的新的数据类型、String文本类型、Symbol符号类型不可修改且唯一。引用类型的数据只有一种即<u>Object对象类型</u>。

其中要注意的是，使用typeof方法检测Null类型时返回的是Object（这是一个JavaScript一直以来的Bug）；Object类型是一种由基础类型组成的包含了key-value对的数据类型；基础数据类型和原始数据类型存储的位置不同。

### 1.3 内存空间

JavaScript运行时需要利用内存来存储数据，其中可以将内存分为三个部分分别是<u>代码空间</u>——用来存储可执行代码，<u>栈空间</u>——用来存储执行上下文，以及<u>堆空间</u>。

栈空间用来存储可执行上下文，一般基础数据都直接存储在栈中，而Object数据由于其往往需要占较大内存所以会将其存储在堆中，栈中只存储其内存地址。一般而言，栈空间的大小都是较小的，因为栈空间若是较大，则释放或添加执行上下文则会调用更大的时间，而堆空间一般较大，也可以存储更多的数据。

### 1.4 再谈闭包

以下这段代码涉及到了闭包。

```
function foo() {
    var myName = " 极客时间 "
    let test1 = 1
    const test2 = 2
    var innerBar = { 
        setName:function(newName){
            myName = newName
        },
        getName:function(){
            console.log(test1)
            return myName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName(" 极客邦 ")
bar.getName()
console.log(bar.getName())
```

按道理，foo函数中的 `myName`、`test1`变量都是基础数据，应该直接存储在栈中，而随着foo函数执行完毕也会随之销毁，那么闭包又是怎么形成的呢？这就要分析这段代码的执行流程。

首先JavaScript引擎执行foo函数时，会先编译，并创建一个空的执行上下文，编译过程中，遇到`setName`内部函数时会对其进行<u>一次快速的词法扫描</u>，发现在内部函数中遇到了其外部函数中定义的变量，JavaScript引擎就会判断这是一个闭包，就会在堆空间中创建一个<u>closure(foo)</u>的对象来存储相关变量。同理在`getName`函数中也会将`test1`变量存储在堆中对应位置。这样即使foo函数的执行上下文被移除，闭包中的变量也可以保留。

## 2.垃圾回收

有一些数据使用之后就不再需要，我们将这些数据称为<u>垃圾数据</u>，不同语言都有不同的垃圾回收政策，对于JavaScript语言则有一个<u>自动垃圾回收策略</u>。

### 2.1 调用栈中的数据回收

和操作系统中涉及到的栈结构相似，调用栈是利用<u>ESP指针</u>（永远指向栈顶的指针）来进行数据回收，因为栈是一种先入后出的结构，栈顶的数据是最先废弃掉的，所以通过移动ESP指针来确定栈顶的位置，ESP指针以上的部分就是被回收的可以重新覆盖的数据区域。

### 2.2 堆中的数据如何回收

在回收栈数据中，有一些数据类似Object数据是存储在堆中的，所以即使回收掉栈中的数据，堆中这些垃圾数据依旧没有被处理，那么这些数据该如何处理呢？这要涉及到<u>代际假说</u>的概念。

代际假说有<u>两个特点</u>，分别是大部分对象在对村中存在时间很短，很多对象一经分配内存就会变得不可访问，第二个特点是不死的对象会活很久。

代际假说适用于大多数的<u>动态语言</u>。V8通过将堆分为<u>新生代和老生代</u>两个区域，分别使用<u>副垃圾回收器和主垃圾回收器</u>来实现垃圾回收。

### 2.3 垃圾回收器的工作流程

V8的两个垃圾回收器拥有一套共同的执行流程。

第一步：标记空间中活动对象和非活动对象，活动对象就是还在使用的对象。

第二步：回收非活动对象所占据的内存。

第三步：进行内存整理，一般在回收对象后，内存中会出现大量不连续的空间，如果需要分配较大连续空间时就会出现内存不足的情况，所以需要进行内存整理。而整理<u>内存碎片</u>其实只在老生代中会进行，使用副垃圾回收器无需再新生代进行此步骤。

**副垃圾回收器**：主要负责新生区的垃圾回收，通常情况，大多数<u>小的对象</u>都会被分配到新生区，所以该区域虽然不大但是使用频繁。新生区又对半分为对象区域和空间区域。如下图所示为堆的结构图：

![](/images/react/2022011102.png)

新加入的对象会被放入对象区域，当对象区域被写满时，则需要执行一次垃圾清理操作。

在垃圾回收过程，首先要对对象进行标记，标记完成后会将存货的对象<u>复制</u>到空闲区域，并且将它们<u>有序排列</u>起来，这个过程也相当于完成了<u>内存整理</u>工作。完成复制后会将对象区域和空闲区与进行<u>角色翻转</u>，原来被填满的对象区域变成了空闲区域。以此这样反复循环的使用就是在新生代中采用的<u>Scavenge算法</u>。

由于新生区的空间不大，很容易就被存活对象装满整个区域，所以JavaScript引擎采用了<u>对象晋升策略</u>，将两次垃圾回收仍然存活的新生区对象转移到老生区中。

**主垃圾回收器**：主要负责老生区中的垃圾回收，对比于新生区，它的对象总是<u>占用较大空间或者是存活时间较长</u>。

因为老生区空间较大不适合采用Scavenge算法，其采用了<u>标记-清除（Mark-Sweep）算法</u>进行垃圾回收。

比如，当调用栈中要移除顶部的执行上下文后，就会进行一次数据扫描——此时便利调用栈，发现找不到相应堆中某数据的引用地址，则会标记堆中该数据为垃圾数据，标记完垃圾数据后就是清除阶段，直接清除被标记为垃圾数据的数据，然后采用<u>标记-整理（Mark-Compact）算法</u>进行内存整理。具体的老生区标记清除过程和标记整理过程如下两张图所示。

![](/images/react/2022011103.png)

![](/images/react/2022011104.png)

### 2.4 全停顿

我们已经知道V8是如何进行垃圾回收的，但由于JavaScript是运行在主线程上，一旦执行垃圾回收算法，就需要暂停其他正在执行的JavaScript脚本，直到垃圾回收执行完毕才能继续执行脚本，这种行为叫做<u>全停顿（Stop-The-World）</u>。

全停顿总是会消耗一定时间导致<u>页面卡顿</u>的问题，为了解决这样的现象V8将主垃圾回收器的标记过程分为一个个的<u>子标记</u>过程，让这些块过程和JS脚本交叉运行，这个算法叫做<u>增量标记（Incremental Marking)算法</u>。

## 3.代码编译

要深入理解V8的工作原理，需要理解一些概念和原理，比如接下来要详细介绍的<u>编译器(Compiler)、解释器(Interpreter)、抽象语法树(AST）、字节码(Bytecode)、及时编译器(JIT)</u>。

### 3.1 编译器和解释器

从程序员能够理解的高级语言到机器能够理解的机器语言之间需要使用到编译器/解释器来进行语言的转换。如C/C++、GO等是通过编译器来解析语言的<u>编译型语言</u>；如Python、JavaScript等则是通过解释器来解析语言的<u>解释型语言</u>。以下是编译器和解析器翻译代码的过程图。

![](/images/react/2022011105.png)

从图中你可以看出这二者的执行流程，大致可阐述为如下：

在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功

在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。

### 3.2 V8执行一段JavaScript代码过程

如图所示为V8执行一段JavaScript代码的流程图。

![](/images/react/2022011106.png)

第一步：源代码生成<u>抽象语法树</u>和执行上下文。

这个步骤相当于Html文件转化为浏览器可以理解的DOM树情况雷系，Javascript也是要转化为计算机能够理解的AST结构。这个过程分别运用到了<u>词法分析</u>和<u>语法分析</u>。

第二步：<u>解释器Lgnition</u>根据AST生成<u>字节码</u>。

第三步：判断是否为<u>热点代码(HotSpot)</u>，如果不是则将字节码放入<u>解释器</u>逐条解释执行，如果是则将字节码放入<u>JIT编译器</u>编译成高效的机器码来执行。这样能够提高代码的整体执行效率。

### 3.3 JavaScript的性能优化

主要关注以下三个方面。

- 提升但此脚本的执行速度，避免JavaScript的长任务霸占主线程，这样可以使得页面快速响应交互。

- 避免大的内联脚本，因为在解析HTML的过程中，解析和编译也会占用主线程。

- 减少JavaScript文件容量，因为更小的文件会提升下载速度，并且占用更低的内存。
