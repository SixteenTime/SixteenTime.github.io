{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/2021121101.png","path":"images/2021121101.png","modified":0,"renderable":0},{"_id":"source/images/2021121201.jpg","path":"images/2021121201.jpg","modified":0,"renderable":0},{"_id":"source/images/2021121202.png","path":"images/2021121202.png","modified":0,"renderable":0},{"_id":"source/images/2021121301.png","path":"images/2021121301.png","modified":0,"renderable":0},{"_id":"source/images/2021121401.png","path":"images/2021121401.png","modified":0,"renderable":0},{"_id":"source/images/2021121302.png","path":"images/2021121302.png","modified":0,"renderable":0},{"_id":"source/images/2021121402.png","path":"images/2021121402.png","modified":0,"renderable":0},{"_id":"source/images/2021121403.png","path":"images/2021121403.png","modified":0,"renderable":0},{"_id":"source/images/2021121405.png","path":"images/2021121405.png","modified":0,"renderable":0},{"_id":"source/images/2021121404.png","path":"images/2021121404.png","modified":0,"renderable":0},{"_id":"source/images/2021121701.png","path":"images/2021121701.png","modified":0,"renderable":0},{"_id":"source/images/2021121601.png","path":"images/2021121601.png","modified":0,"renderable":0},{"_id":"source/images/2021121702.png","path":"images/2021121702.png","modified":0,"renderable":0},{"_id":"source/images/2021121801.png","path":"images/2021121801.png","modified":0,"renderable":0},{"_id":"source/images/2021121802.png","path":"images/2021121802.png","modified":0,"renderable":0},{"_id":"source/images/2021122201.png","path":"images/2021122201.png","modified":0,"renderable":0},{"_id":"source/images/2021122202.png","path":"images/2021122202.png","modified":0,"renderable":0},{"_id":"source/images/2021122301.png","path":"images/2021122301.png","modified":0,"renderable":0},{"_id":"source/images/2021122302.png","path":"images/2021122302.png","modified":0,"renderable":0},{"_id":"source/images/2021122501.png","path":"images/2021122501.png","modified":0,"renderable":0},{"_id":"source/images/2021122701.png","path":"images/2021122701.png","modified":0,"renderable":0},{"_id":"source/images/2022011201.png","path":"images/2022011201.png","modified":0,"renderable":0},{"_id":"source/images/Alex/02.png","path":"images/Alex/02.png","modified":0,"renderable":0},{"_id":"source/images/Alex/01.png","path":"images/Alex/01.png","modified":0,"renderable":0},{"_id":"source/images/Alex/03.png","path":"images/Alex/03.png","modified":0,"renderable":0},{"_id":"source/images/Alex/04.png","path":"images/Alex/04.png","modified":0,"renderable":0},{"_id":"source/images/Alex/05.png","path":"images/Alex/05.png","modified":0,"renderable":0},{"_id":"source/images/Alex/07.png","path":"images/Alex/07.png","modified":0,"renderable":0},{"_id":"source/images/Alex/06.png","path":"images/Alex/06.png","modified":0,"renderable":0},{"_id":"source/images/Alex/09.png","path":"images/Alex/09.png","modified":0,"renderable":0},{"_id":"source/images/Alex/08.png","path":"images/Alex/08.png","modified":0,"renderable":0},{"_id":"source/images/Alex/10.png","path":"images/Alex/10.png","modified":0,"renderable":0},{"_id":"source/images/Alex/11.png","path":"images/Alex/11.png","modified":0,"renderable":0},{"_id":"source/images/beauty/01.png","path":"images/beauty/01.png","modified":0,"renderable":0},{"_id":"source/images/beauty/02.jfif","path":"images/beauty/02.jfif","modified":0,"renderable":0},{"_id":"source/images/beauty/03.jfif","path":"images/beauty/03.jfif","modified":0,"renderable":0},{"_id":"source/images/beauty/05.JPG","path":"images/beauty/05.JPG","modified":0,"renderable":0},{"_id":"source/images/beauty/07.PNG","path":"images/beauty/07.PNG","modified":0,"renderable":0},{"_id":"source/images/beauty/06.JPG","path":"images/beauty/06.JPG","modified":0,"renderable":0},{"_id":"source/images/beauty/08.PNG","path":"images/beauty/08.PNG","modified":0,"renderable":0},{"_id":"source/images/beauty/09.jpeg","path":"images/beauty/09.jpeg","modified":0,"renderable":0},{"_id":"source/images/beauty/10.png","path":"images/beauty/10.png","modified":0,"renderable":0},{"_id":"source/images/beauty/12.png","path":"images/beauty/12.png","modified":0,"renderable":0},{"_id":"source/images/beauty/11.png","path":"images/beauty/11.png","modified":0,"renderable":0},{"_id":"source/images/beauty/14.png","path":"images/beauty/14.png","modified":0,"renderable":0},{"_id":"source/images/beauty/13.png","path":"images/beauty/13.png","modified":0,"renderable":0},{"_id":"source/images/beauty/15.png","path":"images/beauty/15.png","modified":0,"renderable":0},{"_id":"source/images/beauty/16.png","path":"images/beauty/16.png","modified":0,"renderable":0},{"_id":"source/images/book/01.jpg","path":"images/book/01.jpg","modified":0,"renderable":0},{"_id":"source/images/react/2021121901.png","path":"images/react/2021121901.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122001.png","path":"images/react/2021122001.png","modified":0,"renderable":0},{"_id":"source/images/react/2021121902.png","path":"images/react/2021121902.png","modified":0,"renderable":0},{"_id":"source/images/react/2021121903.png","path":"images/react/2021121903.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122002.png","path":"images/react/2021122002.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122003.png","path":"images/react/2021122003.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122004.png","path":"images/react/2021122004.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122005.png","path":"images/react/2021122005.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122006.png","path":"images/react/2021122006.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122101.png","path":"images/react/2021122101.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122102.png","path":"images/react/2021122102.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122103.png","path":"images/react/2021122103.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122106.png","path":"images/react/2021122106.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122104.png","path":"images/react/2021122104.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122107.png","path":"images/react/2021122107.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122105.png","path":"images/react/2021122105.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122108.png","path":"images/react/2021122108.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122110.png","path":"images/react/2021122110.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122111.png","path":"images/react/2021122111.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122109.png","path":"images/react/2021122109.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122112.png","path":"images/react/2021122112.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122115.png","path":"images/react/2021122115.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122113.png","path":"images/react/2021122113.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122114.png","path":"images/react/2021122114.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122116.png","path":"images/react/2021122116.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122118.png","path":"images/react/2021122118.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122117.png","path":"images/react/2021122117.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122119.png","path":"images/react/2021122119.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122120.png","path":"images/react/2021122120.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122121.png","path":"images/react/2021122121.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122201.png","path":"images/react/2021122201.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122202.png","path":"images/react/2021122202.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122203.png","path":"images/react/2021122203.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122204.png","path":"images/react/2021122204.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122205.png","path":"images/react/2021122205.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122301.png","path":"images/react/2021122301.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122302.png","path":"images/react/2021122302.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122303.png","path":"images/react/2021122303.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122305.png","path":"images/react/2021122305.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122304.png","path":"images/react/2021122304.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122306.png","path":"images/react/2021122306.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122307.png","path":"images/react/2021122307.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122308.png","path":"images/react/2021122308.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122309.png","path":"images/react/2021122309.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122310.png","path":"images/react/2021122310.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122311.png","path":"images/react/2021122311.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122312.png","path":"images/react/2021122312.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122701.png","path":"images/react/2021122701.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122702.png","path":"images/react/2021122702.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122703.png","path":"images/react/2021122703.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122704.png","path":"images/react/2021122704.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122705.png","path":"images/react/2021122705.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122706.png","path":"images/react/2021122706.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122707.png","path":"images/react/2021122707.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122708.png","path":"images/react/2021122708.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122709.png","path":"images/react/2021122709.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122710.png","path":"images/react/2021122710.png","modified":0,"renderable":0},{"_id":"source/images/react/2021122711.png","path":"images/react/2021122711.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011001.png","path":"images/react/2022011001.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011002.png","path":"images/react/2022011002.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011003.png","path":"images/react/2022011003.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011006.png","path":"images/react/2022011006.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011004.png","path":"images/react/2022011004.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011007.png","path":"images/react/2022011007.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011005.png","path":"images/react/2022011005.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011008.png","path":"images/react/2022011008.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011009.png","path":"images/react/2022011009.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011010.png","path":"images/react/2022011010.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011011.png","path":"images/react/2022011011.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011013.png","path":"images/react/2022011013.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011014.png","path":"images/react/2022011014.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011012.png","path":"images/react/2022011012.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011101.png","path":"images/react/2022011101.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011102.png","path":"images/react/2022011102.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011103.png","path":"images/react/2022011103.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011104.png","path":"images/react/2022011104.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011106.png","path":"images/react/2022011106.png","modified":0,"renderable":0},{"_id":"source/images/react/2022011105.png","path":"images/react/2022011105.png","modified":0,"renderable":0},{"_id":"source/images/react/2022012401.png","path":"images/react/2022012401.png","modified":0,"renderable":0},{"_id":"source/images/react/2022012402.png","path":"images/react/2022012402.png","modified":0,"renderable":0},{"_id":"source/images/react/2022012403.png","path":"images/react/2022012403.png","modified":0,"renderable":0},{"_id":"source/images/react/2022012404.png","path":"images/react/2022012404.png","modified":0,"renderable":0},{"_id":"source/images/react/2022012405.png","path":"images/react/2022012405.png","modified":0,"renderable":0},{"_id":"source/images/theme/cloud.png","path":"images/theme/cloud.png","modified":0,"renderable":0},{"_id":"source/images/theme/loading.gif","path":"images/theme/loading.gif","modified":0,"renderable":0},{"_id":"source/images/theme/loading2.png","path":"images/theme/loading2.png","modified":0,"renderable":0},{"_id":"source/images/theme/post-image.png","path":"images/theme/post-image.png","modified":0,"renderable":0},{"_id":"source/images/theme/welcome-image.jpg","path":"images/theme/welcome-image.jpg","modified":0,"renderable":0},{"_id":"source/images/theme/welcome-image.png","path":"images/theme/welcome-image.png","modified":0,"renderable":0},{"_id":"source/images/theme/welcome-image2.jpg","path":"images/theme/welcome-image2.jpg","modified":0,"renderable":0},{"_id":"source/images/theme/welcome-image3.jpg","path":"images/theme/welcome-image3.jpg","modified":0,"renderable":0},{"_id":"source/images/theme/welcome-image4.jpg","path":"images/theme/welcome-image4.jpg","modified":0,"renderable":0},{"_id":"source/images/theme/welcome-image5.png","path":"images/theme/welcome-image5.png","modified":0,"renderable":0},{"_id":"source/images/theme/welcome-image6.jfif","path":"images/theme/welcome-image6.jfif","modified":0,"renderable":0},{"_id":"source/images/theme/welcome-image7.jfif","path":"images/theme/welcome-image7.jfif","modified":0,"renderable":0},{"_id":"themes/zhaoo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/js/color-mode.js","path":"js/color-mode.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/apple-touch-icon.png","path":"images/icons/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/favicon-128x128.png","path":"images/icons/favicon-128x128.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/favicon-144x144.png","path":"images/icons/favicon-144x144.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/favicon-16x16.png","path":"images/icons/favicon-16x16.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/favicon-32x32.png","path":"images/icons/favicon-32x32.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/logo_128.png","path":"images/icons/logo_128.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/logo_144.png","path":"images/icons/logo_144.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/logo_32.png","path":"images/icons/logo_32.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/logo_16.png","path":"images/icons/logo_16.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/logo_180.png","path":"images/icons/logo_180.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/logo_500.png","path":"images/icons/logo_500.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/zhaoo-logo.png","path":"images/icons/zhaoo-logo.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/cloud.png","path":"images/theme/cloud.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/loading.gif","path":"images/theme/loading.gif","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/loading2.png","path":"images/theme/loading2.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/post-image.png","path":"images/theme/post-image.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/welcome-image.png","path":"images/theme/welcome-image.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/welcome-image2.jpg","path":"images/theme/welcome-image2.jpg","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/welcome-image4.jpg","path":"images/theme/welcome-image4.jpg","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/welcome-image3.jpg","path":"images/theme/welcome-image3.jpg","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/welcome-image5.png","path":"images/theme/welcome-image5.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/welcome-image6.jfif","path":"images/theme/welcome-image6.jfif","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/welcome-image7.jfif","path":"images/theme/welcome-image7.jfif","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/welcome-image8.png","path":"images/theme/welcome-image8.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/daovoice/daovoice.js","path":"lib/daovoice/daovoice.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/fancybox/fancybox.css","path":"lib/fancybox/fancybox.css","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/fancybox/fancybox.js","path":"lib/fancybox/fancybox.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/gitalk/gitalk.css","path":"lib/gitalk/gitalk.css","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/gitalk/gitalk.js","path":"lib/gitalk/gitalk.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/highlight/a11y-dark.css","path":"lib/highlight/a11y-dark.css","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/highlight/highlight.js","path":"lib/highlight/highlight.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/jquery/jquery.js","path":"lib/jquery/jquery.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/pjax/pjax.js","path":"lib/pjax/pjax.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/lazyload/lazyload.js","path":"lib/lazyload/lazyload.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/lottie/lottie.js","path":"lib/lottie/lottie.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/qrcode/qrcode.js","path":"lib/qrcode/qrcode.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"451bb6994a62aac57cf5f269cc4cd7873cd0ed81","modified":1639440962904},{"_id":"source/_posts/HTTP1.md","hash":"41265116f5297a58f5c48540eaae6b977a49d7eb","modified":1645499016354},{"_id":"source/_posts/React学习一.md","hash":"62e9afb5c8205d741727e7d1f2fde82281e7196c","modified":1646969265064},{"_id":"source/_posts/React学习三.md","hash":"e387ea5e3d2b086f62d4fea8b779f56a32c035bd","modified":1646970128310},{"_id":"source/_data/galleries.json","hash":"0484953b7c2e99f42ae6f3a0a04ac8f62038dec9","modified":1640009008207},{"_id":"source/_posts/React学习二.md","hash":"54bea8070c35a1dc3d13793a141efa9b713eb9e4","modified":1646969607995},{"_id":"source/_posts/React学习四.md","hash":"c2e7c625f5b9a2b2cfac019dc6526ec31ea0a130","modified":1646970166980},{"_id":"source/_posts/Git.md","hash":"f6e41413ee58935e32f3fbd97ee82b5ee2f135eb","modified":1640089454901},{"_id":"source/_posts/一封信.md","hash":"3e282f32a8eba2fe6d30b79b97034973a4559809","modified":1641976029866},{"_id":"source/_posts/V8工作原理.md","hash":"5e248285e5d8b7bdc42364a8c70dddd674cdc0c3","modified":1641893488910},{"_id":"source/_posts/二零二一年十二月十八日.md","hash":"4afa0e346dcb4dd85aaebb5d1362a33d70ec757a","modified":1640007576723},{"_id":"source/_posts/二零二一年十二月二十三日.md","hash":"4edcabca10d1736971b2f56f0f2ee72b24535261","modified":1640273192658},{"_id":"source/_posts/前端相关问题.md","hash":"7060e17ab4336afb3da6d9dfb056501d6cc63994","modified":1647512781295},{"_id":"source/_posts/二零二一年十二月二十七日.md","hash":"28f31593586d5d07c3cb57d6d9becf0d16f6c2ab","modified":1640613754327},{"_id":"source/_posts/二零二一年十二月二十二日.md","hash":"7257a81f94697e1a1b58f51ed8b043ce613295c9","modified":1640189466814},{"_id":"source/_posts/二零二一年十二月二十五日.md","hash":"f3561bbf6efaa00d104f3f7384e1ad0b390cc1af","modified":1640614813533},{"_id":"source/_posts/二零二一年十二月十七日.md","hash":"581b4435863fb9543ede1ada633f4ed2e15bee20","modified":1640009031719},{"_id":"source/_posts/数据库原理复习.md","hash":"5209e3556c05d5d442b515e232850b8e5bfce6dc","modified":1640089454911},{"_id":"source/_posts/二零二一年十二月十四日.md","hash":"0b9d33837c31393342394121d4edfa2ef6501ea7","modified":1639643160432},{"_id":"source/_posts/搭建hexo博客时出现的问题.md","hash":"26a82d26ccf278d10a555b59813790a7d184cec1","modified":1639288034291},{"_id":"source/_posts/操作系统复习.md","hash":"7ce3099d94e3f245f83b45f295319726e12f98ef","modified":1640089454910},{"_id":"source/_posts/正则表达式.md","hash":"01efd8638ed0533d7ec2ab2dd6c9404176f43011","modified":1640089478372},{"_id":"source/_posts/浏览器安全问题.md","hash":"5a172fc11c167d03cc81fdcefd35e554a218bd8c","modified":1645591309232},{"_id":"source/_posts/日本女性简简简史笔记.md","hash":"38ee99a7ce59d0654f565df50f3cbc31c9de4ac4","modified":1643012871035},{"_id":"source/_posts/虚无的日常.md","hash":"3f4c6c32c5cf749b6ecd1de6c450c2aa0f5172b7","modified":1648205734310},{"_id":"source/_posts/浏览器中的页面循环系统.md","hash":"420e5d3d5f90c94fb028ca39f300babf0158b641","modified":1643012545710},{"_id":"source/_posts/计算机网络复习.md","hash":"28af54ecf4c625e91e52c5f997ff207a95b44895","modified":1645606341985},{"_id":"source/_posts/浏览器中JavaScript执行机制.md","hash":"314052aea647c66bc603dcd26f22cb0bf11f081d","modified":1641870810984},{"_id":"source/categories/index.md","hash":"108d69d9b70c1b66531b8de5e89d809f9fad26a6","modified":1639274948833},{"_id":"source/_posts/浏览器相关.md","hash":"30bd5fac3838c0938bf774ecd79b57b10d3e7e81","modified":1640567892135},{"_id":"source/galleries/index.md","hash":"2af42f5c4d404b22104a41e8875d39d1831b7dac","modified":1639273789465},{"_id":"source/_posts/面向对象思想.md","hash":"33baa1ac6dac606538391e596618dc9f96fe27b8","modified":1640089454915},{"_id":"source/about/index.md","hash":"1751fce61820bd9bb9ce9b449dbed8545252d945","modified":1639355567651},{"_id":"source/tags/index.md","hash":"377d1b44097a7b98e5e31bb0a65182f9da9e503c","modified":1639274768635},{"_id":"source/galleries/Alex/index.md","hash":"5ae37990cb5cccd752852aa3f724973af5a4682f","modified":1640008735335},{"_id":"source/galleries/书摘/index.md","hash":"22f86612984ec0bd86f7a04be5b7d2f2a8c6fb04","modified":1639287258273},{"_id":"source/galleries/她们/index.md","hash":"8a87ebd038bec449a2d702110bb6254754817827","modified":1639274685735},{"_id":"source/images/beauty/06.JPG","hash":"6670a0675966694f0cd37fcafb81b078548ca009","modified":1606639594000},{"_id":"source/images/react/2021121902.png","hash":"2b68e23d92d07b1185b3d93f6dca26325843f24b","modified":1639877711270},{"_id":"source/images/react/2021121901.png","hash":"34ffc46a845eddb6ee3172511e1a88bc81fb6bc0","modified":1639877698957},{"_id":"source/images/react/2021121903.png","hash":"17c9af7b63c7fcb050ed845b1894a6f7c84bf667","modified":1639878946018},{"_id":"source/images/react/2021122103.png","hash":"36f8125de36b1776ff2742b0e02b34522e7b5185","modified":1640089454933},{"_id":"source/images/react/2021122105.png","hash":"7fc8a5e3047873955c32df91f3d50850869b633d","modified":1640089454938},{"_id":"source/images/react/2021122110.png","hash":"6127b4f39e03b42f6eb344fe83a6672bed2d9aa9","modified":1640089454950},{"_id":"source/images/react/2021122112.png","hash":"3b55bfb0a53c98c759d7a721c300e0001b6909f7","modified":1640089454955},{"_id":"source/images/react/2021122115.png","hash":"225915bb5e648c388488ee2e60df53badfda6fd7","modified":1640089454958},{"_id":"source/images/react/2021122113.png","hash":"89ab33a48e1ba564962bda05fd250dc8922da4f9","modified":1640089454956},{"_id":"source/images/react/2021122114.png","hash":"c9fb140c0cddd2d8fe61567dd09649a54ad57ed5","modified":1640089454957},{"_id":"source/images/react/2021122116.png","hash":"b2065f8c4daaeb61f5804262296bf70069e462fb","modified":1640089454959},{"_id":"source/images/react/2021122118.png","hash":"dd31b41b779b7cdf4c8d27b6ca8ef63ebf14f662","modified":1640089454962},{"_id":"source/images/react/2021122117.png","hash":"9ea8f08b950572537512af6d97db206a011da9b6","modified":1640089454961},{"_id":"source/images/react/2021122119.png","hash":"2f22cd1d494f4827346ebca41b341a9c96dbfdd2","modified":1640089454963},{"_id":"source/images/react/2021122120.png","hash":"b65976f898e7afcd63a334dec0f795ae9ebabe33","modified":1640089454964},{"_id":"source/images/react/2021122121.png","hash":"3252e0b4d9a7d42fd1866da9fb34b9d9b44effb6","modified":1640089454965},{"_id":"source/images/react/2021122202.png","hash":"1224b6bdd202310e7efb30e7f4c72f0420790ddb","modified":1640144256335},{"_id":"source/images/react/2021122701.png","hash":"7cba0c24bd81de904c848afbe938782bb06590d4","modified":1640568579630},{"_id":"source/images/react/2021122703.png","hash":"e32bebba72ab06bfd557147fc04e5ae7f69a82eb","modified":1640571370997},{"_id":"source/images/react/2021122702.png","hash":"9edd0dbbaacbc9ef0bf0c80828c560e6803ffa4d","modified":1640568833443},{"_id":"source/images/react/2021122710.png","hash":"300e6aca39511bef984303d63dba1d51265299a9","modified":1640578968792},{"_id":"source/images/react/2021122711.png","hash":"7f88663c7cd84ad62c0d44dff1d8280843f12847","modified":1640579101489},{"_id":"source/images/react/2022011005.png","hash":"61e1d62b55880eaab861992e8b46650d9531038d","modified":1641797711096},{"_id":"source/images/react/2022011006.png","hash":"5a00b74f9641e01683f03f2c3e9cd0404b21e610","modified":1641797861043},{"_id":"source/images/react/2022011101.png","hash":"ed544b1ad5829dd2dd68339504186725dc720f77","modified":1641866786918},{"_id":"source/images/react/2022011103.png","hash":"f42a40f6a293c9184f79e7efad2bc0d28ecc8ca3","modified":1641891141656},{"_id":"source/images/react/2022011104.png","hash":"2d099e5ec20a9aedae47e8352d91b795448b26b5","modified":1641891153868},{"_id":"source/images/theme/loading2.png","hash":"2a7ceb0aab67f0c04934dee9643a4ff6d8fb60cc","modified":1639226141725},{"_id":"source/images/theme/loading.gif","hash":"db91090dd60098086993953f88c37a332eea70d7","modified":1637246461000},{"_id":"source/images/beauty/09.jpeg","hash":"9698f34a49ff23c3071d2ad7094054afe5451e74","modified":1639284658379},{"_id":"source/images/react/2021122001.png","hash":"b513570c9481c0b3a0ccdfb5107c69bb492ea720","modified":1639966657312},{"_id":"source/images/react/2021122002.png","hash":"17b937b519e9137dcf28bdfcc12bdfb070970346","modified":1639967133929},{"_id":"source/images/react/2021122003.png","hash":"c14de8c7ceb1b0116a14c905bcedc88c061adf57","modified":1639968848527},{"_id":"source/images/react/2021122104.png","hash":"03252eccef97d5c51ecc586d05b9b5e862a41246","modified":1640089454936},{"_id":"source/images/react/2021122106.png","hash":"d6c931a793721debde55900621e35b8920dccdbe","modified":1640089454940},{"_id":"source/images/react/2021122107.png","hash":"5bf508b3a2d694c655d9e8b5a686b12f6e620e42","modified":1640089454942},{"_id":"source/images/react/2021122108.png","hash":"5306785754e42bd9b5ca8db958cf18d92f5d0fc0","modified":1640089454945},{"_id":"source/images/react/2021122111.png","hash":"542f61c5b73077da968db61ee83d73006811db89","modified":1640089454953},{"_id":"source/images/react/2021122109.png","hash":"344a18d45ec1357f35f3aeae7641048f21ef3013","modified":1640089454948},{"_id":"source/images/react/2021122201.png","hash":"08370145908a50a88daf6c24e582cc222c7192d3","modified":1640136248075},{"_id":"source/images/react/2021122303.png","hash":"3b15052719f0b195eb4c1c0a8e7da3eda0e48daa","modified":1640222668826},{"_id":"source/images/react/2021122305.png","hash":"fc45b0b80eb3c1588db6a03f6f5b56649c69bb27","modified":1640227094976},{"_id":"source/images/react/2021122308.png","hash":"09d3a341122b912bd527657c14166b29c46cf765","modified":1640229495434},{"_id":"source/images/react/2021122310.png","hash":"50da6cea489045f975ebb7702f1d871389ebb068","modified":1640229907993},{"_id":"source/images/react/2021122705.png","hash":"b5b6185dcd98eac0d4fb117c3572216be4f80f0d","modified":1640575402707},{"_id":"source/images/react/2021122706.png","hash":"2cd5dddcd3c729061340efab15ca1f2102dfe98f","modified":1640577973870},{"_id":"source/images/react/2022011002.png","hash":"37e6d5ebd28fdd45f8dd726b8ce29af92b46db28","modified":1641797286077},{"_id":"source/images/react/2022011004.png","hash":"d16aaabc4174135914d05739bcaa824366402f69","modified":1641797594347},{"_id":"source/images/react/2022011007.png","hash":"6ed15d4331370bbf3e3cddae875a7fea656853c3","modified":1641799843921},{"_id":"source/images/react/2022011011.png","hash":"2772cc3efd02617973dc680ccc6c3d5a4b1842c1","modified":1641801754783},{"_id":"source/images/react/2022011102.png","hash":"602ea35dc2b1c42c66c7ed96c164b29fa73b8599","modified":1641890358715},{"_id":"source/images/react/2022011105.png","hash":"390370338af3e779b18fcccb519cd0f154a5214d","modified":1641892064595},{"_id":"source/images/react/2022012404.png","hash":"df593b8ba9cb3961c6db952f29b85ca179873a10","modified":1643010205205},{"_id":"source/images/theme/welcome-image3.jpg","hash":"f78bc3e3291d7031efc36ada72151f12172adf04","modified":1624513484000},{"_id":"source/images/2021121101.png","hash":"0b5e4870110a2586e7e9cc15d6329029594778ca","modified":1639232304532},{"_id":"source/images/beauty/03.jfif","hash":"b0d97a262d2f616e5a01522a59084930830aeaf0","modified":1639218142342},{"_id":"source/images/beauty/05.JPG","hash":"f88552e8efbaf639ddf9aa66831009ffd96aa1e9","modified":1607071422000},{"_id":"source/images/react/2021122004.png","hash":"9ad39cf682fcf4d084c5cfead0775d7ba4a4a8d2","modified":1639969016603},{"_id":"source/images/react/2021122203.png","hash":"44749087abbed4057a39d25b35812f42dfe2cecf","modified":1640145586530},{"_id":"source/images/react/2021122204.png","hash":"79a07aedef86c180ea4002f38c1eda77de35ac62","modified":1640162931621},{"_id":"source/images/react/2021122301.png","hash":"fa6a0a726fd6150a5473bf62c820b790a53f506e","modified":1640221616645},{"_id":"source/images/react/2021122302.png","hash":"a9fd41cf53ae6d54f5eb20dfa69b314c235c8b0e","modified":1640222219573},{"_id":"source/images/react/2021122306.png","hash":"3abdf87afe6c694f3c0e641fbb95b182a223ddc6","modified":1640227302240},{"_id":"source/images/react/2021122309.png","hash":"ccc63d87af89561d2d4c2d1a27246930600547b5","modified":1640229724091},{"_id":"source/images/react/2021122709.png","hash":"131011ffc2c28c00ec735fdb2651ba1b4f872816","modified":1640578791542},{"_id":"source/images/react/2022011001.png","hash":"9ef042f6f0161b89a64720ecb0fac21f3fcdee18","modified":1641797050470},{"_id":"source/images/react/2022011003.png","hash":"3e9afbdd77616ee82a23a2fd68758c80fdb13f02","modified":1641797510440},{"_id":"source/images/react/2022011009.png","hash":"4e330a852d69c7c69ec086cabab19c17f0b17003","modified":1641800746837},{"_id":"source/images/react/2022011008.png","hash":"cfe526a90a52405e536fdc8c4a58d18e28507b26","modified":1641800032639},{"_id":"source/images/react/2022011010.png","hash":"acab459fa29dd1cd916391292fd2fd0a58293f8c","modified":1641801138468},{"_id":"source/images/react/2022011013.png","hash":"62de23a32618b095a81873b23512e4430d359a79","modified":1641802241899},{"_id":"source/images/react/2022011012.png","hash":"3665cdc082013562e98891c33c530e94eb6cf75b","modified":1641801833821},{"_id":"source/images/react/2022011014.png","hash":"3f719fdc8dd1bbf9b75fc73b90930174b17a2c92","modified":1641803036454},{"_id":"source/images/react/2022011106.png","hash":"8604e4fcdca89c06f5196c7e5b854c3e025c3577","modified":1641892193979},{"_id":"source/images/react/2022012403.png","hash":"bab0ae3278a39860fd3b2dae41e9963121f9abf2","modified":1642989020226},{"_id":"source/images/react/2022012405.png","hash":"d4acba54f685ff6eb3ff9f9aaf347d3c7b9fc3d6","modified":1643010652363},{"_id":"source/images/theme/cloud.png","hash":"fdf44a91026ad999dca2f0a42213aabebd783c98","modified":1637246461000},{"_id":"source/images/theme/welcome-image7.jfif","hash":"b0d97a262d2f616e5a01522a59084930830aeaf0","modified":1639218142342},{"_id":"source/images/beauty/02.jfif","hash":"8b05cc38ecc004df4256186f5ffedbc5ca78858f","modified":1639218095683},{"_id":"source/images/beauty/15.png","hash":"46a2afaee7897957c6ba5bd1dfe5050334581c93","modified":1639355931603},{"_id":"source/images/react/2021122205.png","hash":"b680084b91f1b54360b64a2794f1e0ac38321835","modified":1640163514531},{"_id":"source/images/react/2021122307.png","hash":"384d946c3be96214eb8edb658d6de8e84844e843","modified":1640228811363},{"_id":"source/images/react/2021122311.png","hash":"76860cba9a6e4e831db1ba7c9e9923304fff2e71","modified":1640230064367},{"_id":"source/images/react/2021122312.png","hash":"4e3406605ded207763ec55090c4652ff4e293433","modified":1640231808575},{"_id":"source/images/react/2021122704.png","hash":"f834097142a3241bd483d3e7b65c34688350d9ad","modified":1640571487148},{"_id":"source/images/react/2021122707.png","hash":"17b0032f8d8541992bafb49fccb26c858106c4aa","modified":1640578138223},{"_id":"source/images/react/2021122708.png","hash":"d92cc56d45d0a35d3b9245db97a34f611165e649","modified":1640578294553},{"_id":"source/images/react/2022012402.png","hash":"1c8c83938246021882ea768edeae6d88716841da","modified":1642985911984},{"_id":"source/images/react/2022012401.png","hash":"febf8958eb1e4bac299496e9f93598daa21aee8f","modified":1642984598628},{"_id":"source/images/theme/welcome-image4.jpg","hash":"bc0d3ce8dede763fd9924da20c2ccb97e295025e","modified":1639213274224},{"_id":"source/images/theme/welcome-image6.jfif","hash":"8b05cc38ecc004df4256186f5ffedbc5ca78858f","modified":1639218095683},{"_id":"source/images/react/2021122102.png","hash":"ac19234cf513200d6e895f5709c33c2206089f1b","modified":1640089454931},{"_id":"source/images/theme/welcome-image.jpg","hash":"ba0968002f3ac6d41bb50ba9ba62309ff8e62dda","modified":1639212660336},{"_id":"source/images/theme/welcome-image2.jpg","hash":"9e3fb1c2c7cec5fdadec0b87fd0a6f593ada60a3","modified":1624513186000},{"_id":"source/images/2021121201.jpg","hash":"981dcd61b7f1a408637661b859c1a5869b25ce53","modified":1639210074807},{"_id":"source/images/book/01.jpg","hash":"0714b0d4afa0e67ac861ed02c85a15a1acb9a432","modified":1639287181785},{"_id":"source/images/react/2021122005.png","hash":"673fa65445567403ef48b67f99824620947ec3a2","modified":1639990704351},{"_id":"source/images/beauty/12.png","hash":"311b9469d62b76061a999d01f1b3dac87c86a32d","modified":1639355863885},{"_id":"source/images/react/2021122006.png","hash":"4d8c01d70e325a700391d4fced32f2831e83103c","modified":1640001003554},{"_id":"source/images/react/2021122304.png","hash":"fdd82ce66e35c44643c0422167c339fded88ab4d","modified":1640223586000},{"_id":"source/images/2021121702.png","hash":"d87b66f0f64365a5202d9ea3f4653b4e7beae094","modified":1639729848387},{"_id":"themes/zhaoo/.gitignore","hash":"7d65523f2a5afb69d76824dd1dfa62a34faa3197","modified":1637246461000},{"_id":"themes/zhaoo/LICENSE","hash":"74f4b502cb5e62d3c947bc4fd16bed695d8bf65b","modified":1637246461000},{"_id":"themes/zhaoo/README_EN.md","hash":"daa353598985e4184d6055df229665985001e672","modified":1637246461000},{"_id":"themes/zhaoo/package.json","hash":"e116101e90a6eefdbbf423f7a4d0edd72221cf17","modified":1637246461000},{"_id":"themes/zhaoo/_config.yml","hash":"111942b97e3dc374c894af365497420bd01ec257","modified":1639284012515},{"_id":"themes/zhaoo/languages/default.yml","hash":"1b2b75ca9ff3bfeddb596239889b584cdfcecc32","modified":1637246461000},{"_id":"themes/zhaoo/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1637246461000},{"_id":"themes/zhaoo/README.md","hash":"31f0def1c46e5dac5a77ebd77dca0460de3ed2f8","modified":1637246461000},{"_id":"themes/zhaoo/languages/it.yml","hash":"6ae71000ed039f56572143ffe90da17b95d1a66f","modified":1637246461000},{"_id":"themes/zhaoo/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1637246461000},{"_id":"themes/zhaoo/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1637246461000},{"_id":"themes/zhaoo/languages/zh-CN.yml","hash":"ccbba6315760755926f5abfe1b98c225a6650581","modified":1637246461000},{"_id":"themes/zhaoo/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1637246461000},{"_id":"themes/zhaoo/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1637246461000},{"_id":"themes/zhaoo/layout/categories.ejs","hash":"e7ed9fa6a6abd02af212a8bf04fc600d008f4abd","modified":1637246461000},{"_id":"themes/zhaoo/layout/archive.ejs","hash":"438069ea52e71a9fd8c96ff58007ec6c91e352a7","modified":1637246461000},{"_id":"themes/zhaoo/layout/category.ejs","hash":"ca4af3683e3d3daf9282c76b0749c2b1a89399ac","modified":1637246461000},{"_id":"themes/zhaoo/layout/galleries.ejs","hash":"65f1bad4c0410c92087f72e2d9298f30f23e4d18","modified":1637246461000},{"_id":"themes/zhaoo/layout/gallery.ejs","hash":"a379c8607ae2fdd450198e437ba8125ac1435654","modified":1637246461000},{"_id":"themes/zhaoo/layout/layout.ejs","hash":"4b559e7859d72d3e962b18198cbb30ec126c84b5","modified":1637246461000},{"_id":"themes/zhaoo/layout/index.ejs","hash":"0e6282054062e1391be29bb473487a808f13828c","modified":1637246461000},{"_id":"themes/zhaoo/layout/post.ejs","hash":"747038a8b2d33bce35b2f68d3e50bdfa28c4f36c","modified":1637246461000},{"_id":"themes/zhaoo/layout/pure.ejs","hash":"1ffc46cb8d2a976a329bd6e8292ca8114467f833","modified":1637246461000},{"_id":"themes/zhaoo/layout/tags.ejs","hash":"937f6400f7b47baa4aca025786dcd67151355cc1","modified":1637246461000},{"_id":"themes/zhaoo/layout/tag.ejs","hash":"91a8ffd62866427d6e04884fc4fc806b8c261770","modified":1637246461000},{"_id":"themes/zhaoo/scripts/caption.js","hash":"651928cc462943be90036c33262d3d25aa3e7ea0","modified":1637246461000},{"_id":"themes/zhaoo/scripts/carrier.js","hash":"10c3cde9ec17e1ced6ad871e7f5af409cbc51e6e","modified":1637246461000},{"_id":"themes/zhaoo/scripts/entry.js","hash":"c0c69f1c184c7a2e29dbaaa45a93b8948c241932","modified":1637246461000},{"_id":"themes/zhaoo/scripts/lazyload.js","hash":"ccf0c3d84fc2edf085c43e204410cf4d3c6b2baa","modified":1637246461000},{"_id":"themes/zhaoo/scripts/merge-config.js","hash":"35aac2f51a883d4d7bbe2b3b273b47f4db670952","modified":1637246461000},{"_id":"themes/zhaoo/scripts/post-image.js","hash":"82f5d9d5d9fe9d7de886d87fe20cea360d0df8d9","modified":1637246461000},{"_id":"themes/zhaoo/scripts/title.js","hash":"b62b21cd09717564ef883c901deb5451b3000dbd","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/head.ejs","hash":"b81bbde79d21adaef2023e9e1f0807c9ffb5b59b","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/script.ejs","hash":"b3d7c42d6ee99dfeed081cb5f788c58263c1eff0","modified":1637246461000},{"_id":"themes/zhaoo/source/css/style.styl","hash":"91077c8a71c5827bdc5875309e3837e48a290ffd","modified":1637246461000},{"_id":"themes/zhaoo/source/_data/galleries.json","hash":"3214779942d7a54967b977f505286a0d454d7100","modified":1639274387960},{"_id":"themes/zhaoo/source/js/color-mode.js","hash":"33cd307624e32035ea4544c9a6a4676ef9f70beb","modified":1637246461000},{"_id":"themes/zhaoo/source/js/script.js","hash":"a36c745bdb1fcb58bcb4774159bba7653a0499ba","modified":1637246461000},{"_id":"themes/zhaoo/source/js/utils.js","hash":"359461693c5a1c8f9fb159c2dfb78051d0b351e1","modified":1637246461000},{"_id":"themes/zhaoo/_example/source/_data/local_images.json","hash":"9a5ba1814709361cd141121e803f8953ef32d7fb","modified":1637246461000},{"_id":"themes/zhaoo/_example/source/_data/galleries.json","hash":"2b8bd59e5dbda5512b6a7458b2d3936e7ae23c5a","modified":1637246461000},{"_id":"themes/zhaoo/_example/source/_posts/hexo-theme-zhaoo-doc.md","hash":"6855f6440f4cdac0540afbd4900f9ab2175a0d5a","modified":1637246461000},{"_id":"themes/zhaoo/_example/source/categories/index.md","hash":"108d69d9b70c1b66531b8de5e89d809f9fad26a6","modified":1637246461000},{"_id":"themes/zhaoo/_example/source/_posts/hexo-theme-zhaoo.md","hash":"b52814eaf58dca925001beb2f911bb5e377e69a9","modified":1637246461000},{"_id":"themes/zhaoo/_example/source/about/index.md","hash":"e9cf4e1b773da337befbacca42eeffc5f76e2ad5","modified":1637246461000},{"_id":"themes/zhaoo/_example/source/galleries/index.md","hash":"83876d965236601bc871f6619f7d1f6e1357c945","modified":1637246461000},{"_id":"themes/zhaoo/_example/source/tags/index.md","hash":"176a9920c6ed25f1f2d12940b7733da45b0966d4","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/comments/changyan.ejs","hash":"d762068b8c036ae7e83a2df9d36cd43dca46d5a4","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/comments/gitalk.ejs","hash":"8748a63003dc954df1b0a47f3d45ff191e714f3d","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/components/footer.ejs","hash":"59dab61fa47add0fa174e49507659eb2e18d4de8","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/comments/valine.ejs","hash":"8f6ce8eb608f0c7c9ce482fd1f8aad7efa175f8c","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/components/fab.ejs","hash":"f6c0ed0c4a5b3a435605c7e956da143e66993e00","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/components/header.ejs","hash":"62ae2fac8dc5d6cba29ebe777b9d06e6d954a45b","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/components/loading.ejs","hash":"1e1d68be27d3120864daf2d7305ac7a62bca1d84","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/components/menu.ejs","hash":"c4106f65b24355895399ebae328bc8bb8f622d6a","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/components/paginator.ejs","hash":"174723904a7a0b6088c411233266a5d35b8affe7","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/components/scrollbar.ejs","hash":"dabbb31935dd1e67bf735665b35d41db8eee67c6","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/components/search.ejs","hash":"3e2f18d6b785cee85667655f1d27e9858447a3d8","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/components/navbar.ejs","hash":"d6886ca04c922bd32068ae3540a75463bdf42a99","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/index/post.ejs","hash":"4de44a27558cf1058a5fe2bb65fb2e27f593af76","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/index/item.ejs","hash":"af1e72bc4e9216783e924c94b626ed32dad7616c","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/index/preview.ejs","hash":"fc78346e7a00d1584fe8b0dc1b229a481c7a056a","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/plugins/seo.ejs","hash":"7aa361277db60df8195b651fdfbc95ec5f5a4daa","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/plugins/analytics.ejs","hash":"367d6fb80be4ce480c78bf63f2fbd2d28dedd0a3","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/plugins/daovoice.ejs","hash":"f49d99f040979c44b7abad5136786c2535a8db46","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/post/comments.ejs","hash":"505e0724ccf8aa467e219e9f1fc86ca62479ec18","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/plugins/leancloud.ejs","hash":"535708a3276ed989f63321e13d889863d1bd6d8f","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/post/article.ejs","hash":"21cb86efd40a44f9c63c496cfaa7c3b973d29254","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/post/copyright.ejs","hash":"3c16a6499867c7fb773505ea2d877b3bbfdf81b0","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/post/donate.ejs","hash":"e64e1a6e537ea56888baf9be98324baa9c39b49f","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/post/nav.ejs","hash":"9a59b60fdba3100d91c9f527bae75ac0e9cb8bd5","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/post/head.ejs","hash":"9ab6fe00a2b1a03cfcbe3125cf91c52908afb528","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/post/tag.ejs","hash":"6b94a9ccb03624e6ce7cbbc827e45bc4bfca8a4a","modified":1637246461000},{"_id":"themes/zhaoo/layout/_partial/post/toc.ejs","hash":"bbb947334a5275cee6b834b5c216ddc6699d68c7","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_base/color-mode.styl","hash":"be52bfac7dd56ce6c76039ea1522cc30c9e815a2","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_base/reset.styl","hash":"be64ad3469e427e9b7000e763034fb94984a8eeb","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_base/zui.styl","hash":"84c080d668427a3a64b8c930333c714783730414","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_components/common.styl","hash":"dc725d10a7a161654e498875d3a507ffe18dba7e","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_components/footer.styl","hash":"06a0f3acc8947842889e06986025169063c72eac","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_components/fab.styl","hash":"184933f6ee13a7a7f40b2592fc35ba0a9c2a5825","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_components/header.styl","hash":"d9286ca8729e35d3b29ca6cb27ec2ccae562c040","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_components/menu.styl","hash":"46f897c3cb3fea7c409d179cdcca7a63dd82bcd4","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_components/paginator.styl","hash":"bafe156fce40a01f2fa38bc2bbb38dc92239cabd","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_components/navbar.styl","hash":"4e7fbb1c5fd25b280d88a70eec465de8ac0a4ab4","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_components/preview.styl","hash":"b5427785cfee20fcc400e55e964dab3312584726","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_components/scrollbar.styl","hash":"aca6a15c54cf34ddbf99075d0c13d458cfc11828","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_components/search.styl","hash":"e9f96afd0947d83deda8cf6bfb938125a203b3d3","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_pages/pages.styl","hash":"c4e4af922ee697c44295ab1072e350d4587b120f","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_variables/variables.styl","hash":"e4fd51e16ba970994ebcc0b6dacdd82d22dbe6d7","modified":1637246461000},{"_id":"themes/zhaoo/source/images/icons/apple-touch-icon.png","hash":"c1d16404a57db24e985204e7b2b97fa45d5fea0b","modified":1637246461000},{"_id":"themes/zhaoo/source/images/icons/favicon-128x128.png","hash":"c92b96941e92baf607a75887b3e187c9517ae807","modified":1637246461000},{"_id":"themes/zhaoo/source/images/icons/favicon-144x144.png","hash":"e54f440ff564f1235f9c399e2cd435dd502ceb84","modified":1637246461000},{"_id":"themes/zhaoo/source/images/icons/favicon-16x16.png","hash":"86cc7a07ccf09deff3de7b0ef2f82daa282a8b8e","modified":1637246461000},{"_id":"themes/zhaoo/source/images/icons/favicon-32x32.png","hash":"7b095984bd7d07e10fa9b0df8347a933eba8537c","modified":1637246461000},{"_id":"themes/zhaoo/source/images/icons/logo_128.png","hash":"9cc9959f00728a3ee3a9f5d7112471403b797c58","modified":1639210539151},{"_id":"themes/zhaoo/source/images/icons/logo_16.png","hash":"d66e50faf20249a908a584e2eafc9b4dc39105b3","modified":1639210576188},{"_id":"themes/zhaoo/source/images/icons/logo_32.png","hash":"27d4611d634335f6a45457fd1d65f409cb60374b","modified":1639210560272},{"_id":"themes/zhaoo/source/images/icons/logo_144.png","hash":"77698e3999a963c06a975df3dd5eeb388f10f205","modified":1639210521051},{"_id":"themes/zhaoo/source/images/icons/zhaoo-logo.png","hash":"50f9f5de4207847bba6aecc4c21d21d79f0001fb","modified":1637246461000},{"_id":"themes/zhaoo/source/images/theme/loading.gif","hash":"db91090dd60098086993953f88c37a332eea70d7","modified":1637246461000},{"_id":"themes/zhaoo/source/images/theme/loading2.png","hash":"2a7ceb0aab67f0c04934dee9643a4ff6d8fb60cc","modified":1639226141725},{"_id":"themes/zhaoo/source/lib/fancybox/fancybox.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1637246461000},{"_id":"themes/zhaoo/source/lib/gitalk/.DS_Store","hash":"d0c74f5f99535ad14eaec93484abb4ff8dbca277","modified":1637246461000},{"_id":"themes/zhaoo/source/lib/gitalk/gitalk.css","hash":"99f6725b386bdb0f52d15b0dd7877eaf1ad4c918","modified":1637246461000},{"_id":"themes/zhaoo/source/lib/highlight/a11y-dark.css","hash":"9f0c935216015dd88251a6c366bdd00abfe65982","modified":1637246461000},{"_id":"themes/zhaoo/source/lib/highlight/highlight.js","hash":"a52ef27b8a21963326b05ef06f6ee104b8b94e7e","modified":1637246461000},{"_id":"themes/zhaoo/source/lib/lazyload/lazyload.js","hash":"338318e930487b2791a7bcf53ad4601630cc41e2","modified":1637246461000},{"_id":"themes/zhaoo/source/lib/pjax/pjax.js","hash":"0ced78e5c97127948f5bfbfbb80c4fce5c0f671e","modified":1637246461000},{"_id":"themes/zhaoo/_example/source/galleries/colorful/index.md","hash":"d825ba0a41ff7ef253356a14bac6bfaf02135435","modified":1637246461000},{"_id":"themes/zhaoo/_example/source/galleries/深圳日记/index.md","hash":"ed9640b8192a9a9ce4771a33a8c2671d408fbb80","modified":1637246461000},{"_id":"themes/zhaoo/_example/source/galleries/记事/index.md","hash":"487e5b5267f2a83fd35ce179a57e3d54e8e2b870","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_pages/_category/categories.styl","hash":"66f983e15ebca02d95342d00234981fa6c04825d","modified":1637246461000},{"_id":"themes/zhaoo/source/lib/qrcode/qrcode.js","hash":"f424bd339870510d1160d1c5da5d698aedbb452e","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_pages/_archive/archive.styl","hash":"9a680e104a6418997e093303bb93f9097553d049","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_pages/_gallery/galleries.styl","hash":"4d520006b28d419732314eeefe13201562089a9a","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_pages/_tag/tags.styl","hash":"0ca5f9f71dab35247cf3b1318b2995a7e9058426","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_pages/_post/toc.styl","hash":"fc0c97ec7d9e98b79493cdd26452f4bb5defab08","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_pages/_gallery/gallery.styl","hash":"4f1975a81247e226d63c50b9500278d969e6257a","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_pages/_post/article.styl","hash":"1a155390dc8f332dd324a7a0b057055d9d63ff33","modified":1637246461000},{"_id":"themes/zhaoo/source/css/_pages/_index/index.styl","hash":"3a69a450ec352b480a691521f85011659d136487","modified":1637246461000},{"_id":"source/images/2021121405.png","hash":"c08945480c6bbeee6127b23edcdbd17cab2c7e1b","modified":1639497922990},{"_id":"source/images/beauty/08.PNG","hash":"f38e3ea6d62e49f68f4d56b3c57e68bc8e19ac2c","modified":1619446890000},{"_id":"source/images/beauty/16.png","hash":"bcbe7d9f8992722856ca076bd2952724750db49a","modified":1639355942214},{"_id":"source/images/react/2021122101.png","hash":"b583bbbaf1a086e4a712a53f566c6a62e6ae22db","modified":1640089454925},{"_id":"themes/zhaoo/source/images/icons/logo_180.png","hash":"458f67b1b8b040cb204eb7336a477dae63610f32","modified":1639210500712},{"_id":"themes/zhaoo/source/images/theme/welcome-image3.jpg","hash":"f78bc3e3291d7031efc36ada72151f12172adf04","modified":1624513484000},{"_id":"themes/zhaoo/source/lib/fancybox/fancybox.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1637246461000},{"_id":"themes/zhaoo/source/lib/jquery/jquery.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1637246461000},{"_id":"source/images/2021121402.png","hash":"5b035ece83096bff938f295e9ed699b781a8ac4e","modified":1639497875950},{"_id":"source/images/2021122302.png","hash":"0372d04456d6b0274b3d3d9020c25c3333313f4c","modified":1640272748583},{"_id":"themes/zhaoo/source/images/theme/cloud.png","hash":"fdf44a91026ad999dca2f0a42213aabebd783c98","modified":1637246461000},{"_id":"themes/zhaoo/source/images/theme/welcome-image7.jfif","hash":"b0d97a262d2f616e5a01522a59084930830aeaf0","modified":1639218142342},{"_id":"themes/zhaoo/source/lib/gitalk/gitalk.js","hash":"266500948447c95aeea95ef6760f192afc96fd5e","modified":1637246461000},{"_id":"source/images/2021121302.png","hash":"420900c34782a66d4e5b3894b62bbe79b09f98b2","modified":1639406837481},{"_id":"themes/zhaoo/source/images/theme/welcome-image4.jpg","hash":"bc0d3ce8dede763fd9924da20c2ccb97e295025e","modified":1639213274224},{"_id":"themes/zhaoo/source/images/theme/welcome-image6.jfif","hash":"8b05cc38ecc004df4256186f5ffedbc5ca78858f","modified":1639218095683},{"_id":"source/images/2021122201.png","hash":"48d6a3e617cd123789cc0053b5662abf70d85376","modified":1640188787334},{"_id":"themes/zhaoo/screenshots/menu.png","hash":"0f4220734a52953636a5273d64a03c8b01ec6098","modified":1637246461000},{"_id":"themes/zhaoo/source/images/theme/welcome-image2.jpg","hash":"9e3fb1c2c7cec5fdadec0b87fd0a6f593ada60a3","modified":1624513186000},{"_id":"themes/zhaoo/source/lib/lottie/lottie.js","hash":"35a3798d0f059f95c5d790eec56798ac10e07319","modified":1637246461000},{"_id":"source/images/Alex/10.png","hash":"f17bfaf547ade13e9d79f913302acce4f414e12a","modified":1640008516779},{"_id":"source/images/2021122301.png","hash":"a7723673f2ee1e72190ba4bb38ad03375b64b6e2","modified":1640270871903},{"_id":"source/images/beauty/07.PNG","hash":"56d81ec6b1f2d8a5c8f14f14b3da22edd57abba1","modified":1619446922000},{"_id":"source/images/beauty/13.png","hash":"fc449566995e195f12074f9df1ba0d5942b2caf6","modified":1639355909008},{"_id":"themes/zhaoo/source/images/icons/logo_500.png","hash":"4e371a74fc6eb31b8c02fcdc8f6005c2e32c0ee3","modified":1639210477596},{"_id":"source/images/Alex/04.png","hash":"effbceda0a96d811b8a6c35562d5860ed1aecac6","modified":1640008065452},{"_id":"source/images/Alex/11.png","hash":"f0eecf899658c5c5c2254be076be9dd30a69c976","modified":1640008529709},{"_id":"themes/zhaoo/screenshots/galleries.png","hash":"8ba5a26c7932d5ef456cc799bbc00c5f468e54cc","modified":1637246461000},{"_id":"source/images/beauty/14.png","hash":"3e6b3b361ad95ad53e58ab8d03447a67a83cbf55","modified":1639355920666},{"_id":"source/images/2021121401.png","hash":"808e3955b595445d717ac91d303b9ef40d3b19b8","modified":1639497862325},{"_id":"source/images/beauty/11.png","hash":"81cdae8288deec6082d7f30a1a15f8b1f75703b0","modified":1639355806548},{"_id":"themes/zhaoo/source/lib/daovoice/daovoice.js","hash":"180375e6fc5a5a71810b5e83109c0ce1533bbc5a","modified":1637246461000},{"_id":"source/images/2021121404.png","hash":"748232ced31b4f7aca6ef88fc4f763cd0f3b4bd7","modified":1639497908739},{"_id":"source/images/2021122202.png","hash":"35fa3a7c5ae820609e5faee3c5ac743a154ba2dd","modified":1640188817563},{"_id":"source/images/Alex/05.png","hash":"c017d8bd70e6ed6bbf7b549ab9b9d252752211c9","modified":1640008080733},{"_id":"source/images/Alex/03.png","hash":"ef1f9e6b798550e52c5c6c2b4380408a0eef9950","modified":1640008041787},{"_id":"source/images/2021122501.png","hash":"b10aaf34fbce85b1e80a162f1444a8031526a0a8","modified":1640413723505},{"_id":"source/images/2022011201.png","hash":"e027996a464e7a8b19bf3906eb40666cd715df54","modified":1641975962103},{"_id":"source/images/2021121403.png","hash":"6665590523cd811af5de89ec1ee403a344497969","modified":1639497891310},{"_id":"source/images/2021122701.png","hash":"6058462269e8891e3e6a4e32e1393a8c97e8ec1a","modified":1640613742321},{"_id":"source/images/Alex/09.png","hash":"d15ac5815557c32a63c9b9360132677802692dec","modified":1640008503638},{"_id":"themes/zhaoo/screenshots/article.png","hash":"74706d28c479a20f77c1bd4454879cabf8784ca6","modified":1637246461000},{"_id":"themes/zhaoo/screenshots/index.png","hash":"a95df16106c813b92f14071bac3d38bc53a1bc00","modified":1637246461000},{"_id":"source/images/2021121601.png","hash":"fa9275f7b54baaaedaae8740cd182e36eac768e5","modified":1639647703521},{"_id":"source/images/Alex/07.png","hash":"733d0cad783640ec9d7c7d00ef2b6f366322ae25","modified":1640008479859},{"_id":"source/images/Alex/08.png","hash":"7d3e95ab6fa2f9c37082833e6c99777a91ff1cc0","modified":1640008491356},{"_id":"themes/zhaoo/screenshots/preview.png","hash":"2b4271a275b9ff8318d00ab04504a109ec931fe7","modified":1637246461000},{"_id":"source/images/2021121301.png","hash":"cb99b87bc2f7ac6a5d074b74a7a28f9a9fe9f311","modified":1639406660824},{"_id":"source/images/Alex/02.png","hash":"c4e2ac26d0b978e9e53ff1cf69d96aea27844edd","modified":1640007963006},{"_id":"source/images/beauty/10.png","hash":"2e9fddc4cdc8bd8986fb555f09dec00fc1999519","modified":1635403213261},{"_id":"source/images/Alex/06.png","hash":"f790cf723ccb3113f09ffde3cc7271ee55eb0c53","modified":1640008460412},{"_id":"source/images/2021121701.png","hash":"aa0936864c7921c3f99ef578cb6efeee336effbb","modified":1639729301938},{"_id":"source/images/2021121802.png","hash":"150a7f93359e9d0e67dbcd0e2c7ad4bbfb34f29b","modified":1640007573003},{"_id":"source/images/Alex/01.png","hash":"0d2b4bfaa96c1551e45d6693e0cfe4a06562c90b","modified":1640007920930},{"_id":"themes/zhaoo/source/images/theme/welcome-image8.png","hash":"fd918cf2341acc8d5e262bc93acdffac8111e12a","modified":1639283909452},{"_id":"source/images/2021121801.png","hash":"5e6cb3c02f87fff552af010808f623112c88b8b1","modified":1639787111270},{"_id":"source/images/beauty/01.png","hash":"30cf9777ffb1cfaf2089d95935337d432616c25e","modified":1639234875165},{"_id":"source/images/theme/welcome-image.png","hash":"30cf9777ffb1cfaf2089d95935337d432616c25e","modified":1639234875165},{"_id":"themes/zhaoo/source/images/theme/welcome-image.png","hash":"30cf9777ffb1cfaf2089d95935337d432616c25e","modified":1639234875165},{"_id":"source/images/2021121202.png","hash":"3cbcffd7976217b259ae51b6ac5bb593dcf1661c","modified":1639325609876},{"_id":"source/images/theme/welcome-image5.png","hash":"8aca765eb61b322c501447f667a5455015d2edbe","modified":1639217995064},{"_id":"source/images/theme/post-image.png","hash":"4da57f81fa5424b4b4dda2f50e36d6af9da37268","modified":1632790037568},{"_id":"themes/zhaoo/source/images/theme/welcome-image5.png","hash":"8aca765eb61b322c501447f667a5455015d2edbe","modified":1639217995064},{"_id":"themes/zhaoo/source/images/theme/post-image.png","hash":"4da57f81fa5424b4b4dda2f50e36d6af9da37268","modified":1632790037568}],"Category":[{"name":"React","_id":"cl16bbh0s00066wtv2vkq69a0"},{"name":"计算机基础复习","_id":"cl16bbh1a000k6wtv52dhaqch"},{"name":"浏览器","_id":"cl16bbh1g000s6wtve8u87683"},{"name":"日记","_id":"cl16bbh1m000z6wtvfj1hfcc9"},{"name":"博客","_id":"cl16bbh2d001r6wtvdwg86r89"}],"Data":[{"_id":"galleries","data":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}],"Page":[{"title":"关于我","type":"about","layout":"about","image":"/images/2021121201.jpg","toc":false,"copyright":false,"_content":"\n\n\n###### 关于我\n\n一个吭哧吭哧码代码的内向星球人。\n\n一个中土大陆社恐土著，伪托尔金小说爱好者。\n\n平时的兴趣很少，我会努力扩大自己的兴趣爱好的！\n\n主要还是看书和看电影\n\n------\n\n今年上半年学了两个月的钢琴，希望以后能买一架钢琴（二手的也行），对钢琴的向往来自高中读三毛，三毛的钢琴上摆着一张蒙娜丽莎的复印照，她总是痴迷地盯着她看。这样一副情景让我对钢琴、蒙娜丽莎都产生了迷离的美感和向往，总有一天我这个土著也能够欣赏艺术的！\n\n此时应该献上一张三毛的照片\n\n![](/images/beauty/09.JPEG)\n\n最喜欢的电影是《时时刻刻》，主要是痴迷里面的伍尔夫。最喜欢的书是费兰特的《那不勒斯四部曲》，主要还是痴迷莉拉。最喜欢的播客是《痴人之爱》，喜欢这个名字以及男女主播的声音。对于音乐，我的感受力好薄弱，真羡慕那些享受音乐的人。\n\n###### 关于这个博客\n\n这个博客的标题没有任何意义，我是一个想名字废人，就像我自己的昵称一样。\n\n似乎没什么可说的了，那就这样。","source":"about/index.md","raw":"---\ntitle: 关于我\ntype: \"about\"\nlayout: \"about\"\nimage: /images/2021121201.jpg\ntoc: false\ncopyright: false\n---\n\n\n\n###### 关于我\n\n一个吭哧吭哧码代码的内向星球人。\n\n一个中土大陆社恐土著，伪托尔金小说爱好者。\n\n平时的兴趣很少，我会努力扩大自己的兴趣爱好的！\n\n主要还是看书和看电影\n\n------\n\n今年上半年学了两个月的钢琴，希望以后能买一架钢琴（二手的也行），对钢琴的向往来自高中读三毛，三毛的钢琴上摆着一张蒙娜丽莎的复印照，她总是痴迷地盯着她看。这样一副情景让我对钢琴、蒙娜丽莎都产生了迷离的美感和向往，总有一天我这个土著也能够欣赏艺术的！\n\n此时应该献上一张三毛的照片\n\n![](/images/beauty/09.JPEG)\n\n最喜欢的电影是《时时刻刻》，主要是痴迷里面的伍尔夫。最喜欢的书是费兰特的《那不勒斯四部曲》，主要还是痴迷莉拉。最喜欢的播客是《痴人之爱》，喜欢这个名字以及男女主播的声音。对于音乐，我的感受力好薄弱，真羡慕那些享受音乐的人。\n\n###### 关于这个博客\n\n这个博客的标题没有任何意义，我是一个想名字废人，就像我自己的昵称一样。\n\n似乎没什么可说的了，那就这样。","date":"2021-12-13T00:32:47.651Z","updated":"2021-12-13T00:32:47.651Z","path":"about/index.html","comments":1,"_id":"cl16bbh0e00006wtv5lmu59xa","content":"<h6 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h6><p>一个吭哧吭哧码代码的内向星球人。</p>\n<p>一个中土大陆社恐土著，伪托尔金小说爱好者。</p>\n<p>平时的兴趣很少，我会努力扩大自己的兴趣爱好的！</p>\n<p>主要还是看书和看电影</p>\n<hr>\n<p>今年上半年学了两个月的钢琴，希望以后能买一架钢琴（二手的也行），对钢琴的向往来自高中读三毛，三毛的钢琴上摆着一张蒙娜丽莎的复印照，她总是痴迷地盯着她看。这样一副情景让我对钢琴、蒙娜丽莎都产生了迷离的美感和向往，总有一天我这个土著也能够欣赏艺术的！</p>\n<p>此时应该献上一张三毛的照片</p>\n<p><img src=\"/images/beauty/09.JPEG\"></p>\n<p>最喜欢的电影是《时时刻刻》，主要是痴迷里面的伍尔夫。最喜欢的书是费兰特的《那不勒斯四部曲》，主要还是痴迷莉拉。最喜欢的播客是《痴人之爱》，喜欢这个名字以及男女主播的声音。对于音乐，我的感受力好薄弱，真羡慕那些享受音乐的人。</p>\n<h6 id=\"关于这个博客\"><a href=\"#关于这个博客\" class=\"headerlink\" title=\"关于这个博客\"></a>关于这个博客</h6><p>这个博客的标题没有任何意义，我是一个想名字废人，就像我自己的昵称一样。</p>\n<p>似乎没什么可说的了，那就这样。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<h6 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h6><p>一个吭哧吭哧码代码的内向星球人。</p>\n<p>一个中土大陆社恐土著，伪托尔金小说爱好者。</p>\n<p>平时的兴趣很少，我会努力扩大自己的兴趣爱好的！</p>\n<p>主要还是看书和看电影</p>\n<hr>\n<p>今年上半年学了两个月的钢琴，希望以后能买一架钢琴（二手的也行），对钢琴的向往来自高中读三毛，三毛的钢琴上摆着一张蒙娜丽莎的复印照，她总是痴迷地盯着她看。这样一副情景让我对钢琴、蒙娜丽莎都产生了迷离的美感和向往，总有一天我这个土著也能够欣赏艺术的！</p>\n<p>此时应该献上一张三毛的照片</p>\n<p><img src=\"/images/beauty/09.JPEG\"></p>\n<p>最喜欢的电影是《时时刻刻》，主要是痴迷里面的伍尔夫。最喜欢的书是费兰特的《那不勒斯四部曲》，主要还是痴迷莉拉。最喜欢的播客是《痴人之爱》，喜欢这个名字以及男女主播的声音。对于音乐，我的感受力好薄弱，真羡慕那些享受音乐的人。</p>\n<h6 id=\"关于这个博客\"><a href=\"#关于这个博客\" class=\"headerlink\" title=\"关于这个博客\"></a>关于这个博客</h6><p>这个博客的标题没有任何意义，我是一个想名字废人，就像我自己的昵称一样。</p>\n<p>似乎没什么可说的了，那就这样。</p>\n"},{"title":"分类","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ntype: \"categories\"\nlayout: \"categories\"\n---","date":"2021-12-12T02:09:08.833Z","updated":"2021-12-12T02:09:08.833Z","path":"categories/index.html","comments":1,"_id":"cl16bbh0n00026wtvg6oycwzd","content":"","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":""},{"title":"相册","layout":"galleries","_content":"","source":"galleries/index.md","raw":"---\ntitle: 相册\nlayout: \"galleries\"\n---","date":"2021-12-12T01:49:49.465Z","updated":"2021-12-12T01:49:49.465Z","path":"galleries/index.html","comments":1,"_id":"cl16bbh0q00046wtv837ne1ig","content":"","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":""},{"title":"标签","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ntype: \"tags\"\nlayout: \"tags\"\n---","date":"2021-12-12T02:06:08.635Z","updated":"2021-12-12T02:06:08.635Z","path":"tags/index.html","comments":1,"_id":"cl16bbh0v00086wtv702f4835","content":"","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":""},{"title":"Alex","layout":"gallery","_content":"","source":"galleries/Alex/index.md","raw":"---\ntitle: Alex\nlayout: \"gallery\"\n---","date":"2021-12-20T13:58:55.335Z","updated":"2021-12-20T13:58:55.335Z","path":"galleries/Alex/index.html","comments":1,"_id":"cl16bbh0x000a6wtv0xw336nx","content":"","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":""},{"title":"书摘","layout":"gallery","_content":"","source":"galleries/书摘/index.md","raw":"---\ntitle: 书摘\nlayout: \"gallery\"\n---","date":"2021-12-12T05:34:18.273Z","updated":"2021-12-12T05:34:18.273Z","path":"galleries/书摘/index.html","comments":1,"_id":"cl16bbh0z000c6wtv4xeqagre","content":"","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":""},{"title":"她们","layout":"gallery","_content":"","source":"galleries/她们/index.md","raw":"---\ntitle: 她们\nlayout: \"gallery\"\n---","date":"2021-12-12T02:04:45.735Z","updated":"2021-12-12T02:04:45.735Z","path":"galleries/她们/index.html","comments":1,"_id":"cl16bbh15000g6wtv0egbdhh9","content":"","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":""}],"Post":[{"_content":"HTTP1\n\n\n\nHTTP1的演进过程\n\n\n\n1991年提出了HTTP/0.9,它也是基于TCP协议的，所以一个HTTP/0.9请求在TCP连接成功后从客服端向服务端发送一个GET请求行信息，服务端收到请求后会采用ASCII字符流返回对应的HTML文件。文件传输完成后就断开连接。\n\n\n\nHTTP/0.9有三个特点\n\n1.只有请求行，没有请求头和请求体。\n\n2.服务器返回的信息没有响应头。\n\n3.服务端返回的文件内容是ASCII字符流。因为传输的只有HTML格式的文件，其用ASCII字节码传输最合适。\n\nHTTP/0.9只适合传输体积小的HTML文件。最开始的HTTP只需要满足学术上交流的基本需求而可以用HTTP/0.9来满足，随着新兴网络的兴起，浏览器中展示的不止有HTML，还有JavaScript、CSS、图片、音频等文件，基于此需求HTTP/1.0诞生了。\n\nHTTP/1.0区别于HTTP/0.9的最大区别就是引入了请求头、响应头，这样就能够传输各种更多的文件采用更多的方法进行更加深入的交流。如下所示的请求头信息：\n\n```\naccept: text/html\naccept-encoding: gzip, deflate, br\naccept-Charset: ISO-8859-1,utf-8\naccept-language: zh-CN,zh\n```\n\n这四行分别表示\n\n1.客户端需要请求的文件信息是text/html。\n\n2.因为传输文件体积往往会相对较大，所以需要压缩文件进行传输，第二行表示的是客户端期待服务端压缩文件的方式。\n\n3.客户端期待返回的文件编码方式是UTF-8 或者 ISO-8859-1。\n\n4.客户端期待服务端想要中文版本语言页面。\n\n服务端会根据客户端发送的请求头信息进行数据处理，最后返回带有响应头的数据信息，如下所示的响应头信息：\n\n```\ncontent-encoding: br\ncontent-type: text/html; charset=UTF-8\n```\n\n表示1.服务端最终采用的压缩方式是br。2.服务端返回的Html文件的编码类型是UTF-8。\n\n除了以上这个HTTP/1.0的重要特性外，还有其他几个新增特性：\n\n1.引入了状态码。\n\n2.提供了Cache机制来减轻服务器压力。\n\n3.请求头中加入了用户代理字段来统计客户端基础信息。\n\nHTTP/1.1是在HTTP/1.0的基础上争对其问题进行一定的修改，主要改进内容如下所示：\n\n1.支持持久连接。\n\n在此之前每进行一次HTTP请求连接都要建立一次TCP连接，这样就会在连续多次HTTP连接中产生一定时间用于TCP连接而造成时间延迟，HTTP/1.1使用持久连接进行改进，即一个TCP连接上可以传输多个HTTP请求，只要浏览器或服务器没有明确断开连接，该TCP连接会一直保持。浏览器为每个域名最多同时维护六个TCP持久连接。\n\n2.HTTP管线化。\n\nHTTP/1.1企图使用管线化的方式来解决由于进行多次请求而由于前方的请求未被处理完成而产生的阻塞问题。具体的方式是整批将请求发送给服务端，不过由于服务端一九需要根据请求顺序来进行回复，所以管线化的方案在后来都被许多浏览器放弃。\n\n3.提供虚拟主机支持。\n\n随着虚拟主机技术的发展实现了一台物理主机绑定了多个虚拟主机，即有多个域名，这些域名都共用同一个IP地址，HTTP/1.1在请求头上增加Host字段来表示当前的域名地址来进行处理。\n\n4.对动态生成的内容提供完美支持。\n\n在HTTP/1.0中，需要在响应头设置完整数据大小，浏览器可以根据设置的大小来接受数据，不过现在越来越多的页面内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，HTTP/1.1引入了Chunk transfer 机制来解决这个问题。\n\n5.客户端Cookie、安全机制。\n\n诞HTTP/1.1存在对宽带利用率并不理想导致网络传输速度较慢的问题，导致该问题的主要原因如下所示：\n\n1.TCP的慢启动。这是TCP为了减少网络拥塞的一个策略，无法改变。\n\n2.同时开启了多条TCP连接，那么这些连接会竞争固定的宽带。\n\n3.HTTP/1.1对头阻塞问题。\n\nHTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。\n\n另外HTTP/2采用了多路复用来解决阻塞问题，具体就是给每一个请求一个对应的ID，然后服务器就会根据自己的喜好优先选择先处理和返回哪些内容。\n\n除此之外，HTTP/2还设置了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到该请求之后就会优先处理优先级高的请求。\n\n服务器推送，之前服务端一直是被动的返回信息，诞生HTTP/2可以主动推送信息。\n\n头部压缩。来提高船速效率。\n\n诞生HTTP/2依旧存在一定的问题，HTTP/2的主要问题是其上的TCP协议导致的，因为TCP协议本就是单连接协议，必然产生很多问题导致阻塞延迟的现象，而HTTP无法改变TCP协议就只能绕过TCP协议。HTTP/3则是采用了基于UDP协议来构造一个新的协议QUIC协议，来实现TCP和UD拥有的一些合理性优势。\n\n\n","source":"_posts/HTTP1.md","raw":"HTTP1\n\n\n\nHTTP1的演进过程\n\n\n\n1991年提出了HTTP/0.9,它也是基于TCP协议的，所以一个HTTP/0.9请求在TCP连接成功后从客服端向服务端发送一个GET请求行信息，服务端收到请求后会采用ASCII字符流返回对应的HTML文件。文件传输完成后就断开连接。\n\n\n\nHTTP/0.9有三个特点\n\n1.只有请求行，没有请求头和请求体。\n\n2.服务器返回的信息没有响应头。\n\n3.服务端返回的文件内容是ASCII字符流。因为传输的只有HTML格式的文件，其用ASCII字节码传输最合适。\n\nHTTP/0.9只适合传输体积小的HTML文件。最开始的HTTP只需要满足学术上交流的基本需求而可以用HTTP/0.9来满足，随着新兴网络的兴起，浏览器中展示的不止有HTML，还有JavaScript、CSS、图片、音频等文件，基于此需求HTTP/1.0诞生了。\n\nHTTP/1.0区别于HTTP/0.9的最大区别就是引入了请求头、响应头，这样就能够传输各种更多的文件采用更多的方法进行更加深入的交流。如下所示的请求头信息：\n\n```\naccept: text/html\naccept-encoding: gzip, deflate, br\naccept-Charset: ISO-8859-1,utf-8\naccept-language: zh-CN,zh\n```\n\n这四行分别表示\n\n1.客户端需要请求的文件信息是text/html。\n\n2.因为传输文件体积往往会相对较大，所以需要压缩文件进行传输，第二行表示的是客户端期待服务端压缩文件的方式。\n\n3.客户端期待返回的文件编码方式是UTF-8 或者 ISO-8859-1。\n\n4.客户端期待服务端想要中文版本语言页面。\n\n服务端会根据客户端发送的请求头信息进行数据处理，最后返回带有响应头的数据信息，如下所示的响应头信息：\n\n```\ncontent-encoding: br\ncontent-type: text/html; charset=UTF-8\n```\n\n表示1.服务端最终采用的压缩方式是br。2.服务端返回的Html文件的编码类型是UTF-8。\n\n除了以上这个HTTP/1.0的重要特性外，还有其他几个新增特性：\n\n1.引入了状态码。\n\n2.提供了Cache机制来减轻服务器压力。\n\n3.请求头中加入了用户代理字段来统计客户端基础信息。\n\nHTTP/1.1是在HTTP/1.0的基础上争对其问题进行一定的修改，主要改进内容如下所示：\n\n1.支持持久连接。\n\n在此之前每进行一次HTTP请求连接都要建立一次TCP连接，这样就会在连续多次HTTP连接中产生一定时间用于TCP连接而造成时间延迟，HTTP/1.1使用持久连接进行改进，即一个TCP连接上可以传输多个HTTP请求，只要浏览器或服务器没有明确断开连接，该TCP连接会一直保持。浏览器为每个域名最多同时维护六个TCP持久连接。\n\n2.HTTP管线化。\n\nHTTP/1.1企图使用管线化的方式来解决由于进行多次请求而由于前方的请求未被处理完成而产生的阻塞问题。具体的方式是整批将请求发送给服务端，不过由于服务端一九需要根据请求顺序来进行回复，所以管线化的方案在后来都被许多浏览器放弃。\n\n3.提供虚拟主机支持。\n\n随着虚拟主机技术的发展实现了一台物理主机绑定了多个虚拟主机，即有多个域名，这些域名都共用同一个IP地址，HTTP/1.1在请求头上增加Host字段来表示当前的域名地址来进行处理。\n\n4.对动态生成的内容提供完美支持。\n\n在HTTP/1.0中，需要在响应头设置完整数据大小，浏览器可以根据设置的大小来接受数据，不过现在越来越多的页面内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，HTTP/1.1引入了Chunk transfer 机制来解决这个问题。\n\n5.客户端Cookie、安全机制。\n\n诞HTTP/1.1存在对宽带利用率并不理想导致网络传输速度较慢的问题，导致该问题的主要原因如下所示：\n\n1.TCP的慢启动。这是TCP为了减少网络拥塞的一个策略，无法改变。\n\n2.同时开启了多条TCP连接，那么这些连接会竞争固定的宽带。\n\n3.HTTP/1.1对头阻塞问题。\n\nHTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。\n\n另外HTTP/2采用了多路复用来解决阻塞问题，具体就是给每一个请求一个对应的ID，然后服务器就会根据自己的喜好优先选择先处理和返回哪些内容。\n\n除此之外，HTTP/2还设置了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到该请求之后就会优先处理优先级高的请求。\n\n服务器推送，之前服务端一直是被动的返回信息，诞生HTTP/2可以主动推送信息。\n\n头部压缩。来提高船速效率。\n\n诞生HTTP/2依旧存在一定的问题，HTTP/2的主要问题是其上的TCP协议导致的，因为TCP协议本就是单连接协议，必然产生很多问题导致阻塞延迟的现象，而HTTP无法改变TCP协议就只能绕过TCP协议。HTTP/3则是采用了基于UDP协议来构造一个新的协议QUIC协议，来实现TCP和UD拥有的一些合理性优势。\n\n\n","slug":"HTTP1","published":1,"date":"2022-02-22T01:20:19.685Z","updated":"2022-02-22T03:03:36.354Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh0i00016wtvbg3t5ren","content":"<p>HTTP1</p>\n<p>HTTP1的演进过程</p>\n<p>1991年提出了HTTP/0.9,它也是基于TCP协议的，所以一个HTTP/0.9请求在TCP连接成功后从客服端向服务端发送一个GET请求行信息，服务端收到请求后会采用ASCII字符流返回对应的HTML文件。文件传输完成后就断开连接。</p>\n<p>HTTP/0.9有三个特点</p>\n<p>1.只有请求行，没有请求头和请求体。</p>\n<p>2.服务器返回的信息没有响应头。</p>\n<p>3.服务端返回的文件内容是ASCII字符流。因为传输的只有HTML格式的文件，其用ASCII字节码传输最合适。</p>\n<p>HTTP/0.9只适合传输体积小的HTML文件。最开始的HTTP只需要满足学术上交流的基本需求而可以用HTTP/0.9来满足，随着新兴网络的兴起，浏览器中展示的不止有HTML，还有JavaScript、CSS、图片、音频等文件，基于此需求HTTP/1.0诞生了。</p>\n<p>HTTP/1.0区别于HTTP/0.9的最大区别就是引入了请求头、响应头，这样就能够传输各种更多的文件采用更多的方法进行更加深入的交流。如下所示的请求头信息：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">accep<span class=\"hljs-variable\">t:</span> text/html<br>accept-encodin<span class=\"hljs-variable\">g:</span> gzip, deflate, <span class=\"hljs-keyword\">br</span><br>accept-Charse<span class=\"hljs-variable\">t:</span> ISO-<span class=\"hljs-number\">8859</span>-<span class=\"hljs-number\">1</span>,utf-<span class=\"hljs-number\">8</span><br>accept-<span class=\"hljs-keyword\">language</span>: zh-CN,zh<br></code></pre></td></tr></table></figure>\n\n<p>这四行分别表示</p>\n<p>1.客户端需要请求的文件信息是text/html。</p>\n<p>2.因为传输文件体积往往会相对较大，所以需要压缩文件进行传输，第二行表示的是客户端期待服务端压缩文件的方式。</p>\n<p>3.客户端期待返回的文件编码方式是UTF-8 或者 ISO-8859-1。</p>\n<p>4.客户端期待服务端想要中文版本语言页面。</p>\n<p>服务端会根据客户端发送的请求头信息进行数据处理，最后返回带有响应头的数据信息，如下所示的响应头信息：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\">content-encoding: <span class=\"hljs-keyword\">br</span><br>content-<span class=\"hljs-keyword\">type</span>: text/html<span class=\"hljs-comment\">; charset=UTF-8</span><br></code></pre></td></tr></table></figure>\n\n<p>表示1.服务端最终采用的压缩方式是br。2.服务端返回的Html文件的编码类型是UTF-8。</p>\n<p>除了以上这个HTTP/1.0的重要特性外，还有其他几个新增特性：</p>\n<p>1.引入了状态码。</p>\n<p>2.提供了Cache机制来减轻服务器压力。</p>\n<p>3.请求头中加入了用户代理字段来统计客户端基础信息。</p>\n<p>HTTP/1.1是在HTTP/1.0的基础上争对其问题进行一定的修改，主要改进内容如下所示：</p>\n<p>1.支持持久连接。</p>\n<p>在此之前每进行一次HTTP请求连接都要建立一次TCP连接，这样就会在连续多次HTTP连接中产生一定时间用于TCP连接而造成时间延迟，HTTP/1.1使用持久连接进行改进，即一个TCP连接上可以传输多个HTTP请求，只要浏览器或服务器没有明确断开连接，该TCP连接会一直保持。浏览器为每个域名最多同时维护六个TCP持久连接。</p>\n<p>2.HTTP管线化。</p>\n<p>HTTP/1.1企图使用管线化的方式来解决由于进行多次请求而由于前方的请求未被处理完成而产生的阻塞问题。具体的方式是整批将请求发送给服务端，不过由于服务端一九需要根据请求顺序来进行回复，所以管线化的方案在后来都被许多浏览器放弃。</p>\n<p>3.提供虚拟主机支持。</p>\n<p>随着虚拟主机技术的发展实现了一台物理主机绑定了多个虚拟主机，即有多个域名，这些域名都共用同一个IP地址，HTTP/1.1在请求头上增加Host字段来表示当前的域名地址来进行处理。</p>\n<p>4.对动态生成的内容提供完美支持。</p>\n<p>在HTTP/1.0中，需要在响应头设置完整数据大小，浏览器可以根据设置的大小来接受数据，不过现在越来越多的页面内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，HTTP/1.1引入了Chunk transfer 机制来解决这个问题。</p>\n<p>5.客户端Cookie、安全机制。</p>\n<p>诞HTTP/1.1存在对宽带利用率并不理想导致网络传输速度较慢的问题，导致该问题的主要原因如下所示：</p>\n<p>1.TCP的慢启动。这是TCP为了减少网络拥塞的一个策略，无法改变。</p>\n<p>2.同时开启了多条TCP连接，那么这些连接会竞争固定的宽带。</p>\n<p>3.HTTP/1.1对头阻塞问题。</p>\n<p>HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</p>\n<p>另外HTTP/2采用了多路复用来解决阻塞问题，具体就是给每一个请求一个对应的ID，然后服务器就会根据自己的喜好优先选择先处理和返回哪些内容。</p>\n<p>除此之外，HTTP/2还设置了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到该请求之后就会优先处理优先级高的请求。</p>\n<p>服务器推送，之前服务端一直是被动的返回信息，诞生HTTP/2可以主动推送信息。</p>\n<p>头部压缩。来提高船速效率。</p>\n<p>诞生HTTP/2依旧存在一定的问题，HTTP/2的主要问题是其上的TCP协议导致的，因为TCP协议本就是单连接协议，必然产生很多问题导致阻塞延迟的现象，而HTTP无法改变TCP协议就只能绕过TCP协议。HTTP/3则是采用了基于UDP协议来构造一个新的协议QUIC协议，来实现TCP和UD拥有的一些合理性优势。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<p>HTTP1</p>\n<p>HTTP1的演进过程</p>\n<p>1991年提出了HTTP/0.9,它也是基于TCP协议的，所以一个HTTP/0.9请求在TCP连接成功后从客服端向服务端发送一个GET请求行信息，服务端收到请求后会采用ASCII字符流返回对应的HTML文件。文件传输完成后就断开连接。</p>\n<p>HTTP/0.9有三个特点</p>\n<p>1.只有请求行，没有请求头和请求体。</p>\n<p>2.服务器返回的信息没有响应头。</p>\n<p>3.服务端返回的文件内容是ASCII字符流。因为传输的只有HTML格式的文件，其用ASCII字节码传输最合适。</p>\n<p>HTTP/0.9只适合传输体积小的HTML文件。最开始的HTTP只需要满足学术上交流的基本需求而可以用HTTP/0.9来满足，随着新兴网络的兴起，浏览器中展示的不止有HTML，还有JavaScript、CSS、图片、音频等文件，基于此需求HTTP/1.0诞生了。</p>\n<p>HTTP/1.0区别于HTTP/0.9的最大区别就是引入了请求头、响应头，这样就能够传输各种更多的文件采用更多的方法进行更加深入的交流。如下所示的请求头信息：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">accep<span class=\"hljs-variable\">t:</span> text/html<br>accept-encodin<span class=\"hljs-variable\">g:</span> gzip, deflate, <span class=\"hljs-keyword\">br</span><br>accept-Charse<span class=\"hljs-variable\">t:</span> ISO-<span class=\"hljs-number\">8859</span>-<span class=\"hljs-number\">1</span>,utf-<span class=\"hljs-number\">8</span><br>accept-<span class=\"hljs-keyword\">language</span>: zh-CN,zh<br></code></pre></td></tr></table></figure>\n\n<p>这四行分别表示</p>\n<p>1.客户端需要请求的文件信息是text/html。</p>\n<p>2.因为传输文件体积往往会相对较大，所以需要压缩文件进行传输，第二行表示的是客户端期待服务端压缩文件的方式。</p>\n<p>3.客户端期待返回的文件编码方式是UTF-8 或者 ISO-8859-1。</p>\n<p>4.客户端期待服务端想要中文版本语言页面。</p>\n<p>服务端会根据客户端发送的请求头信息进行数据处理，最后返回带有响应头的数据信息，如下所示的响应头信息：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\">content-encoding: <span class=\"hljs-keyword\">br</span><br>content-<span class=\"hljs-keyword\">type</span>: text/html<span class=\"hljs-comment\">; charset=UTF-8</span><br></code></pre></td></tr></table></figure>\n\n<p>表示1.服务端最终采用的压缩方式是br。2.服务端返回的Html文件的编码类型是UTF-8。</p>\n<p>除了以上这个HTTP/1.0的重要特性外，还有其他几个新增特性：</p>\n<p>1.引入了状态码。</p>\n<p>2.提供了Cache机制来减轻服务器压力。</p>\n<p>3.请求头中加入了用户代理字段来统计客户端基础信息。</p>\n<p>HTTP/1.1是在HTTP/1.0的基础上争对其问题进行一定的修改，主要改进内容如下所示：</p>\n<p>1.支持持久连接。</p>\n<p>在此之前每进行一次HTTP请求连接都要建立一次TCP连接，这样就会在连续多次HTTP连接中产生一定时间用于TCP连接而造成时间延迟，HTTP/1.1使用持久连接进行改进，即一个TCP连接上可以传输多个HTTP请求，只要浏览器或服务器没有明确断开连接，该TCP连接会一直保持。浏览器为每个域名最多同时维护六个TCP持久连接。</p>\n<p>2.HTTP管线化。</p>\n<p>HTTP/1.1企图使用管线化的方式来解决由于进行多次请求而由于前方的请求未被处理完成而产生的阻塞问题。具体的方式是整批将请求发送给服务端，不过由于服务端一九需要根据请求顺序来进行回复，所以管线化的方案在后来都被许多浏览器放弃。</p>\n<p>3.提供虚拟主机支持。</p>\n<p>随着虚拟主机技术的发展实现了一台物理主机绑定了多个虚拟主机，即有多个域名，这些域名都共用同一个IP地址，HTTP/1.1在请求头上增加Host字段来表示当前的域名地址来进行处理。</p>\n<p>4.对动态生成的内容提供完美支持。</p>\n<p>在HTTP/1.0中，需要在响应头设置完整数据大小，浏览器可以根据设置的大小来接受数据，不过现在越来越多的页面内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，HTTP/1.1引入了Chunk transfer 机制来解决这个问题。</p>\n<p>5.客户端Cookie、安全机制。</p>\n<p>诞HTTP/1.1存在对宽带利用率并不理想导致网络传输速度较慢的问题，导致该问题的主要原因如下所示：</p>\n<p>1.TCP的慢启动。这是TCP为了减少网络拥塞的一个策略，无法改变。</p>\n<p>2.同时开启了多条TCP连接，那么这些连接会竞争固定的宽带。</p>\n<p>3.HTTP/1.1对头阻塞问题。</p>\n<p>HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</p>\n<p>另外HTTP/2采用了多路复用来解决阻塞问题，具体就是给每一个请求一个对应的ID，然后服务器就会根据自己的喜好优先选择先处理和返回哪些内容。</p>\n<p>除此之外，HTTP/2还设置了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到该请求之后就会优先处理优先级高的请求。</p>\n<p>服务器推送，之前服务端一直是被动的返回信息，诞生HTTP/2可以主动推送信息。</p>\n<p>头部压缩。来提高船速效率。</p>\n<p>诞生HTTP/2依旧存在一定的问题，HTTP/2的主要问题是其上的TCP协议导致的，因为TCP协议本就是单连接协议，必然产生很多问题导致阻塞延迟的现象，而HTTP无法改变TCP协议就只能绕过TCP协议。HTTP/3则是采用了基于UDP协议来构造一个新的协议QUIC协议，来实现TCP和UD拥有的一些合理性优势。</p>\n"},{"title":"React的认识与初步尝试","date":"2021-12-19T00:39:01.000Z","_content":"\n### 一、React是什么\n\n一个JavaScipt库，配合JSX（一个JavaScipt语法扩展）能够更好描述UI应该呈现的交互本质形式。\n\n### 二、初步使用React实例\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <!-- 上面两个Js文件是有固定的引用先后顺序 -->\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        function fun(name){\n            return name+' hh';\n        }\n        class HelloMsg extends React.Component{\n            render(){\n                return (\n                <div>\n                  <div>hello React</div>\n                  <h3>{this.props.name}</h3>\n                  <h2>{2+3}</h2>\n                  <h1>{fun('abc')}</h1>\n                </div>\n                )\n            }\n        }\n        ReactDOM.render(<HelloMsg name=\"hhh\"/>,document.getElementById(\"test1\"))\n\n        </script>\n</html>\n```\n\n第一步：导入相关js文件\n\n第二步：在body中定义需要渲染的元素\n\n第三步：在js区域自定义组件，并调用`ReactDOM.render`进行元素渲染。\n\n之后仔细分析js部分代码：\n\n```javascript\nfunction fun(name){\n            return name+' hh';\n    }\nclass HelloMsg extends React.Component{\n    render(){\n        return (\n            <div>\n              <div>hello React</div>\n              <h3>{this.props.name}</h3>\n              <h2>{2+3}</h2>\n              <h1>{fun('abc')}</h1>\n            </div>\n            )\n        }\n    }\nReactDOM.render(<HelloMsg name=\"hhh\"/>,document.getElementById(\"test1\"))\n```\n\n在方法`ReactDOM.render(element, document.getElementById('root'));`为将自定义的元素`element`覆盖html中id为root的块元素。因为覆盖Html中的元素只有一个，所以返回的也是一个块元素，里面可以包裹很多小元素，在使用html元素时使用js相关只要使用`{}`就可以。而元素传参运用`this.props`来进行传输。\n\nReact元素不可修改，更新的方法只能是创建一个新的元素传入ReactDOM.render\n\nReact 只更新它需要更新的部分,尽管每一秒我们都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容，也就是例子中的文本节点。\n\n### 三、定义React元素\n\n可以通过以下方法自定义元素。\n\n```javascript\n//自定义元素element\nconst element = (\n    <div>\n        <h1>h1h1</h1>\n        <h2>h2h2</h2>\n    </div>\n);\nReactDOM.render(element,document.getElementById(\"test1\"))\n```\n\n### 四、自定义组件\n\nReact可以自定义复杂的组件，有两种自定义组件的方法，分别是函数的方法和类的方法。如下例所示：\n\n```\n// 用函数的方式自定义组件\nfunction HelloMsg(props){\n    return <h1>hello~ {props.name} !</h1>\n}\n// ES6的类自定义组件\nclass HiMsg extends React.Component{\n    render(){\n            return <h2>hi~ {this.props.name}</h2>\n    }    \n}\n```\n\n其中，函数方法的元素传参方式和类的元素传参方式有所区别。\n\n所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。\n\n自定义组件还可以组合使用，如下所示：\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <!-- 上面两个Js文件是有固定的引用先后顺序 -->\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        // 组合组件\n\n        // 用函数的方式自定义组件\n        // 自定义组件可以实现交互传参\n        function HelloMsg(props){\n            return <h1>hello~ {props.name} !</h1>\n        }\n        // ES6的类自定义组件\n        class HiMsg extends React.Component{\n            render(){\n                return <h2>hi~ {this.props.name}</h2>\n            }\n\n        }\n\n        // 组合组件\n        function App(){\n            return (\n              <div>\n                  <HelloMsg name=\"zhangsan\"/>\n                  <HiMsg name=\"zhangsan\"/>\n                  <HelloMsg name=\"Mody\"/>\n                  <HiMsg name=\"Mody\"/>\n                  <HelloMsg name=\"Recy\"/>\n                  <HiMsg name=\"Recy\"/>\n              </div>\n            )\n        }\n        ReactDOM.render(<App/>,document.getElementById(\"test1\"))\n\n        </script>\n</html>\n```\n","source":"_posts/React学习一.md","raw":"---\ntitle: React的认识与初步尝试\ndate: 2021-12-19 08:39:01\ntags: [React, 学习]\ncategories:\n- React\n---\n\n### 一、React是什么\n\n一个JavaScipt库，配合JSX（一个JavaScipt语法扩展）能够更好描述UI应该呈现的交互本质形式。\n\n### 二、初步使用React实例\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <!-- 上面两个Js文件是有固定的引用先后顺序 -->\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        function fun(name){\n            return name+' hh';\n        }\n        class HelloMsg extends React.Component{\n            render(){\n                return (\n                <div>\n                  <div>hello React</div>\n                  <h3>{this.props.name}</h3>\n                  <h2>{2+3}</h2>\n                  <h1>{fun('abc')}</h1>\n                </div>\n                )\n            }\n        }\n        ReactDOM.render(<HelloMsg name=\"hhh\"/>,document.getElementById(\"test1\"))\n\n        </script>\n</html>\n```\n\n第一步：导入相关js文件\n\n第二步：在body中定义需要渲染的元素\n\n第三步：在js区域自定义组件，并调用`ReactDOM.render`进行元素渲染。\n\n之后仔细分析js部分代码：\n\n```javascript\nfunction fun(name){\n            return name+' hh';\n    }\nclass HelloMsg extends React.Component{\n    render(){\n        return (\n            <div>\n              <div>hello React</div>\n              <h3>{this.props.name}</h3>\n              <h2>{2+3}</h2>\n              <h1>{fun('abc')}</h1>\n            </div>\n            )\n        }\n    }\nReactDOM.render(<HelloMsg name=\"hhh\"/>,document.getElementById(\"test1\"))\n```\n\n在方法`ReactDOM.render(element, document.getElementById('root'));`为将自定义的元素`element`覆盖html中id为root的块元素。因为覆盖Html中的元素只有一个，所以返回的也是一个块元素，里面可以包裹很多小元素，在使用html元素时使用js相关只要使用`{}`就可以。而元素传参运用`this.props`来进行传输。\n\nReact元素不可修改，更新的方法只能是创建一个新的元素传入ReactDOM.render\n\nReact 只更新它需要更新的部分,尽管每一秒我们都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容，也就是例子中的文本节点。\n\n### 三、定义React元素\n\n可以通过以下方法自定义元素。\n\n```javascript\n//自定义元素element\nconst element = (\n    <div>\n        <h1>h1h1</h1>\n        <h2>h2h2</h2>\n    </div>\n);\nReactDOM.render(element,document.getElementById(\"test1\"))\n```\n\n### 四、自定义组件\n\nReact可以自定义复杂的组件，有两种自定义组件的方法，分别是函数的方法和类的方法。如下例所示：\n\n```\n// 用函数的方式自定义组件\nfunction HelloMsg(props){\n    return <h1>hello~ {props.name} !</h1>\n}\n// ES6的类自定义组件\nclass HiMsg extends React.Component{\n    render(){\n            return <h2>hi~ {this.props.name}</h2>\n    }    \n}\n```\n\n其中，函数方法的元素传参方式和类的元素传参方式有所区别。\n\n所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。\n\n自定义组件还可以组合使用，如下所示：\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <!-- 上面两个Js文件是有固定的引用先后顺序 -->\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        // 组合组件\n\n        // 用函数的方式自定义组件\n        // 自定义组件可以实现交互传参\n        function HelloMsg(props){\n            return <h1>hello~ {props.name} !</h1>\n        }\n        // ES6的类自定义组件\n        class HiMsg extends React.Component{\n            render(){\n                return <h2>hi~ {this.props.name}</h2>\n            }\n\n        }\n\n        // 组合组件\n        function App(){\n            return (\n              <div>\n                  <HelloMsg name=\"zhangsan\"/>\n                  <HiMsg name=\"zhangsan\"/>\n                  <HelloMsg name=\"Mody\"/>\n                  <HiMsg name=\"Mody\"/>\n                  <HelloMsg name=\"Recy\"/>\n                  <HiMsg name=\"Recy\"/>\n              </div>\n            )\n        }\n        ReactDOM.render(<App/>,document.getElementById(\"test1\"))\n\n        </script>\n</html>\n```\n","slug":"React学习一","published":1,"updated":"2022-03-11T03:27:45.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh0o00036wtv13wqgu9r","content":"<h3 id=\"一、React是什么\"><a href=\"#一、React是什么\" class=\"headerlink\" title=\"一、React是什么\"></a>一、React是什么</h3><p>一个JavaScipt库，配合JSX（一个JavaScipt语法扩展）能够更好描述UI应该呈现的交互本质形式。</p>\n<h3 id=\"二、初步使用React实例\"><a href=\"#二、初步使用React实例\" class=\"headerlink\" title=\"二、初步使用React实例\"></a>二、初步使用React实例</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!-- 上面两个Js文件是有固定的引用先后顺序 --&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\">name</span>)</span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">return</span> name+<span class=\"hljs-string\">&#x27; hh&#x27;</span>;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloMsg</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"javascript\">                <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>hello React<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>&#123;this.props.name&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>&#123;2+3&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;fun(&#x27;abc&#x27;)&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HelloMsg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;hhh&quot;</span>/&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;test1&quot;</span>))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>第一步：导入相关js文件</p>\n<p>第二步：在body中定义需要渲染的元素</p>\n<p>第三步：在js区域自定义组件，并调用<code>ReactDOM.render</code>进行元素渲染。</p>\n<p>之后仔细分析js部分代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\">name</span>)</span>&#123;<br>            <span class=\"hljs-keyword\">return</span> name+<span class=\"hljs-string\">&#x27; hh&#x27;</span>;<br>    &#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloMsg</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> (<br>            <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>hello React<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>&#123;this.props.name&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span></span><br><span class=\"xml\">              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>&#123;2+3&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span></span><br><span class=\"xml\">              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;fun(&#x27;abc&#x27;)&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"xml\">            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>            )<br>        &#125;<br>    &#125;<br>ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HelloMsg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;hhh&quot;</span>/&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;test1&quot;</span>))<br></code></pre></td></tr></table></figure>\n\n<p>在方法<code>ReactDOM.render(element, document.getElementById(&#39;root&#39;));</code>为将自定义的元素<code>element</code>覆盖html中id为root的块元素。因为覆盖Html中的元素只有一个，所以返回的也是一个块元素，里面可以包裹很多小元素，在使用html元素时使用js相关只要使用<code>&#123;&#125;</code>就可以。而元素传参运用<code>this.props</code>来进行传输。</p>\n<p>React元素不可修改，更新的方法只能是创建一个新的元素传入ReactDOM.render</p>\n<p>React 只更新它需要更新的部分,尽管每一秒我们都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容，也就是例子中的文本节点。</p>\n<h3 id=\"三、定义React元素\"><a href=\"#三、定义React元素\" class=\"headerlink\" title=\"三、定义React元素\"></a>三、定义React元素</h3><p>可以通过以下方法自定义元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//自定义元素element</span><br><span class=\"hljs-keyword\">const</span> element = (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>h1h1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>h2h2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>);<br>ReactDOM.render(element,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;test1&quot;</span>))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"四、自定义组件\"><a href=\"#四、自定义组件\" class=\"headerlink\" title=\"四、自定义组件\"></a>四、自定义组件</h3><p>React可以自定义复杂的组件，有两种自定义组件的方法，分别是函数的方法和类的方法。如下例所示：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-comment\">// 用函数的方式自定义组件</span><br>function <span class=\"hljs-type\">HelloMsg</span>(props)&#123;<br>    <span class=\"hljs-keyword\">return</span> &lt;h1&gt;hello~ &#123;props.name&#125; !&lt;/h1&gt;<br>&#125;<br><span class=\"hljs-comment\">// ES6的类自定义组件</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HiMsg</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;<br>    render()&#123;<br>            <span class=\"hljs-keyword\">return</span> &lt;h2&gt;hi~ &#123;<span class=\"hljs-keyword\">this</span>.props.name&#125;&lt;/h2&gt;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>其中，函数方法的元素传参方式和类的元素传参方式有所区别。</p>\n<p>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</p>\n<p>自定义组件还可以组合使用，如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!-- 上面两个Js文件是有固定的引用先后顺序 --&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">// 组合组件</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">// 用函数的方式自定义组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">// 自定义组件可以实现交互传参</span></span><br><span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">HelloMsg</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>hello~ &#123;props.name&#125; !<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span></span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        <span class=\"hljs-comment\">// ES6的类自定义组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HiMsg</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>hi~ &#123;this.props.name&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span></span></span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">// 组合组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"javascript\">              <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HelloMsg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;zhangsan&quot;</span>/&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HiMsg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;zhangsan&quot;</span>/&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HelloMsg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;Mody&quot;</span>/&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HiMsg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;Mody&quot;</span>/&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HelloMsg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;Recy&quot;</span>/&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HiMsg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;Recy&quot;</span>/&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">              <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"javascript\">            )</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span>/&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;test1&quot;</span>))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<h3 id=\"一、React是什么\"><a href=\"#一、React是什么\" class=\"headerlink\" title=\"一、React是什么\"></a>一、React是什么</h3><p>一个JavaScipt库，配合JSX（一个JavaScipt语法扩展）能够更好描述UI应该呈现的交互本质形式。</p>\n<h3 id=\"二、初步使用React实例\"><a href=\"#二、初步使用React实例\" class=\"headerlink\" title=\"二、初步使用React实例\"></a>二、初步使用React实例</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!-- 上面两个Js文件是有固定的引用先后顺序 --&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\">name</span>)</span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">return</span> name+<span class=\"hljs-string\">&#x27; hh&#x27;</span>;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloMsg</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"javascript\">                <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>hello React<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>&#123;this.props.name&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>&#123;2+3&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;fun(&#x27;abc&#x27;)&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HelloMsg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;hhh&quot;</span>/&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;test1&quot;</span>))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>第一步：导入相关js文件</p>\n<p>第二步：在body中定义需要渲染的元素</p>\n<p>第三步：在js区域自定义组件，并调用<code>ReactDOM.render</code>进行元素渲染。</p>\n<p>之后仔细分析js部分代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fun</span>(<span class=\"hljs-params\">name</span>)</span>&#123;<br>            <span class=\"hljs-keyword\">return</span> name+<span class=\"hljs-string\">&#x27; hh&#x27;</span>;<br>    &#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloMsg</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> (<br>            <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>hello React<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>&#123;this.props.name&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span></span><br><span class=\"xml\">              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>&#123;2+3&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span></span><br><span class=\"xml\">              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;fun(&#x27;abc&#x27;)&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"xml\">            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>            )<br>        &#125;<br>    &#125;<br>ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HelloMsg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;hhh&quot;</span>/&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;test1&quot;</span>))<br></code></pre></td></tr></table></figure>\n\n<p>在方法<code>ReactDOM.render(element, document.getElementById(&#39;root&#39;));</code>为将自定义的元素<code>element</code>覆盖html中id为root的块元素。因为覆盖Html中的元素只有一个，所以返回的也是一个块元素，里面可以包裹很多小元素，在使用html元素时使用js相关只要使用<code>&#123;&#125;</code>就可以。而元素传参运用<code>this.props</code>来进行传输。</p>\n<p>React元素不可修改，更新的方法只能是创建一个新的元素传入ReactDOM.render</p>\n<p>React 只更新它需要更新的部分,尽管每一秒我们都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容，也就是例子中的文本节点。</p>\n<h3 id=\"三、定义React元素\"><a href=\"#三、定义React元素\" class=\"headerlink\" title=\"三、定义React元素\"></a>三、定义React元素</h3><p>可以通过以下方法自定义元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//自定义元素element</span><br><span class=\"hljs-keyword\">const</span> element = (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>h1h1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>h2h2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>);<br>ReactDOM.render(element,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;test1&quot;</span>))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"四、自定义组件\"><a href=\"#四、自定义组件\" class=\"headerlink\" title=\"四、自定义组件\"></a>四、自定义组件</h3><p>React可以自定义复杂的组件，有两种自定义组件的方法，分别是函数的方法和类的方法。如下例所示：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-comment\">// 用函数的方式自定义组件</span><br>function <span class=\"hljs-type\">HelloMsg</span>(props)&#123;<br>    <span class=\"hljs-keyword\">return</span> &lt;h1&gt;hello~ &#123;props.name&#125; !&lt;/h1&gt;<br>&#125;<br><span class=\"hljs-comment\">// ES6的类自定义组件</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HiMsg</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;<br>    render()&#123;<br>            <span class=\"hljs-keyword\">return</span> &lt;h2&gt;hi~ &#123;<span class=\"hljs-keyword\">this</span>.props.name&#125;&lt;/h2&gt;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>其中，函数方法的元素传参方式和类的元素传参方式有所区别。</p>\n<p>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</p>\n<p>自定义组件还可以组合使用，如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!-- 上面两个Js文件是有固定的引用先后顺序 --&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">// 组合组件</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">// 用函数的方式自定义组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">// 自定义组件可以实现交互传参</span></span><br><span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">HelloMsg</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>hello~ &#123;props.name&#125; !<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span></span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        <span class=\"hljs-comment\">// ES6的类自定义组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HiMsg</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>hi~ &#123;this.props.name&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span></span></span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">// 组合组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"javascript\">              <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HelloMsg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;zhangsan&quot;</span>/&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HiMsg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;zhangsan&quot;</span>/&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HelloMsg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;Mody&quot;</span>/&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HiMsg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;Mody&quot;</span>/&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HelloMsg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;Recy&quot;</span>/&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HiMsg</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;Recy&quot;</span>/&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">              <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"javascript\">            )</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span>/&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;test1&quot;</span>))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n"},{"title":"React的列表和表单","date":"2021-12-19T01:45:05.000Z","_content":"\n### 一、使用map来进行列表渲染\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //通过map的方式渲染列表\n\n        function List(props){\n            //获取列表参数\n            const numbers=props.numbers;\n            //利用map进行渲染\n            const listItem=numbers.map((number=>\n            <li>{number}</li>));\n\n            return (\n              <ul>{listItem}</ul>\n            )\n        }\n\n        const numbers=[1,2,3,4,5];\n        ReactDOM.render(\n        <List numbers={numbers} />,\n        document.getElementById('test1'))\n\n        </script>\n</html>\n```\n\n运行以上代码，发现已成功渲染列表，但是在控制台获得警告如下：\n\n![](/images/react/2021121903.png)\n\n提示对于列表的每一个元素都需要key关键词，给每一列添加key:`<li key={number.toString()}>{number}</li>));`，key作为列表中每个元素的唯一标识符，是有优化性能的作用。对于应该在哪里设置元素的key，一个好的经验法则是：在 `map()` 方法中的元素需要设置 key 属性。\n\n以上情况可以也通过以下方法实现\n\n```jsx\nfuntion ListItem(props){\n            return <li>{props.value}</li>\n}\n\nfunction List2(props){\n    const numbers=props.numbers;\n    return (\n         <ul>\n            {numbers.map((number=>\n            <ListItem key={number.toString()} value={number} />\n            ))}\n        </ul>\n    )\n}\n```\n\n### 二、表单\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //表单的运用\n\n        //通过类自定义的内有方法来更方便迅捷地操作表单\n\n        //自定义表单组件\n        class NameForm extends React.Component{\n            constructor(props){\n                super(props);\n                //定义可更改的变量，即表单输入元素\n                this.state={value:''};\n                //在具体方法中绑定this来实现对state的改变。\n                this.handleChange=this.handleChange.bind(this);\n                this.handleSubmit=this.handleSubmit.bind(this);\n            }\n\n            handleChange(event){\n                this.setState({value:event.target.value});\n            }\n            handleSubmit(event){\n                //提交前显示名字\n                alert('提交的名字：'+this.state.value);\n                event.preventDefault();\n            }\n            render(){\n                return(\n                  <form onSubmit={this.handleSubmit}>\n                    <label>\n                      名字:\n                      <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n                     </label>\n                      <button type=\"submit\">提交</button>\n                    </form>  \n                )\n            }\n        }\n        ReactDOM.render(<NameForm />,document.getElementById('test1'))\n\n        </script>\n</html>\n```\n\n以上例子实现了一个自定义表单的应用。\n\n注意：在Html中`<textarea>` 组件直接通过子元素定义其文本，而在React中通过属性value来确定其文本。针对`<select>`组件React 并不会使用 `selected` 属性，而是在根 `select` 标签上使用 `value` 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。\n\n具体关于textarea 和select在React里的具体操作如下所示：\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //表单的运用\n\n        //通过类自定义的内有方法来更方便迅捷地操作表单\n\n        //自定义表单组件\n        class NameForm extends React.Component{\n            constructor(props){\n                super(props);\n                //定义可更改的变量，即表单输入元素\n                this.state={\n                    value:'',\n                    textValue:'',\n                    selected:'aa',\n                };\n                //在具体方法中绑定this来实现对state的改变。\n                this.handleChange=this.handleChange.bind(this);\n                this.handleSubmit=this.handleSubmit.bind(this);\n                this.handleChangeSelect=this.handleChangeSelect.bind(this);\n                this.handleChangeTextarea=this.handleChangeTextarea.bind(this);\n            }\n\n            handleChange(event){\n                this.setState({value:event.target.value});\n            }\n            handleSubmit(event){\n                //提交前显示名字\n                alert('提交的名字：'+this.state.value);\n                event.preventDefault();\n            }\n            handleChangeTextarea(event){\n                this.setState({textValue:event.target.value})\n            }\n            handleChangeSelect(event){\n                console.log('event',event)\n                this.setState({selected:event.target.value});\n            }\n            render(){\n                return(\n                  <form onSubmit={this.handleSubmit}>\n                    <label>\n                      名字:\n                      <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n                     </label>\n                     <label>\n                         内容：\n                         <textarea  value={this.state.textValue} onChange={this.handleChangeTextarea}/>\n                     </label>\n                     <label>\n                         选择：\n                         <select value={this.state.selected} onChange={this.handleChangeSelect} >\n                             <option value='aa'>aa</ option>\n                             <option value='bb'>bb</ option>\n                             <option value='cc'>cc</ option>\n                         </select>\n                     </label>\n                      <button type=\"submit\">提交</button>\n                    </form>  \n                )\n            }\n        }\n        ReactDOM.render(<NameForm />,document.getElementById('test1'))\n\n        </script>\n</html>\n```\n\n以上的形式在一个表单中调用了多个onChange，也可以只调用同一个onChange函数同时监听并改变多个数据，可以给每个元素添加 `name` 属性，并让处理函数根据 `event.target.name` 的值选择要执行的操作。具体代码如下所示：\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //表单的运用\n\n        //通过类自定义的内有方法来更方便迅捷地操作表单\n\n        //自定义表单组件\n        class NameForm extends React.Component{\n            constructor(props){\n                super(props);\n                //定义可更改的变量，即表单输入元素\n                this.state={\n                    nameValue:'',\n                    textValue:'',\n                    selected:'aa',\n                };\n                //在具体方法中绑定this来实现对state的改变。\n                this.handleChange=this.handleChange.bind(this);\n                this.handleSubmit=this.handleSubmit.bind(this);\n            }\n\n            handleChange(event){\n                const value=event.target.value;\n                const name=event.target.name;\n                this.setState({\n                    [name]:value\n                })\n            }\n            handleSubmit(event){\n                //提交前显示名字\n                alert('提交的名字：'+this.state.value);\n                console.log('state',this.state)\n                event.preventDefault();\n            }\n            render(){\n                return(\n                  <form onSubmit={this.handleSubmit}>\n                    <label>\n                      名字:\n                      <input name=\"nameValue\" type=\"text\" value={this.state.value} onChange={this.handleChange} />\n                     </label>\n                     <label>\n                         内容：\n                         <textarea name=\"textValue\"  value={this.state.textValue} onChange={this.handleChange}/>\n                     </label>\n                     <label>\n                         选择：\n                         <select name=\"selected\" value={this.state.selected} onChange={this.handleChange} >\n                             <option value='aa'>aa</ option>\n                             <option value='bb'>bb</ option>\n                             <option value='cc'>cc</ option>\n                         </select>\n                     </label>\n                      <button type=\"submit\">提交</button>\n                    </form>  \n                )\n            }\n        }\n        ReactDOM.render(<NameForm />,document.getElementById('test1'))\n\n        </script>\n</html>\n```\n","source":"_posts/React学习三.md","raw":"---\ntitle: React的列表和表单\ndate: 2021-12-19 09:45:05\ntags: [React, 学习]\ncategories:\n- React\n---\n\n### 一、使用map来进行列表渲染\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //通过map的方式渲染列表\n\n        function List(props){\n            //获取列表参数\n            const numbers=props.numbers;\n            //利用map进行渲染\n            const listItem=numbers.map((number=>\n            <li>{number}</li>));\n\n            return (\n              <ul>{listItem}</ul>\n            )\n        }\n\n        const numbers=[1,2,3,4,5];\n        ReactDOM.render(\n        <List numbers={numbers} />,\n        document.getElementById('test1'))\n\n        </script>\n</html>\n```\n\n运行以上代码，发现已成功渲染列表，但是在控制台获得警告如下：\n\n![](/images/react/2021121903.png)\n\n提示对于列表的每一个元素都需要key关键词，给每一列添加key:`<li key={number.toString()}>{number}</li>));`，key作为列表中每个元素的唯一标识符，是有优化性能的作用。对于应该在哪里设置元素的key，一个好的经验法则是：在 `map()` 方法中的元素需要设置 key 属性。\n\n以上情况可以也通过以下方法实现\n\n```jsx\nfuntion ListItem(props){\n            return <li>{props.value}</li>\n}\n\nfunction List2(props){\n    const numbers=props.numbers;\n    return (\n         <ul>\n            {numbers.map((number=>\n            <ListItem key={number.toString()} value={number} />\n            ))}\n        </ul>\n    )\n}\n```\n\n### 二、表单\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //表单的运用\n\n        //通过类自定义的内有方法来更方便迅捷地操作表单\n\n        //自定义表单组件\n        class NameForm extends React.Component{\n            constructor(props){\n                super(props);\n                //定义可更改的变量，即表单输入元素\n                this.state={value:''};\n                //在具体方法中绑定this来实现对state的改变。\n                this.handleChange=this.handleChange.bind(this);\n                this.handleSubmit=this.handleSubmit.bind(this);\n            }\n\n            handleChange(event){\n                this.setState({value:event.target.value});\n            }\n            handleSubmit(event){\n                //提交前显示名字\n                alert('提交的名字：'+this.state.value);\n                event.preventDefault();\n            }\n            render(){\n                return(\n                  <form onSubmit={this.handleSubmit}>\n                    <label>\n                      名字:\n                      <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n                     </label>\n                      <button type=\"submit\">提交</button>\n                    </form>  \n                )\n            }\n        }\n        ReactDOM.render(<NameForm />,document.getElementById('test1'))\n\n        </script>\n</html>\n```\n\n以上例子实现了一个自定义表单的应用。\n\n注意：在Html中`<textarea>` 组件直接通过子元素定义其文本，而在React中通过属性value来确定其文本。针对`<select>`组件React 并不会使用 `selected` 属性，而是在根 `select` 标签上使用 `value` 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。\n\n具体关于textarea 和select在React里的具体操作如下所示：\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //表单的运用\n\n        //通过类自定义的内有方法来更方便迅捷地操作表单\n\n        //自定义表单组件\n        class NameForm extends React.Component{\n            constructor(props){\n                super(props);\n                //定义可更改的变量，即表单输入元素\n                this.state={\n                    value:'',\n                    textValue:'',\n                    selected:'aa',\n                };\n                //在具体方法中绑定this来实现对state的改变。\n                this.handleChange=this.handleChange.bind(this);\n                this.handleSubmit=this.handleSubmit.bind(this);\n                this.handleChangeSelect=this.handleChangeSelect.bind(this);\n                this.handleChangeTextarea=this.handleChangeTextarea.bind(this);\n            }\n\n            handleChange(event){\n                this.setState({value:event.target.value});\n            }\n            handleSubmit(event){\n                //提交前显示名字\n                alert('提交的名字：'+this.state.value);\n                event.preventDefault();\n            }\n            handleChangeTextarea(event){\n                this.setState({textValue:event.target.value})\n            }\n            handleChangeSelect(event){\n                console.log('event',event)\n                this.setState({selected:event.target.value});\n            }\n            render(){\n                return(\n                  <form onSubmit={this.handleSubmit}>\n                    <label>\n                      名字:\n                      <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n                     </label>\n                     <label>\n                         内容：\n                         <textarea  value={this.state.textValue} onChange={this.handleChangeTextarea}/>\n                     </label>\n                     <label>\n                         选择：\n                         <select value={this.state.selected} onChange={this.handleChangeSelect} >\n                             <option value='aa'>aa</ option>\n                             <option value='bb'>bb</ option>\n                             <option value='cc'>cc</ option>\n                         </select>\n                     </label>\n                      <button type=\"submit\">提交</button>\n                    </form>  \n                )\n            }\n        }\n        ReactDOM.render(<NameForm />,document.getElementById('test1'))\n\n        </script>\n</html>\n```\n\n以上的形式在一个表单中调用了多个onChange，也可以只调用同一个onChange函数同时监听并改变多个数据，可以给每个元素添加 `name` 属性，并让处理函数根据 `event.target.name` 的值选择要执行的操作。具体代码如下所示：\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //表单的运用\n\n        //通过类自定义的内有方法来更方便迅捷地操作表单\n\n        //自定义表单组件\n        class NameForm extends React.Component{\n            constructor(props){\n                super(props);\n                //定义可更改的变量，即表单输入元素\n                this.state={\n                    nameValue:'',\n                    textValue:'',\n                    selected:'aa',\n                };\n                //在具体方法中绑定this来实现对state的改变。\n                this.handleChange=this.handleChange.bind(this);\n                this.handleSubmit=this.handleSubmit.bind(this);\n            }\n\n            handleChange(event){\n                const value=event.target.value;\n                const name=event.target.name;\n                this.setState({\n                    [name]:value\n                })\n            }\n            handleSubmit(event){\n                //提交前显示名字\n                alert('提交的名字：'+this.state.value);\n                console.log('state',this.state)\n                event.preventDefault();\n            }\n            render(){\n                return(\n                  <form onSubmit={this.handleSubmit}>\n                    <label>\n                      名字:\n                      <input name=\"nameValue\" type=\"text\" value={this.state.value} onChange={this.handleChange} />\n                     </label>\n                     <label>\n                         内容：\n                         <textarea name=\"textValue\"  value={this.state.textValue} onChange={this.handleChange}/>\n                     </label>\n                     <label>\n                         选择：\n                         <select name=\"selected\" value={this.state.selected} onChange={this.handleChange} >\n                             <option value='aa'>aa</ option>\n                             <option value='bb'>bb</ option>\n                             <option value='cc'>cc</ option>\n                         </select>\n                     </label>\n                      <button type=\"submit\">提交</button>\n                    </form>  \n                )\n            }\n        }\n        ReactDOM.render(<NameForm />,document.getElementById('test1'))\n\n        </script>\n</html>\n```\n","slug":"React学习三","published":1,"updated":"2022-03-11T03:42:08.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh0r00056wtv6514a7zh","content":"<h3 id=\"一、使用map来进行列表渲染\"><a href=\"#一、使用map来进行列表渲染\" class=\"headerlink\" title=\"一、使用map来进行列表渲染\"></a>一、使用map来进行列表渲染</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//通过map的方式渲染列表</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">List</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//获取列表参数</span></span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">const</span> numbers=props.numbers;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//利用map进行渲染</span></span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">const</span> listItem=numbers.map((<span class=\"hljs-function\"><span class=\"hljs-params\">number</span>=&gt;</span></span><br><span class=\"javascript\">            <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>&#123;number&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span>));</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"javascript\">              <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>&#123;listItem&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></span></span><br><span class=\"javascript\">            )</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-keyword\">const</span> numbers=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>];</span><br><span class=\"javascript\">        ReactDOM.render(</span><br><span class=\"javascript\">        <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">List</span> <span class=\"hljs-attr\">numbers</span>=<span class=\"hljs-string\">&#123;numbers&#125;</span> /&gt;</span></span>,</span><br><span class=\"javascript\">        <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;test1&#x27;</span>))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>运行以上代码，发现已成功渲染列表，但是在控制台获得警告如下：</p>\n<p><img src=\"/images/react/2021121903.png\"></p>\n<p>提示对于列表的每一个元素都需要key关键词，给每一列添加key:<code>&lt;li key=&#123;number.toString()&#125;&gt;&#123;number&#125;&lt;/li&gt;));</code>，key作为列表中每个元素的唯一标识符，是有优化性能的作用。对于应该在哪里设置元素的key，一个好的经验法则是：在 <code>map()</code> 方法中的元素需要设置 key 属性。</p>\n<p>以上情况可以也通过以下方法实现</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\">funtion <span class=\"hljs-function\"><span class=\"hljs-title\">ListItem</span>(<span class=\"hljs-params\">props</span>)</span>&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>&#123;props.value&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">List2</span>(<span class=\"hljs-params\">props</span>)</span>&#123;<br>    <span class=\"hljs-keyword\">const</span> numbers=props.numbers;<br>    <span class=\"hljs-keyword\">return</span> (<br>         <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span></span><br><span class=\"xml\">            &#123;numbers.map((number=&gt;</span><br><span class=\"xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ListItem</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#123;number.toString()&#125;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;number&#125;</span> /&gt;</span></span><br><span class=\"xml\">            ))&#125;</span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"二、表单\"><a href=\"#二、表单\" class=\"headerlink\" title=\"二、表单\"></a>二、表单</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//表单的运用</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//自定义表单组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NameForm</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props);</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//定义可更改的变量，即表单输入元素</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;<span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>&#125;;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChange=<span class=\"hljs-built_in\">this</span>.handleChange.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleSubmit=<span class=\"hljs-built_in\">this</span>.handleSubmit.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChange</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;<span class=\"hljs-attr\">value</span>:event.target.value&#125;);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleSubmit</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//提交前显示名字</span></span><br><span class=\"javascript\">                alert(<span class=\"hljs-string\">&#x27;提交的名字：&#x27;</span>+<span class=\"hljs-built_in\">this</span>.state.value);</span><br><span class=\"javascript\">                event.preventDefault();</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span>(</span><br><span class=\"javascript\">                  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                      名字:</span></span><br><span class=\"xml\"><span class=\"javascript\">                      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;this.state.value&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                     <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;submit&quot;</span>&gt;</span>提交<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></span>  </span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">NameForm</span> /&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;test1&#x27;</span>))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>以上例子实现了一个自定义表单的应用。</p>\n<p>注意：在Html中<code>&lt;textarea&gt;</code> 组件直接通过子元素定义其文本，而在React中通过属性value来确定其文本。针对<code>&lt;select&gt;</code>组件React 并不会使用 <code>selected</code> 属性，而是在根 <code>select</code> 标签上使用 <code>value</code> 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。</p>\n<p>具体关于textarea 和select在React里的具体操作如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//表单的运用</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//自定义表单组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NameForm</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props);</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//定义可更改的变量，即表单输入元素</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">textValue</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">selected</span>:<span class=\"hljs-string\">&#x27;aa&#x27;</span>,</span><br><span class=\"javascript\">                &#125;;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChange=<span class=\"hljs-built_in\">this</span>.handleChange.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleSubmit=<span class=\"hljs-built_in\">this</span>.handleSubmit.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChangeSelect=<span class=\"hljs-built_in\">this</span>.handleChangeSelect.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChangeTextarea=<span class=\"hljs-built_in\">this</span>.handleChangeTextarea.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChange</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;<span class=\"hljs-attr\">value</span>:event.target.value&#125;);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleSubmit</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//提交前显示名字</span></span><br><span class=\"javascript\">                alert(<span class=\"hljs-string\">&#x27;提交的名字：&#x27;</span>+<span class=\"hljs-built_in\">this</span>.state.value);</span><br><span class=\"javascript\">                event.preventDefault();</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChangeTextarea</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;<span class=\"hljs-attr\">textValue</span>:event.target.value&#125;)</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChangeSelect</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;event&#x27;</span>,event)</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;<span class=\"hljs-attr\">selected</span>:event.target.value&#125;);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span>(</span><br><span class=\"javascript\">                  &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class=\"javascript\">                    &lt;label&gt;</span><br><span class=\"javascript\">                      名字:</span><br><span class=\"javascript\">                      &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                     &lt;label&gt;</span><br><span class=\"javascript\">                         内容：</span><br><span class=\"javascript\">                         &lt;textarea  value=&#123;this.state.textValue&#125; onChange=&#123;this.handleChangeTextarea&#125;/&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                     &lt;label&gt;</span><br><span class=\"javascript\">                         选择：</span><br><span class=\"javascript\">                         &lt;select value=&#123;this.state.selected&#125; onChange=&#123;this.handleChangeSelect&#125; &gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;aa&#x27;&gt;aa&lt;/ option&gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;bb&#x27;&gt;bb&lt;/ option&gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;cc&#x27;&gt;cc&lt;/ option&gt;</span><br><span class=\"javascript\">                         &lt;/select&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                      &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"javascript\">                    &lt;/form&gt;  </span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(&lt;NameForm /&gt;,document.getElementById(&#x27;test1&#x27;))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>以上的形式在一个表单中调用了多个onChange，也可以只调用同一个onChange函数同时监听并改变多个数据，可以给每个元素添加 <code>name</code> 属性，并让处理函数根据 <code>event.target.name</code> 的值选择要执行的操作。具体代码如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//表单的运用</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//自定义表单组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NameForm</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props);</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//定义可更改的变量，即表单输入元素</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">nameValue</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">textValue</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">selected</span>:<span class=\"hljs-string\">&#x27;aa&#x27;</span>,</span><br><span class=\"javascript\">                &#125;;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChange=<span class=\"hljs-built_in\">this</span>.handleChange.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleSubmit=<span class=\"hljs-built_in\">this</span>.handleSubmit.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChange</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">const</span> value=event.target.value;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">const</span> name=event.target.name;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;</span><br><span class=\"javascript\">                    [name]:value</span><br><span class=\"javascript\">                &#125;)</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleSubmit</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//提交前显示名字</span></span><br><span class=\"javascript\">                alert(<span class=\"hljs-string\">&#x27;提交的名字：&#x27;</span>+<span class=\"hljs-built_in\">this</span>.state.value);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;state&#x27;</span>,<span class=\"hljs-built_in\">this</span>.state)</span><br><span class=\"javascript\">                event.preventDefault();</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span>(</span><br><span class=\"javascript\">                  &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class=\"javascript\">                    &lt;label&gt;</span><br><span class=\"javascript\">                      名字:</span><br><span class=\"javascript\">                      &lt;input name=&quot;nameValue&quot; type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                     &lt;label&gt;</span><br><span class=\"javascript\">                         内容：</span><br><span class=\"javascript\">                         &lt;textarea name=&quot;textValue&quot;  value=&#123;this.state.textValue&#125; onChange=&#123;this.handleChange&#125;/&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                     &lt;label&gt;</span><br><span class=\"javascript\">                         选择：</span><br><span class=\"javascript\">                         &lt;select name=&quot;selected&quot; value=&#123;this.state.selected&#125; onChange=&#123;this.handleChange&#125; &gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;aa&#x27;&gt;aa&lt;/ option&gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;bb&#x27;&gt;bb&lt;/ option&gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;cc&#x27;&gt;cc&lt;/ option&gt;</span><br><span class=\"javascript\">                         &lt;/select&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                      &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"javascript\">                    &lt;/form&gt;  </span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(&lt;NameForm /&gt;,document.getElementById(&#x27;test1&#x27;))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<h3 id=\"一、使用map来进行列表渲染\"><a href=\"#一、使用map来进行列表渲染\" class=\"headerlink\" title=\"一、使用map来进行列表渲染\"></a>一、使用map来进行列表渲染</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//通过map的方式渲染列表</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">List</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//获取列表参数</span></span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">const</span> numbers=props.numbers;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//利用map进行渲染</span></span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">const</span> listItem=numbers.map((<span class=\"hljs-function\"><span class=\"hljs-params\">number</span>=&gt;</span></span><br><span class=\"javascript\">            <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>&#123;number&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span>));</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"javascript\">              <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>&#123;listItem&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></span></span><br><span class=\"javascript\">            )</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-keyword\">const</span> numbers=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>];</span><br><span class=\"javascript\">        ReactDOM.render(</span><br><span class=\"javascript\">        <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">List</span> <span class=\"hljs-attr\">numbers</span>=<span class=\"hljs-string\">&#123;numbers&#125;</span> /&gt;</span></span>,</span><br><span class=\"javascript\">        <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;test1&#x27;</span>))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>运行以上代码，发现已成功渲染列表，但是在控制台获得警告如下：</p>\n<p><img src=\"/images/react/2021121903.png\"></p>\n<p>提示对于列表的每一个元素都需要key关键词，给每一列添加key:<code>&lt;li key=&#123;number.toString()&#125;&gt;&#123;number&#125;&lt;/li&gt;));</code>，key作为列表中每个元素的唯一标识符，是有优化性能的作用。对于应该在哪里设置元素的key，一个好的经验法则是：在 <code>map()</code> 方法中的元素需要设置 key 属性。</p>\n<p>以上情况可以也通过以下方法实现</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\">funtion <span class=\"hljs-function\"><span class=\"hljs-title\">ListItem</span>(<span class=\"hljs-params\">props</span>)</span>&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>&#123;props.value&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">List2</span>(<span class=\"hljs-params\">props</span>)</span>&#123;<br>    <span class=\"hljs-keyword\">const</span> numbers=props.numbers;<br>    <span class=\"hljs-keyword\">return</span> (<br>         <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span></span><br><span class=\"xml\">            &#123;numbers.map((number=&gt;</span><br><span class=\"xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ListItem</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#123;number.toString()&#125;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;number&#125;</span> /&gt;</span></span><br><span class=\"xml\">            ))&#125;</span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"二、表单\"><a href=\"#二、表单\" class=\"headerlink\" title=\"二、表单\"></a>二、表单</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//表单的运用</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//自定义表单组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NameForm</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props);</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//定义可更改的变量，即表单输入元素</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;<span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>&#125;;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChange=<span class=\"hljs-built_in\">this</span>.handleChange.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleSubmit=<span class=\"hljs-built_in\">this</span>.handleSubmit.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChange</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;<span class=\"hljs-attr\">value</span>:event.target.value&#125;);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleSubmit</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//提交前显示名字</span></span><br><span class=\"javascript\">                alert(<span class=\"hljs-string\">&#x27;提交的名字：&#x27;</span>+<span class=\"hljs-built_in\">this</span>.state.value);</span><br><span class=\"javascript\">                event.preventDefault();</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span>(</span><br><span class=\"javascript\">                  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                      名字:</span></span><br><span class=\"xml\"><span class=\"javascript\">                      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;this.state.value&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                     <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;submit&quot;</span>&gt;</span>提交<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></span>  </span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">NameForm</span> /&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;test1&#x27;</span>))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>以上例子实现了一个自定义表单的应用。</p>\n<p>注意：在Html中<code>&lt;textarea&gt;</code> 组件直接通过子元素定义其文本，而在React中通过属性value来确定其文本。针对<code>&lt;select&gt;</code>组件React 并不会使用 <code>selected</code> 属性，而是在根 <code>select</code> 标签上使用 <code>value</code> 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。</p>\n<p>具体关于textarea 和select在React里的具体操作如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//表单的运用</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//自定义表单组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NameForm</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props);</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//定义可更改的变量，即表单输入元素</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">textValue</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">selected</span>:<span class=\"hljs-string\">&#x27;aa&#x27;</span>,</span><br><span class=\"javascript\">                &#125;;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChange=<span class=\"hljs-built_in\">this</span>.handleChange.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleSubmit=<span class=\"hljs-built_in\">this</span>.handleSubmit.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChangeSelect=<span class=\"hljs-built_in\">this</span>.handleChangeSelect.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChangeTextarea=<span class=\"hljs-built_in\">this</span>.handleChangeTextarea.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChange</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;<span class=\"hljs-attr\">value</span>:event.target.value&#125;);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleSubmit</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//提交前显示名字</span></span><br><span class=\"javascript\">                alert(<span class=\"hljs-string\">&#x27;提交的名字：&#x27;</span>+<span class=\"hljs-built_in\">this</span>.state.value);</span><br><span class=\"javascript\">                event.preventDefault();</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChangeTextarea</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;<span class=\"hljs-attr\">textValue</span>:event.target.value&#125;)</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChangeSelect</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;event&#x27;</span>,event)</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;<span class=\"hljs-attr\">selected</span>:event.target.value&#125;);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span>(</span><br><span class=\"javascript\">                  &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class=\"javascript\">                    &lt;label&gt;</span><br><span class=\"javascript\">                      名字:</span><br><span class=\"javascript\">                      &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                     &lt;label&gt;</span><br><span class=\"javascript\">                         内容：</span><br><span class=\"javascript\">                         &lt;textarea  value=&#123;this.state.textValue&#125; onChange=&#123;this.handleChangeTextarea&#125;/&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                     &lt;label&gt;</span><br><span class=\"javascript\">                         选择：</span><br><span class=\"javascript\">                         &lt;select value=&#123;this.state.selected&#125; onChange=&#123;this.handleChangeSelect&#125; &gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;aa&#x27;&gt;aa&lt;/ option&gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;bb&#x27;&gt;bb&lt;/ option&gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;cc&#x27;&gt;cc&lt;/ option&gt;</span><br><span class=\"javascript\">                         &lt;/select&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                      &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"javascript\">                    &lt;/form&gt;  </span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(&lt;NameForm /&gt;,document.getElementById(&#x27;test1&#x27;))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>以上的形式在一个表单中调用了多个onChange，也可以只调用同一个onChange函数同时监听并改变多个数据，可以给每个元素添加 <code>name</code> 属性，并让处理函数根据 <code>event.target.name</code> 的值选择要执行的操作。具体代码如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//表单的运用</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//自定义表单组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NameForm</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props);</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//定义可更改的变量，即表单输入元素</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">nameValue</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">textValue</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">selected</span>:<span class=\"hljs-string\">&#x27;aa&#x27;</span>,</span><br><span class=\"javascript\">                &#125;;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChange=<span class=\"hljs-built_in\">this</span>.handleChange.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleSubmit=<span class=\"hljs-built_in\">this</span>.handleSubmit.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChange</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">const</span> value=event.target.value;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">const</span> name=event.target.name;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;</span><br><span class=\"javascript\">                    [name]:value</span><br><span class=\"javascript\">                &#125;)</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleSubmit</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//提交前显示名字</span></span><br><span class=\"javascript\">                alert(<span class=\"hljs-string\">&#x27;提交的名字：&#x27;</span>+<span class=\"hljs-built_in\">this</span>.state.value);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;state&#x27;</span>,<span class=\"hljs-built_in\">this</span>.state)</span><br><span class=\"javascript\">                event.preventDefault();</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span>(</span><br><span class=\"javascript\">                  &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class=\"javascript\">                    &lt;label&gt;</span><br><span class=\"javascript\">                      名字:</span><br><span class=\"javascript\">                      &lt;input name=&quot;nameValue&quot; type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                     &lt;label&gt;</span><br><span class=\"javascript\">                         内容：</span><br><span class=\"javascript\">                         &lt;textarea name=&quot;textValue&quot;  value=&#123;this.state.textValue&#125; onChange=&#123;this.handleChange&#125;/&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                     &lt;label&gt;</span><br><span class=\"javascript\">                         选择：</span><br><span class=\"javascript\">                         &lt;select name=&quot;selected&quot; value=&#123;this.state.selected&#125; onChange=&#123;this.handleChange&#125; &gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;aa&#x27;&gt;aa&lt;/ option&gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;bb&#x27;&gt;bb&lt;/ option&gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;cc&#x27;&gt;cc&lt;/ option&gt;</span><br><span class=\"javascript\">                         &lt;/select&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                      &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"javascript\">                    &lt;/form&gt;  </span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(&lt;NameForm /&gt;,document.getElementById(&#x27;test1&#x27;))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n"},{"title":"Git相关知识点","date":"2021-12-21T03:07:51.000Z","_content":"\n------\n\n*本文来源于https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过*。\n\n------\n\n## 1.集中式与分布式\n\nGit属于<u>分布式版本控制系统</u>，分布式的好处是每个成员的电脑上都有一份完整代码，而<u>集中式</u>的只有中心服务器才有。并且集中式版本控制系统一旦中心服务器出问题所有成员都无法使用，还必须依赖连网使用，分布式则不存在这些问题。分布式版本控制建立新分支、合并分支操作迅速，集中式新建一个分支相当于复制一份完整代码，操作较慢。\n\n## 2.中心服务器\n\nGit的中心服务器是<u>GitHub</u>。中心服务器用来交换成员的修改。\n\n## 3.工作流\n\n新建一个目录并且Git初始化后，该目录就成为一个工作仓库。该工作区有一个`.git`文件夹，它是Git的版本库。Git 的版本库有一个称为 `Stage` 的暂存区以及最后的 `History` 版本库，`History` 存储所有分支信息，使用一个 `HEAD` 指针指向当前分支。\n\n具体工作流如下图所示：\n\n![](/images/react/2021122111.png)\n\n执行命令`git add files` 将仓库内的文件存入`Stage`缓存区，执行`git commit`命令将这些存在`Stage`的文件数据存入`History`区，此时`Stage`也被清空。执行命令`git reset --files`使用当前分支上的修改覆盖暂存区，用来撤销最后一次 `git add files`，执行命令`git checkout --file` 使用暂存区的修改覆盖工作目录，用来撤销本地修改。\n\n## 4.分支实现和冲突\n\n`HEAD`指针总是指向当前分支指针，在新建分支时，新建的分支指针会指向当前节点，并且`HEAD`指针指向新分支指针。每次提交只有当前分支指针会改变。\n\n如果两个分支都进行了修改，当它们合并时会产生冲突，必须删除冲突才能进行合并。\n\n## 5.SSH传输设置\n\nGit 仓库和 Github 中心仓库之间的传输是通过 SSH 加密。\n\n本地设置SSH Key可以通过命令`ssh-keygen -t rsa -C \"youremail@example.com\"`来实现。其中出现在`.ssh`目录的`id_rsa.pub`里的数据就是SSH的公钥。\n\n## 6.储存\n\n在一个分支操作后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也会有修改内容，这是所有分支公用一个工作区的缘故。可以使用命令`git stash`将当前分支的修改存储起来，此时当前工作区的所有修改都会被存到栈中，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了。\n\n## 7.Git常用命令\n\n**初始化操作**\n\n`git init` 设置本地目录为新的Git仓库\n\n`git clone [url]` 克隆一个代码仓库\n\n**增加文件操作**\n\n`git add [file1] [file2]` 增加file1、file2到暂存区\n\n`git add .` 将当前目录下全部文件存入暂存区。\n\n**删除文件操作**\n\n`git rm [file1] [file2]` 删除指定文件，并在暂存区中也删除\n\n**代码提交操作**\n\n`git commit -m [message]` 提交暂存区到仓库区（History），并备注消息\n\n`git commit -a` 直接从暂存区提交进仓库区\n\n**分支相关操作**\n\n`git branch` 列出所有本地分支\n\n`git branch -r` 列出所有远程分支\n\n`git branch -a` 列出所有分支，包括本地分支和远程分支。\n\n`git branch [branch]` 新建分支\n\n`git checkout [branch-name]` 切换到指定的分支进行工作\n\n`git merge [branch]` 合并指定分支到当前分支\n\n`git branch -d [branch-name]` 删除指定的本地分支\n\n`git push origin --delete [branch-name]` 删除远程分支\n\n`git branch -dr [remote/branch]` 删除远程分支\n\n**查看信息操作**\n\n`git status` 显示有变更文件\n\n`git log` 显示当前分支的版本历史\n\n**远程同步操作**\n\n`git remote -v` 显示所有的远程仓库\n\n`git remote show [remote]` 显示某个远程仓库信息\n\n`git remote add [remote]` 新增某个远程仓库\n\n`git pull [remote] [branch]` 从远程仓库的某一分支拉取到本地\n\n`git push [remote] [branch]` 上传本地指定分支到远程仓库\n\n`git push -f [remote] [branch]` 强制推送当前分支到远程仓库，即使有冲突\n\n`git push [remote] --all` 推送所有分支到远程仓库\n\n**撤销操作**\n\n`git checkout [commit] [file]` 恢复某个commit的指定文件到暂存区和工作区\n\n`git reset --hard` 重置暂存区与工作区，与上一次commit保持一致\n\n`git reset [commit]` 重置当前分支指针为指定commit，同时重置暂存区，但工作区不变\n\n`git reset --hard [commit]` 重置当前HEAD为指定commit，同时重置暂存区与工作区。","source":"_posts/Git.md","raw":"---\ntitle: Git相关知识点\ndate: 2021-12-21 11:07:51\ntags: [学习,前端面试，Git]\ncategories:\n- 计算机基础复习\n---\n\n------\n\n*本文来源于https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过*。\n\n------\n\n## 1.集中式与分布式\n\nGit属于<u>分布式版本控制系统</u>，分布式的好处是每个成员的电脑上都有一份完整代码，而<u>集中式</u>的只有中心服务器才有。并且集中式版本控制系统一旦中心服务器出问题所有成员都无法使用，还必须依赖连网使用，分布式则不存在这些问题。分布式版本控制建立新分支、合并分支操作迅速，集中式新建一个分支相当于复制一份完整代码，操作较慢。\n\n## 2.中心服务器\n\nGit的中心服务器是<u>GitHub</u>。中心服务器用来交换成员的修改。\n\n## 3.工作流\n\n新建一个目录并且Git初始化后，该目录就成为一个工作仓库。该工作区有一个`.git`文件夹，它是Git的版本库。Git 的版本库有一个称为 `Stage` 的暂存区以及最后的 `History` 版本库，`History` 存储所有分支信息，使用一个 `HEAD` 指针指向当前分支。\n\n具体工作流如下图所示：\n\n![](/images/react/2021122111.png)\n\n执行命令`git add files` 将仓库内的文件存入`Stage`缓存区，执行`git commit`命令将这些存在`Stage`的文件数据存入`History`区，此时`Stage`也被清空。执行命令`git reset --files`使用当前分支上的修改覆盖暂存区，用来撤销最后一次 `git add files`，执行命令`git checkout --file` 使用暂存区的修改覆盖工作目录，用来撤销本地修改。\n\n## 4.分支实现和冲突\n\n`HEAD`指针总是指向当前分支指针，在新建分支时，新建的分支指针会指向当前节点，并且`HEAD`指针指向新分支指针。每次提交只有当前分支指针会改变。\n\n如果两个分支都进行了修改，当它们合并时会产生冲突，必须删除冲突才能进行合并。\n\n## 5.SSH传输设置\n\nGit 仓库和 Github 中心仓库之间的传输是通过 SSH 加密。\n\n本地设置SSH Key可以通过命令`ssh-keygen -t rsa -C \"youremail@example.com\"`来实现。其中出现在`.ssh`目录的`id_rsa.pub`里的数据就是SSH的公钥。\n\n## 6.储存\n\n在一个分支操作后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也会有修改内容，这是所有分支公用一个工作区的缘故。可以使用命令`git stash`将当前分支的修改存储起来，此时当前工作区的所有修改都会被存到栈中，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了。\n\n## 7.Git常用命令\n\n**初始化操作**\n\n`git init` 设置本地目录为新的Git仓库\n\n`git clone [url]` 克隆一个代码仓库\n\n**增加文件操作**\n\n`git add [file1] [file2]` 增加file1、file2到暂存区\n\n`git add .` 将当前目录下全部文件存入暂存区。\n\n**删除文件操作**\n\n`git rm [file1] [file2]` 删除指定文件，并在暂存区中也删除\n\n**代码提交操作**\n\n`git commit -m [message]` 提交暂存区到仓库区（History），并备注消息\n\n`git commit -a` 直接从暂存区提交进仓库区\n\n**分支相关操作**\n\n`git branch` 列出所有本地分支\n\n`git branch -r` 列出所有远程分支\n\n`git branch -a` 列出所有分支，包括本地分支和远程分支。\n\n`git branch [branch]` 新建分支\n\n`git checkout [branch-name]` 切换到指定的分支进行工作\n\n`git merge [branch]` 合并指定分支到当前分支\n\n`git branch -d [branch-name]` 删除指定的本地分支\n\n`git push origin --delete [branch-name]` 删除远程分支\n\n`git branch -dr [remote/branch]` 删除远程分支\n\n**查看信息操作**\n\n`git status` 显示有变更文件\n\n`git log` 显示当前分支的版本历史\n\n**远程同步操作**\n\n`git remote -v` 显示所有的远程仓库\n\n`git remote show [remote]` 显示某个远程仓库信息\n\n`git remote add [remote]` 新增某个远程仓库\n\n`git pull [remote] [branch]` 从远程仓库的某一分支拉取到本地\n\n`git push [remote] [branch]` 上传本地指定分支到远程仓库\n\n`git push -f [remote] [branch]` 强制推送当前分支到远程仓库，即使有冲突\n\n`git push [remote] --all` 推送所有分支到远程仓库\n\n**撤销操作**\n\n`git checkout [commit] [file]` 恢复某个commit的指定文件到暂存区和工作区\n\n`git reset --hard` 重置暂存区与工作区，与上一次commit保持一致\n\n`git reset [commit]` 重置当前分支指针为指定commit，同时重置暂存区，但工作区不变\n\n`git reset --hard [commit]` 重置当前HEAD为指定commit，同时重置暂存区与工作区。","slug":"Git","published":1,"updated":"2021-12-21T12:24:14.901Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh0w00096wtv2k9x39vf","content":"<hr>\n<p><em>本文来源于<a href=\"https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82%E5%B9%B6%E4%B8%94%E5%9B%A0%E4%B8%BA%E6%9C%AC%E6%AC%A1%E5%A4%8D%E4%B9%A0%E6%98%AF%E4%BA%89%E5%AF%B9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E4%BC%9A%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%88%BB%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%AA%E4%BC%9A%E7%B2%97%E7%95%A5%E6%89%AB%E8%BF%87\">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过</a></em>。</p>\n<hr>\n<h2 id=\"1-集中式与分布式\"><a href=\"#1-集中式与分布式\" class=\"headerlink\" title=\"1.集中式与分布式\"></a>1.集中式与分布式</h2><p>Git属于<u>分布式版本控制系统</u>，分布式的好处是每个成员的电脑上都有一份完整代码，而<u>集中式</u>的只有中心服务器才有。并且集中式版本控制系统一旦中心服务器出问题所有成员都无法使用，还必须依赖连网使用，分布式则不存在这些问题。分布式版本控制建立新分支、合并分支操作迅速，集中式新建一个分支相当于复制一份完整代码，操作较慢。</p>\n<h2 id=\"2-中心服务器\"><a href=\"#2-中心服务器\" class=\"headerlink\" title=\"2.中心服务器\"></a>2.中心服务器</h2><p>Git的中心服务器是<u>GitHub</u>。中心服务器用来交换成员的修改。</p>\n<h2 id=\"3-工作流\"><a href=\"#3-工作流\" class=\"headerlink\" title=\"3.工作流\"></a>3.工作流</h2><p>新建一个目录并且Git初始化后，该目录就成为一个工作仓库。该工作区有一个<code>.git</code>文件夹，它是Git的版本库。Git 的版本库有一个称为 <code>Stage</code> 的暂存区以及最后的 <code>History</code> 版本库，<code>History</code> 存储所有分支信息，使用一个 <code>HEAD</code> 指针指向当前分支。</p>\n<p>具体工作流如下图所示：</p>\n<p><img src=\"/images/react/2021122111.png\"></p>\n<p>执行命令<code>git add files</code> 将仓库内的文件存入<code>Stage</code>缓存区，执行<code>git commit</code>命令将这些存在<code>Stage</code>的文件数据存入<code>History</code>区，此时<code>Stage</code>也被清空。执行命令<code>git reset --files</code>使用当前分支上的修改覆盖暂存区，用来撤销最后一次 <code>git add files</code>，执行命令<code>git checkout --file</code> 使用暂存区的修改覆盖工作目录，用来撤销本地修改。</p>\n<h2 id=\"4-分支实现和冲突\"><a href=\"#4-分支实现和冲突\" class=\"headerlink\" title=\"4.分支实现和冲突\"></a>4.分支实现和冲突</h2><p><code>HEAD</code>指针总是指向当前分支指针，在新建分支时，新建的分支指针会指向当前节点，并且<code>HEAD</code>指针指向新分支指针。每次提交只有当前分支指针会改变。</p>\n<p>如果两个分支都进行了修改，当它们合并时会产生冲突，必须删除冲突才能进行合并。</p>\n<h2 id=\"5-SSH传输设置\"><a href=\"#5-SSH传输设置\" class=\"headerlink\" title=\"5.SSH传输设置\"></a>5.SSH传输设置</h2><p>Git 仓库和 Github 中心仓库之间的传输是通过 SSH 加密。</p>\n<p>本地设置SSH Key可以通过命令<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code>来实现。其中出现在<code>.ssh</code>目录的<code>id_rsa.pub</code>里的数据就是SSH的公钥。</p>\n<h2 id=\"6-储存\"><a href=\"#6-储存\" class=\"headerlink\" title=\"6.储存\"></a>6.储存</h2><p>在一个分支操作后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也会有修改内容，这是所有分支公用一个工作区的缘故。可以使用命令<code>git stash</code>将当前分支的修改存储起来，此时当前工作区的所有修改都会被存到栈中，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了。</p>\n<h2 id=\"7-Git常用命令\"><a href=\"#7-Git常用命令\" class=\"headerlink\" title=\"7.Git常用命令\"></a>7.Git常用命令</h2><p><strong>初始化操作</strong></p>\n<p><code>git init</code> 设置本地目录为新的Git仓库</p>\n<p><code>git clone [url]</code> 克隆一个代码仓库</p>\n<p><strong>增加文件操作</strong></p>\n<p><code>git add [file1] [file2]</code> 增加file1、file2到暂存区</p>\n<p><code>git add .</code> 将当前目录下全部文件存入暂存区。</p>\n<p><strong>删除文件操作</strong></p>\n<p><code>git rm [file1] [file2]</code> 删除指定文件，并在暂存区中也删除</p>\n<p><strong>代码提交操作</strong></p>\n<p><code>git commit -m [message]</code> 提交暂存区到仓库区（History），并备注消息</p>\n<p><code>git commit -a</code> 直接从暂存区提交进仓库区</p>\n<p><strong>分支相关操作</strong></p>\n<p><code>git branch</code> 列出所有本地分支</p>\n<p><code>git branch -r</code> 列出所有远程分支</p>\n<p><code>git branch -a</code> 列出所有分支，包括本地分支和远程分支。</p>\n<p><code>git branch [branch]</code> 新建分支</p>\n<p><code>git checkout [branch-name]</code> 切换到指定的分支进行工作</p>\n<p><code>git merge [branch]</code> 合并指定分支到当前分支</p>\n<p><code>git branch -d [branch-name]</code> 删除指定的本地分支</p>\n<p><code>git push origin --delete [branch-name]</code> 删除远程分支</p>\n<p><code>git branch -dr [remote/branch]</code> 删除远程分支</p>\n<p><strong>查看信息操作</strong></p>\n<p><code>git status</code> 显示有变更文件</p>\n<p><code>git log</code> 显示当前分支的版本历史</p>\n<p><strong>远程同步操作</strong></p>\n<p><code>git remote -v</code> 显示所有的远程仓库</p>\n<p><code>git remote show [remote]</code> 显示某个远程仓库信息</p>\n<p><code>git remote add [remote]</code> 新增某个远程仓库</p>\n<p><code>git pull [remote] [branch]</code> 从远程仓库的某一分支拉取到本地</p>\n<p><code>git push [remote] [branch]</code> 上传本地指定分支到远程仓库</p>\n<p><code>git push -f [remote] [branch]</code> 强制推送当前分支到远程仓库，即使有冲突</p>\n<p><code>git push [remote] --all</code> 推送所有分支到远程仓库</p>\n<p><strong>撤销操作</strong></p>\n<p><code>git checkout [commit] [file]</code> 恢复某个commit的指定文件到暂存区和工作区</p>\n<p><code>git reset --hard</code> 重置暂存区与工作区，与上一次commit保持一致</p>\n<p><code>git reset [commit]</code> 重置当前分支指针为指定commit，同时重置暂存区，但工作区不变</p>\n<p><code>git reset --hard [commit]</code> 重置当前HEAD为指定commit，同时重置暂存区与工作区。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>本文来源于<a href=\"https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82%E5%B9%B6%E4%B8%94%E5%9B%A0%E4%B8%BA%E6%9C%AC%E6%AC%A1%E5%A4%8D%E4%B9%A0%E6%98%AF%E4%BA%89%E5%AF%B9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E4%BC%9A%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%88%BB%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%AA%E4%BC%9A%E7%B2%97%E7%95%A5%E6%89%AB%E8%BF%87\">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过</a></em>。</p>\n<hr>\n<h2 id=\"1-集中式与分布式\"><a href=\"#1-集中式与分布式\" class=\"headerlink\" title=\"1.集中式与分布式\"></a>1.集中式与分布式</h2><p>Git属于<u>分布式版本控制系统</u>，分布式的好处是每个成员的电脑上都有一份完整代码，而<u>集中式</u>的只有中心服务器才有。并且集中式版本控制系统一旦中心服务器出问题所有成员都无法使用，还必须依赖连网使用，分布式则不存在这些问题。分布式版本控制建立新分支、合并分支操作迅速，集中式新建一个分支相当于复制一份完整代码，操作较慢。</p>\n<h2 id=\"2-中心服务器\"><a href=\"#2-中心服务器\" class=\"headerlink\" title=\"2.中心服务器\"></a>2.中心服务器</h2><p>Git的中心服务器是<u>GitHub</u>。中心服务器用来交换成员的修改。</p>\n<h2 id=\"3-工作流\"><a href=\"#3-工作流\" class=\"headerlink\" title=\"3.工作流\"></a>3.工作流</h2><p>新建一个目录并且Git初始化后，该目录就成为一个工作仓库。该工作区有一个<code>.git</code>文件夹，它是Git的版本库。Git 的版本库有一个称为 <code>Stage</code> 的暂存区以及最后的 <code>History</code> 版本库，<code>History</code> 存储所有分支信息，使用一个 <code>HEAD</code> 指针指向当前分支。</p>\n<p>具体工作流如下图所示：</p>\n<p><img src=\"/images/react/2021122111.png\"></p>\n<p>执行命令<code>git add files</code> 将仓库内的文件存入<code>Stage</code>缓存区，执行<code>git commit</code>命令将这些存在<code>Stage</code>的文件数据存入<code>History</code>区，此时<code>Stage</code>也被清空。执行命令<code>git reset --files</code>使用当前分支上的修改覆盖暂存区，用来撤销最后一次 <code>git add files</code>，执行命令<code>git checkout --file</code> 使用暂存区的修改覆盖工作目录，用来撤销本地修改。</p>\n<h2 id=\"4-分支实现和冲突\"><a href=\"#4-分支实现和冲突\" class=\"headerlink\" title=\"4.分支实现和冲突\"></a>4.分支实现和冲突</h2><p><code>HEAD</code>指针总是指向当前分支指针，在新建分支时，新建的分支指针会指向当前节点，并且<code>HEAD</code>指针指向新分支指针。每次提交只有当前分支指针会改变。</p>\n<p>如果两个分支都进行了修改，当它们合并时会产生冲突，必须删除冲突才能进行合并。</p>\n<h2 id=\"5-SSH传输设置\"><a href=\"#5-SSH传输设置\" class=\"headerlink\" title=\"5.SSH传输设置\"></a>5.SSH传输设置</h2><p>Git 仓库和 Github 中心仓库之间的传输是通过 SSH 加密。</p>\n<p>本地设置SSH Key可以通过命令<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code>来实现。其中出现在<code>.ssh</code>目录的<code>id_rsa.pub</code>里的数据就是SSH的公钥。</p>\n<h2 id=\"6-储存\"><a href=\"#6-储存\" class=\"headerlink\" title=\"6.储存\"></a>6.储存</h2><p>在一个分支操作后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也会有修改内容，这是所有分支公用一个工作区的缘故。可以使用命令<code>git stash</code>将当前分支的修改存储起来，此时当前工作区的所有修改都会被存到栈中，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了。</p>\n<h2 id=\"7-Git常用命令\"><a href=\"#7-Git常用命令\" class=\"headerlink\" title=\"7.Git常用命令\"></a>7.Git常用命令</h2><p><strong>初始化操作</strong></p>\n<p><code>git init</code> 设置本地目录为新的Git仓库</p>\n<p><code>git clone [url]</code> 克隆一个代码仓库</p>\n<p><strong>增加文件操作</strong></p>\n<p><code>git add [file1] [file2]</code> 增加file1、file2到暂存区</p>\n<p><code>git add .</code> 将当前目录下全部文件存入暂存区。</p>\n<p><strong>删除文件操作</strong></p>\n<p><code>git rm [file1] [file2]</code> 删除指定文件，并在暂存区中也删除</p>\n<p><strong>代码提交操作</strong></p>\n<p><code>git commit -m [message]</code> 提交暂存区到仓库区（History），并备注消息</p>\n<p><code>git commit -a</code> 直接从暂存区提交进仓库区</p>\n<p><strong>分支相关操作</strong></p>\n<p><code>git branch</code> 列出所有本地分支</p>\n<p><code>git branch -r</code> 列出所有远程分支</p>\n<p><code>git branch -a</code> 列出所有分支，包括本地分支和远程分支。</p>\n<p><code>git branch [branch]</code> 新建分支</p>\n<p><code>git checkout [branch-name]</code> 切换到指定的分支进行工作</p>\n<p><code>git merge [branch]</code> 合并指定分支到当前分支</p>\n<p><code>git branch -d [branch-name]</code> 删除指定的本地分支</p>\n<p><code>git push origin --delete [branch-name]</code> 删除远程分支</p>\n<p><code>git branch -dr [remote/branch]</code> 删除远程分支</p>\n<p><strong>查看信息操作</strong></p>\n<p><code>git status</code> 显示有变更文件</p>\n<p><code>git log</code> 显示当前分支的版本历史</p>\n<p><strong>远程同步操作</strong></p>\n<p><code>git remote -v</code> 显示所有的远程仓库</p>\n<p><code>git remote show [remote]</code> 显示某个远程仓库信息</p>\n<p><code>git remote add [remote]</code> 新增某个远程仓库</p>\n<p><code>git pull [remote] [branch]</code> 从远程仓库的某一分支拉取到本地</p>\n<p><code>git push [remote] [branch]</code> 上传本地指定分支到远程仓库</p>\n<p><code>git push -f [remote] [branch]</code> 强制推送当前分支到远程仓库，即使有冲突</p>\n<p><code>git push [remote] --all</code> 推送所有分支到远程仓库</p>\n<p><strong>撤销操作</strong></p>\n<p><code>git checkout [commit] [file]</code> 恢复某个commit的指定文件到暂存区和工作区</p>\n<p><code>git reset --hard</code> 重置暂存区与工作区，与上一次commit保持一致</p>\n<p><code>git reset [commit]</code> 重置当前分支指针为指定commit，同时重置暂存区，但工作区不变</p>\n<p><code>git reset --hard [commit]</code> 重置当前HEAD为指定commit，同时重置暂存区与工作区。</p>\n"},{"title":"React的数据更新和监听事件","date":"2021-12-19T01:19:01.000Z","_content":"\n### 一、使用state实现更新React组件数据\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <!-- 上面两个Js文件是有固定的引用先后顺序 -->\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        // 使用state实现更新React组件数据\n\n        // 利用class定义自定义组件\n        class Clock extends React.Component{\n            //调用父类构造器\n            constructor(props) {\n                super(props);\n                //定义state内的数据\n                this.state={data:new Date()};\n            }\n\n            //生命周期函数：挂载完成时，每一秒调用tick函数，即每一秒改变stata内data的数据。\n            componentDidMount(){\n                this.timeID=setInterval(\n                ()=>this.tick(),1000\n                )\n            }\n            //生命周期函数：即将卸载时\n            componentWillUnmount(){\n                clearInterval(this.timeID);\n            }\n\n            tick(){\n                this.setState({\n                    data:new Date()\n                });\n            }\n            render(){\n                return (\n                    <div>\n                        <div>hello!!</div>\n                        <h5>It is {this.state.data.toLocaleTimeString()} .</h5>\n                    </div>\n                )\n            }\n        }\n        ReactDOM.render(<Clock />,document.getElementById(\"test1\"))\n    </script>\n</html>\n```\n\n以上为一个时钟渲染实例，通过state和生命周期的使用来实时完成时钟的运行。\n\n构造函数是唯一可以给 `this.state` 赋值的地方，使用 `setState()`修改state里的数据\n\n出于性能考虑，React 可能会把多个 `setState()` 调用合并成一个调用，因为 `this.props` 和 `this.state` 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。\n\n### 二、监听事件\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <!-- 上面两个Js文件是有固定的引用先后顺序 -->\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //监听事件\n        //实时切换一个按钮的状态\n\n        //定义一个按钮组件\n        class Button1 extends React.Component{\n            //因为设计到React.Component里的一些特性，所以需要构造器继承父类构造器\n            constructor(props) {\n                super(props);\n                //state里的数据可以更新修改，相当于Vue里的data\n                this.state={\n                    isToggleOn:true,\n                    data1:'haha',\n                }\n\n                //为了在该类的方法中调用this.setState来改变state里的数据来实现实时监听，所以，要在构造器里提前将需要的方法绑定this\n                this.handleClick=this.handleClick.bind(this)\n            }\n\n            //该方法来实现实时切换\n            //若前面没有绑定this，则该方法里的this指向underfined\n            //prevState是state原先的状态\n            //这里的=>({...})等价于=>{return ({...})}\n            handleClick(){\n                this.setState(prevState=>({\n                    isToggleOn:!prevState.isToggleOn\n                }))\n            }\n\n            // 下面的方法显示打印出prevState的数据\n            // handleClick(){\n            //     this.setState(prevState=>{\n            //         console.log('prevState',prevState)\n            //         return ({\n            //             isToggleOn:!prevState.isToggleOn\n            //         })\n            //     })\n            // }\n\n            render(){\n                return (\n                    <button onClick={this.handleClick}>\n                        {this.state.isToggleOn?'ON':'OFF'}\n                    </button>\n                )\n            }\n        }\n\n        ReactDOM.render(<Button1 />,document.getElementById(\"test1\"))\n\n        </script>\n</html>\n```\n\n以上例子实现了实时监控切换一个按钮状态。\n\n在 React 中另一个不同点是你不能通过返回 `false` 的方式阻止默认行为。你必须显式的使用 `preventDefault`。\n\n### 三、条件渲染\n\n可以通过以下方法自定义元素。\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <!-- 上面两个Js文件是有固定的引用先后顺序 -->\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //条件渲染\n\n        //用函数定义的方式实现子组件的定义\n        function SonDiv(props){\n            //若isShow=false,则返回null，即该组件不会渲染，会被隐藏\n            if(!props.isShow){\n                return null;\n            }\n            return (\n                <div>Son is Show</div>\n            )\n        }\n\n        //用类的方式实现父组件的定义\n        class FatherDiv extends React.Component{\n            constructor(props) {\n                super(props)\n                this.state={isShow:true}\n                this.handleToggleChilk=this.handleToggleChilk.bind(this)\n\n            }\n            handleToggleChilk(){\n                this.setState(prevState=>({\n                    isShow:!prevState.isShow\n                }))\n            }\n\n            render(){\n                return (\n                    <div>\n                        <SonDiv isShow={this.state.isShow} />\n                        <button onClick={this.handleToggleChilk}>\n                            {this.state.isShow?'hide':'show'}\n                        </button>\n                    </div>\n                )\n            }\n        }\n\n        ReactDOM.render(<FatherDiv />,document.getElementById(\"test1\"))\n\n        </script>\n</html>\n```\n\n以上案例实现了一个监控+条件渲染的案例，初始状态为：\n\n![](/images/react/2021121901.png)\n\n点击按钮'hide'，则会隐藏子组件并且按钮内容改为'show'，点击'show'则会回到初始状态即显示子组件。","source":"_posts/React学习二.md","raw":"---\ntitle: React的数据更新和监听事件\ndate: 2021-12-19 09:19:01\ntags: [React, 学习]\ncategories:\n- React\n---\n\n### 一、使用state实现更新React组件数据\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <!-- 上面两个Js文件是有固定的引用先后顺序 -->\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        // 使用state实现更新React组件数据\n\n        // 利用class定义自定义组件\n        class Clock extends React.Component{\n            //调用父类构造器\n            constructor(props) {\n                super(props);\n                //定义state内的数据\n                this.state={data:new Date()};\n            }\n\n            //生命周期函数：挂载完成时，每一秒调用tick函数，即每一秒改变stata内data的数据。\n            componentDidMount(){\n                this.timeID=setInterval(\n                ()=>this.tick(),1000\n                )\n            }\n            //生命周期函数：即将卸载时\n            componentWillUnmount(){\n                clearInterval(this.timeID);\n            }\n\n            tick(){\n                this.setState({\n                    data:new Date()\n                });\n            }\n            render(){\n                return (\n                    <div>\n                        <div>hello!!</div>\n                        <h5>It is {this.state.data.toLocaleTimeString()} .</h5>\n                    </div>\n                )\n            }\n        }\n        ReactDOM.render(<Clock />,document.getElementById(\"test1\"))\n    </script>\n</html>\n```\n\n以上为一个时钟渲染实例，通过state和生命周期的使用来实时完成时钟的运行。\n\n构造函数是唯一可以给 `this.state` 赋值的地方，使用 `setState()`修改state里的数据\n\n出于性能考虑，React 可能会把多个 `setState()` 调用合并成一个调用，因为 `this.props` 和 `this.state` 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。\n\n### 二、监听事件\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <!-- 上面两个Js文件是有固定的引用先后顺序 -->\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //监听事件\n        //实时切换一个按钮的状态\n\n        //定义一个按钮组件\n        class Button1 extends React.Component{\n            //因为设计到React.Component里的一些特性，所以需要构造器继承父类构造器\n            constructor(props) {\n                super(props);\n                //state里的数据可以更新修改，相当于Vue里的data\n                this.state={\n                    isToggleOn:true,\n                    data1:'haha',\n                }\n\n                //为了在该类的方法中调用this.setState来改变state里的数据来实现实时监听，所以，要在构造器里提前将需要的方法绑定this\n                this.handleClick=this.handleClick.bind(this)\n            }\n\n            //该方法来实现实时切换\n            //若前面没有绑定this，则该方法里的this指向underfined\n            //prevState是state原先的状态\n            //这里的=>({...})等价于=>{return ({...})}\n            handleClick(){\n                this.setState(prevState=>({\n                    isToggleOn:!prevState.isToggleOn\n                }))\n            }\n\n            // 下面的方法显示打印出prevState的数据\n            // handleClick(){\n            //     this.setState(prevState=>{\n            //         console.log('prevState',prevState)\n            //         return ({\n            //             isToggleOn:!prevState.isToggleOn\n            //         })\n            //     })\n            // }\n\n            render(){\n                return (\n                    <button onClick={this.handleClick}>\n                        {this.state.isToggleOn?'ON':'OFF'}\n                    </button>\n                )\n            }\n        }\n\n        ReactDOM.render(<Button1 />,document.getElementById(\"test1\"))\n\n        </script>\n</html>\n```\n\n以上例子实现了实时监控切换一个按钮状态。\n\n在 React 中另一个不同点是你不能通过返回 `false` 的方式阻止默认行为。你必须显式的使用 `preventDefault`。\n\n### 三、条件渲染\n\n可以通过以下方法自定义元素。\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <!-- 上面两个Js文件是有固定的引用先后顺序 -->\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //条件渲染\n\n        //用函数定义的方式实现子组件的定义\n        function SonDiv(props){\n            //若isShow=false,则返回null，即该组件不会渲染，会被隐藏\n            if(!props.isShow){\n                return null;\n            }\n            return (\n                <div>Son is Show</div>\n            )\n        }\n\n        //用类的方式实现父组件的定义\n        class FatherDiv extends React.Component{\n            constructor(props) {\n                super(props)\n                this.state={isShow:true}\n                this.handleToggleChilk=this.handleToggleChilk.bind(this)\n\n            }\n            handleToggleChilk(){\n                this.setState(prevState=>({\n                    isShow:!prevState.isShow\n                }))\n            }\n\n            render(){\n                return (\n                    <div>\n                        <SonDiv isShow={this.state.isShow} />\n                        <button onClick={this.handleToggleChilk}>\n                            {this.state.isShow?'hide':'show'}\n                        </button>\n                    </div>\n                )\n            }\n        }\n\n        ReactDOM.render(<FatherDiv />,document.getElementById(\"test1\"))\n\n        </script>\n</html>\n```\n\n以上案例实现了一个监控+条件渲染的案例，初始状态为：\n\n![](/images/react/2021121901.png)\n\n点击按钮'hide'，则会隐藏子组件并且按钮内容改为'show'，点击'show'则会回到初始状态即显示子组件。","slug":"React学习二","published":1,"updated":"2022-03-11T03:33:27.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh0y000b6wtvhhirhhfc","content":"<h3 id=\"一、使用state实现更新React组件数据\"><a href=\"#一、使用state实现更新React组件数据\" class=\"headerlink\" title=\"一、使用state实现更新React组件数据\"></a>一、使用state实现更新React组件数据</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!-- 上面两个Js文件是有固定的引用先后顺序 --&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">// 使用state实现更新React组件数据</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">// 利用class定义自定义组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Clock</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//调用父类构造器</span></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props);</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//定义state内的数据</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;<span class=\"hljs-attr\">data</span>:<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()&#125;;</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//生命周期函数：挂载完成时，每一秒调用tick函数，即每一秒改变stata内data的数据。</span></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.timeID=<span class=\"hljs-built_in\">setInterval</span>(</span><br><span class=\"javascript\">                <span class=\"hljs-function\">()=&gt;</span><span class=\"hljs-built_in\">this</span>.tick(),<span class=\"hljs-number\">1000</span></span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//生命周期函数：即将卸载时</span></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">componentWillUnmount</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">clearInterval</span>(<span class=\"hljs-built_in\">this</span>.timeID);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">tick</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">data</span>:<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()</span><br><span class=\"javascript\">                &#125;);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"javascript\">                    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>hello!!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h5</span>&gt;</span>It is &#123;this.state.data.toLocaleTimeString()&#125; .<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h5</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Clock</span> /&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;test1&quot;</span>))</span><br><span class=\"javascript\">    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>以上为一个时钟渲染实例，通过state和生命周期的使用来实时完成时钟的运行。</p>\n<p>构造函数是唯一可以给 <code>this.state</code> 赋值的地方，使用 <code>setState()</code>修改state里的数据</p>\n<p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用，因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p>\n<h3 id=\"二、监听事件\"><a href=\"#二、监听事件\" class=\"headerlink\" title=\"二、监听事件\"></a>二、监听事件</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!-- 上面两个Js文件是有固定的引用先后顺序 --&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//监听事件</span></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//实时切换一个按钮的状态</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//定义一个按钮组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Button1</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//因为设计到React.Component里的一些特性，所以需要构造器继承父类构造器</span></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props);</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//state里的数据可以更新修改，相当于Vue里的data</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">isToggleOn</span>:<span class=\"hljs-literal\">true</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">data1</span>:<span class=\"hljs-string\">&#x27;haha&#x27;</span>,</span><br><span class=\"javascript\">                &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//为了在该类的方法中调用this.setState来改变state里的数据来实现实时监听，所以，要在构造器里提前将需要的方法绑定this</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleClick=<span class=\"hljs-built_in\">this</span>.handleClick.bind(<span class=\"hljs-built_in\">this</span>)</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//该方法来实现实时切换</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//若前面没有绑定this，则该方法里的this指向underfined</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//prevState是state原先的状态</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//这里的=&gt;(&#123;...&#125;)等价于=&gt;&#123;return (&#123;...&#125;)&#125;</span></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleClick</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\"><span class=\"hljs-params\">prevState</span>=&gt;</span>(&#123;</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">isToggleOn</span>:!prevState.isToggleOn</span><br><span class=\"javascript\">                &#125;))</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">// 下面的方法显示打印出prevState的数据</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">// handleClick()&#123;</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//     this.setState(prevState=&gt;&#123;</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//         console.log(&#x27;prevState&#x27;,prevState)</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//         return (&#123;</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//             isToggleOn:!prevState.isToggleOn</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//         &#125;)</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//     &#125;)</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">// &#125;</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"javascript\">                    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                        &#123;this.state.isToggleOn?&#x27;ON&#x27;:&#x27;OFF&#x27;&#125;</span></span><br><span class=\"xml\"><span class=\"javascript\">                    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span></span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Button1</span> /&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;test1&quot;</span>))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>以上例子实现了实时监控切换一个按钮状态。</p>\n<p>在 React 中另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code>。</p>\n<h3 id=\"三、条件渲染\"><a href=\"#三、条件渲染\" class=\"headerlink\" title=\"三、条件渲染\"></a>三、条件渲染</h3><p>可以通过以下方法自定义元素。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!-- 上面两个Js文件是有固定的引用先后顺序 --&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//条件渲染</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//用函数定义的方式实现子组件的定义</span></span><br><span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SonDiv</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//若isShow=false,则返回null，即该组件不会渲染，会被隐藏</span></span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">if</span>(!props.isShow)&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"javascript\">                <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Son is Show<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"javascript\">            )</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//用类的方式实现父组件的定义</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FatherDiv</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props)</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;<span class=\"hljs-attr\">isShow</span>:<span class=\"hljs-literal\">true</span>&#125;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleToggleChilk=<span class=\"hljs-built_in\">this</span>.handleToggleChilk.bind(<span class=\"hljs-built_in\">this</span>)</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleToggleChilk</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\"><span class=\"hljs-params\">prevState</span>=&gt;</span>(&#123;</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">isShow</span>:!prevState.isShow</span><br><span class=\"javascript\">                &#125;))</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"javascript\">                    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">SonDiv</span> <span class=\"hljs-attr\">isShow</span>=<span class=\"hljs-string\">&#123;this.state.isShow&#125;</span> /&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;this.handleToggleChilk&#125;</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                            &#123;this.state.isShow?&#x27;hide&#x27;:&#x27;show&#x27;&#125;</span></span><br><span class=\"xml\"><span class=\"javascript\">                        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">FatherDiv</span> /&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;test1&quot;</span>))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>以上案例实现了一个监控+条件渲染的案例，初始状态为：</p>\n<p><img src=\"/images/react/2021121901.png\"></p>\n<p>点击按钮’hide’，则会隐藏子组件并且按钮内容改为’show’，点击’show’则会回到初始状态即显示子组件。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<h3 id=\"一、使用state实现更新React组件数据\"><a href=\"#一、使用state实现更新React组件数据\" class=\"headerlink\" title=\"一、使用state实现更新React组件数据\"></a>一、使用state实现更新React组件数据</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!-- 上面两个Js文件是有固定的引用先后顺序 --&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">// 使用state实现更新React组件数据</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">// 利用class定义自定义组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Clock</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//调用父类构造器</span></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props);</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//定义state内的数据</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;<span class=\"hljs-attr\">data</span>:<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()&#125;;</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//生命周期函数：挂载完成时，每一秒调用tick函数，即每一秒改变stata内data的数据。</span></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.timeID=<span class=\"hljs-built_in\">setInterval</span>(</span><br><span class=\"javascript\">                <span class=\"hljs-function\">()=&gt;</span><span class=\"hljs-built_in\">this</span>.tick(),<span class=\"hljs-number\">1000</span></span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//生命周期函数：即将卸载时</span></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">componentWillUnmount</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">clearInterval</span>(<span class=\"hljs-built_in\">this</span>.timeID);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">tick</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">data</span>:<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()</span><br><span class=\"javascript\">                &#125;);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"javascript\">                    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>hello!!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h5</span>&gt;</span>It is &#123;this.state.data.toLocaleTimeString()&#125; .<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h5</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Clock</span> /&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;test1&quot;</span>))</span><br><span class=\"javascript\">    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>以上为一个时钟渲染实例，通过state和生命周期的使用来实时完成时钟的运行。</p>\n<p>构造函数是唯一可以给 <code>this.state</code> 赋值的地方，使用 <code>setState()</code>修改state里的数据</p>\n<p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用，因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p>\n<h3 id=\"二、监听事件\"><a href=\"#二、监听事件\" class=\"headerlink\" title=\"二、监听事件\"></a>二、监听事件</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!-- 上面两个Js文件是有固定的引用先后顺序 --&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//监听事件</span></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//实时切换一个按钮的状态</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//定义一个按钮组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Button1</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//因为设计到React.Component里的一些特性，所以需要构造器继承父类构造器</span></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props);</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//state里的数据可以更新修改，相当于Vue里的data</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">isToggleOn</span>:<span class=\"hljs-literal\">true</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">data1</span>:<span class=\"hljs-string\">&#x27;haha&#x27;</span>,</span><br><span class=\"javascript\">                &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//为了在该类的方法中调用this.setState来改变state里的数据来实现实时监听，所以，要在构造器里提前将需要的方法绑定this</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleClick=<span class=\"hljs-built_in\">this</span>.handleClick.bind(<span class=\"hljs-built_in\">this</span>)</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//该方法来实现实时切换</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//若前面没有绑定this，则该方法里的this指向underfined</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//prevState是state原先的状态</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//这里的=&gt;(&#123;...&#125;)等价于=&gt;&#123;return (&#123;...&#125;)&#125;</span></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleClick</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\"><span class=\"hljs-params\">prevState</span>=&gt;</span>(&#123;</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">isToggleOn</span>:!prevState.isToggleOn</span><br><span class=\"javascript\">                &#125;))</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">// 下面的方法显示打印出prevState的数据</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">// handleClick()&#123;</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//     this.setState(prevState=&gt;&#123;</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//         console.log(&#x27;prevState&#x27;,prevState)</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//         return (&#123;</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//             isToggleOn:!prevState.isToggleOn</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//         &#125;)</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//     &#125;)</span></span><br><span class=\"javascript\">            <span class=\"hljs-comment\">// &#125;</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"javascript\">                    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                        &#123;this.state.isToggleOn?&#x27;ON&#x27;:&#x27;OFF&#x27;&#125;</span></span><br><span class=\"xml\"><span class=\"javascript\">                    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span></span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Button1</span> /&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;test1&quot;</span>))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>以上例子实现了实时监控切换一个按钮状态。</p>\n<p>在 React 中另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code>。</p>\n<h3 id=\"三、条件渲染\"><a href=\"#三、条件渲染\" class=\"headerlink\" title=\"三、条件渲染\"></a>三、条件渲染</h3><p>可以通过以下方法自定义元素。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!-- 上面两个Js文件是有固定的引用先后顺序 --&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//条件渲染</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//用函数定义的方式实现子组件的定义</span></span><br><span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SonDiv</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//若isShow=false,则返回null，即该组件不会渲染，会被隐藏</span></span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">if</span>(!props.isShow)&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"javascript\">                <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Son is Show<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"javascript\">            )</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//用类的方式实现父组件的定义</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FatherDiv</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props)</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;<span class=\"hljs-attr\">isShow</span>:<span class=\"hljs-literal\">true</span>&#125;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleToggleChilk=<span class=\"hljs-built_in\">this</span>.handleToggleChilk.bind(<span class=\"hljs-built_in\">this</span>)</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleToggleChilk</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\"><span class=\"hljs-params\">prevState</span>=&gt;</span>(&#123;</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">isShow</span>:!prevState.isShow</span><br><span class=\"javascript\">                &#125;))</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"javascript\">                    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">SonDiv</span> <span class=\"hljs-attr\">isShow</span>=<span class=\"hljs-string\">&#123;this.state.isShow&#125;</span> /&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;this.handleToggleChilk&#125;</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                            &#123;this.state.isShow?&#x27;hide&#x27;:&#x27;show&#x27;&#125;</span></span><br><span class=\"xml\"><span class=\"javascript\">                        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">FatherDiv</span> /&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;test1&quot;</span>))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>以上案例实现了一个监控+条件渲染的案例，初始状态为：</p>\n<p><img src=\"/images/react/2021121901.png\"></p>\n<p>点击按钮’hide’，则会隐藏子组件并且按钮内容改为’show’，点击’show’则会回到初始状态即显示子组件。</p>\n"},{"title":"React的状态提升&组合VS继承","date":"2021-12-19T05:49:01.000Z","_content":"\n### 一、状态提升\n\n通常，多个组件需要反应同一个数据变化时，建议使用状态提升，即共享状态提升到最近的父组件中\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //通过map的方式渲染列表\n\n        function List(props){\n            //获取列表参数\n            const numbers=props.numbers;\n            //利用map进行渲染\n            const listItem=numbers.map((number=>\n            <li>{number}</li>));\n\n            return (\n              <ul>{listItem}</ul>\n            )\n        }\n\n        const numbers=[1,2,3,4,5];\n        ReactDOM.render(\n        <List numbers={numbers} />,\n        document.getElementById('test1'))\n\n        </script>\n</html>\n```\n\n运行以上代码，发现已成功渲染列表，但是在控制台获得警告如下：\n\n![](/images/react/2021121903.png)\n\n提示对于列表的每一个元素都需要key关键词，给每一列添加key:`<li key={number.toString()}>{number}</li>));`，key作为列表中每个元素的唯一标识符，是有优化性能的作用。对于应该在哪里设置元素的key，一个好的经验法则是：在 `map()` 方法中的元素需要设置 key 属性。\n\n以上情况可以也通过以下方法实现\n\n```jsx\nfuntion ListItem(props){\n            return <li>{props.value}</li>\n}\n\nfunction List2(props){\n    const numbers=props.numbers;\n    return (\n         <ul>\n            {numbers.map((number=>\n            <ListItem key={number.toString()} value={number} />\n            ))}\n        </ul>\n    )\n}\n```\n\n### 二、表单\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //表单的运用\n\n        //通过类自定义的内有方法来更方便迅捷地操作表单\n\n        //自定义表单组件\n        class NameForm extends React.Component{\n            constructor(props){\n                super(props);\n                //定义可更改的变量，即表单输入元素\n                this.state={value:''};\n                //在具体方法中绑定this来实现对state的改变。\n                this.handleChange=this.handleChange.bind(this);\n                this.handleSubmit=this.handleSubmit.bind(this);\n            }\n\n            handleChange(event){\n                this.setState({value:event.target.value});\n            }\n            handleSubmit(event){\n                //提交前显示名字\n                alert('提交的名字：'+this.state.value);\n                event.preventDefault();\n            }\n            render(){\n                return(\n                  <form onSubmit={this.handleSubmit}>\n                    <label>\n                      名字:\n                      <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n                     </label>\n                      <button type=\"submit\">提交</button>\n                    </form>  \n                )\n            }\n        }\n        ReactDOM.render(<NameForm />,document.getElementById('test1'))\n\n        </script>\n</html>\n```\n\n以上例子实现了一个自定义表单的应用。\n\n注意：在Html中`<textarea>` 组件直接通过子元素定义其文本，而在React中通过属性value来确定其文本。针对`<select>`组件React 并不会使用 `selected` 属性，而是在根 `select` 标签上使用 `value` 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。\n\n具体关于textarea 和select在React里的具体操作如下所示：\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //表单的运用\n\n        //通过类自定义的内有方法来更方便迅捷地操作表单\n\n        //自定义表单组件\n        class NameForm extends React.Component{\n            constructor(props){\n                super(props);\n                //定义可更改的变量，即表单输入元素\n                this.state={\n                    value:'',\n                    textValue:'',\n                    selected:'aa',\n                };\n                //在具体方法中绑定this来实现对state的改变。\n                this.handleChange=this.handleChange.bind(this);\n                this.handleSubmit=this.handleSubmit.bind(this);\n                this.handleChangeSelect=this.handleChangeSelect.bind(this);\n                this.handleChangeTextarea=this.handleChangeTextarea.bind(this);\n            }\n\n            handleChange(event){\n                this.setState({value:event.target.value});\n            }\n            handleSubmit(event){\n                //提交前显示名字\n                alert('提交的名字：'+this.state.value);\n                event.preventDefault();\n            }\n            handleChangeTextarea(event){\n                this.setState({textValue:event.target.value})\n            }\n            handleChangeSelect(event){\n                console.log('event',event)\n                this.setState({selected:event.target.value});\n            }\n            render(){\n                return(\n                  <form onSubmit={this.handleSubmit}>\n                    <label>\n                      名字:\n                      <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n                     </label>\n                     <label>\n                         内容：\n                         <textarea  value={this.state.textValue} onChange={this.handleChangeTextarea}/>\n                     </label>\n                     <label>\n                         选择：\n                         <select value={this.state.selected} onChange={this.handleChangeSelect} >\n                             <option value='aa'>aa</ option>\n                             <option value='bb'>bb</ option>\n                             <option value='cc'>cc</ option>\n                         </select>\n                     </label>\n                      <button type=\"submit\">提交</button>\n                    </form>  \n                )\n            }\n        }\n        ReactDOM.render(<NameForm />,document.getElementById('test1'))\n\n        </script>\n</html>\n```\n\n以上的形式在一个表单中调用了多个onChange，也可以只调用同一个onChange函数同时监听并改变多个数据，可以给每个元素添加 `name` 属性，并让处理函数根据 `event.target.name` 的值选择要执行的操作。具体代码如下所示：\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //表单的运用\n\n        //通过类自定义的内有方法来更方便迅捷地操作表单\n\n        //自定义表单组件\n        class NameForm extends React.Component{\n            constructor(props){\n                super(props);\n                //定义可更改的变量，即表单输入元素\n                this.state={\n                    nameValue:'',\n                    textValue:'',\n                    selected:'aa',\n                };\n                //在具体方法中绑定this来实现对state的改变。\n                this.handleChange=this.handleChange.bind(this);\n                this.handleSubmit=this.handleSubmit.bind(this);\n            }\n\n            handleChange(event){\n                const value=event.target.value;\n                const name=event.target.name;\n                this.setState({\n                    [name]:value\n                })\n            }\n            handleSubmit(event){\n                //提交前显示名字\n                alert('提交的名字：'+this.state.value);\n                console.log('state',this.state)\n                event.preventDefault();\n            }\n            render(){\n                return(\n                  <form onSubmit={this.handleSubmit}>\n                    <label>\n                      名字:\n                      <input name=\"nameValue\" type=\"text\" value={this.state.value} onChange={this.handleChange} />\n                     </label>\n                     <label>\n                         内容：\n                         <textarea name=\"textValue\"  value={this.state.textValue} onChange={this.handleChange}/>\n                     </label>\n                     <label>\n                         选择：\n                         <select name=\"selected\" value={this.state.selected} onChange={this.handleChange} >\n                             <option value='aa'>aa</ option>\n                             <option value='bb'>bb</ option>\n                             <option value='cc'>cc</ option>\n                         </select>\n                     </label>\n                      <button type=\"submit\">提交</button>\n                    </form>  \n                )\n            }\n        }\n        ReactDOM.render(<NameForm />,document.getElementById('test1'))\n\n        </script>\n</html>\n```\n","source":"_posts/React学习四.md","raw":"---\ntitle: React的状态提升&组合VS继承\ndate: 2021-12-19 13:49:01\ntags: [React, 学习]\ncategories:\n- React\n---\n\n### 一、状态提升\n\n通常，多个组件需要反应同一个数据变化时，建议使用状态提升，即共享状态提升到最近的父组件中\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //通过map的方式渲染列表\n\n        function List(props){\n            //获取列表参数\n            const numbers=props.numbers;\n            //利用map进行渲染\n            const listItem=numbers.map((number=>\n            <li>{number}</li>));\n\n            return (\n              <ul>{listItem}</ul>\n            )\n        }\n\n        const numbers=[1,2,3,4,5];\n        ReactDOM.render(\n        <List numbers={numbers} />,\n        document.getElementById('test1'))\n\n        </script>\n</html>\n```\n\n运行以上代码，发现已成功渲染列表，但是在控制台获得警告如下：\n\n![](/images/react/2021121903.png)\n\n提示对于列表的每一个元素都需要key关键词，给每一列添加key:`<li key={number.toString()}>{number}</li>));`，key作为列表中每个元素的唯一标识符，是有优化性能的作用。对于应该在哪里设置元素的key，一个好的经验法则是：在 `map()` 方法中的元素需要设置 key 属性。\n\n以上情况可以也通过以下方法实现\n\n```jsx\nfuntion ListItem(props){\n            return <li>{props.value}</li>\n}\n\nfunction List2(props){\n    const numbers=props.numbers;\n    return (\n         <ul>\n            {numbers.map((number=>\n            <ListItem key={number.toString()} value={number} />\n            ))}\n        </ul>\n    )\n}\n```\n\n### 二、表单\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //表单的运用\n\n        //通过类自定义的内有方法来更方便迅捷地操作表单\n\n        //自定义表单组件\n        class NameForm extends React.Component{\n            constructor(props){\n                super(props);\n                //定义可更改的变量，即表单输入元素\n                this.state={value:''};\n                //在具体方法中绑定this来实现对state的改变。\n                this.handleChange=this.handleChange.bind(this);\n                this.handleSubmit=this.handleSubmit.bind(this);\n            }\n\n            handleChange(event){\n                this.setState({value:event.target.value});\n            }\n            handleSubmit(event){\n                //提交前显示名字\n                alert('提交的名字：'+this.state.value);\n                event.preventDefault();\n            }\n            render(){\n                return(\n                  <form onSubmit={this.handleSubmit}>\n                    <label>\n                      名字:\n                      <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n                     </label>\n                      <button type=\"submit\">提交</button>\n                    </form>  \n                )\n            }\n        }\n        ReactDOM.render(<NameForm />,document.getElementById('test1'))\n\n        </script>\n</html>\n```\n\n以上例子实现了一个自定义表单的应用。\n\n注意：在Html中`<textarea>` 组件直接通过子元素定义其文本，而在React中通过属性value来确定其文本。针对`<select>`组件React 并不会使用 `selected` 属性，而是在根 `select` 标签上使用 `value` 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。\n\n具体关于textarea 和select在React里的具体操作如下所示：\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //表单的运用\n\n        //通过类自定义的内有方法来更方便迅捷地操作表单\n\n        //自定义表单组件\n        class NameForm extends React.Component{\n            constructor(props){\n                super(props);\n                //定义可更改的变量，即表单输入元素\n                this.state={\n                    value:'',\n                    textValue:'',\n                    selected:'aa',\n                };\n                //在具体方法中绑定this来实现对state的改变。\n                this.handleChange=this.handleChange.bind(this);\n                this.handleSubmit=this.handleSubmit.bind(this);\n                this.handleChangeSelect=this.handleChangeSelect.bind(this);\n                this.handleChangeTextarea=this.handleChangeTextarea.bind(this);\n            }\n\n            handleChange(event){\n                this.setState({value:event.target.value});\n            }\n            handleSubmit(event){\n                //提交前显示名字\n                alert('提交的名字：'+this.state.value);\n                event.preventDefault();\n            }\n            handleChangeTextarea(event){\n                this.setState({textValue:event.target.value})\n            }\n            handleChangeSelect(event){\n                console.log('event',event)\n                this.setState({selected:event.target.value});\n            }\n            render(){\n                return(\n                  <form onSubmit={this.handleSubmit}>\n                    <label>\n                      名字:\n                      <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n                     </label>\n                     <label>\n                         内容：\n                         <textarea  value={this.state.textValue} onChange={this.handleChangeTextarea}/>\n                     </label>\n                     <label>\n                         选择：\n                         <select value={this.state.selected} onChange={this.handleChangeSelect} >\n                             <option value='aa'>aa</ option>\n                             <option value='bb'>bb</ option>\n                             <option value='cc'>cc</ option>\n                         </select>\n                     </label>\n                      <button type=\"submit\">提交</button>\n                    </form>  \n                )\n            }\n        }\n        ReactDOM.render(<NameForm />,document.getElementById('test1'))\n\n        </script>\n</html>\n```\n\n以上的形式在一个表单中调用了多个onChange，也可以只调用同一个onChange函数同时监听并改变多个数据，可以给每个元素添加 `name` 属性，并让处理函数根据 `event.target.name` 的值选择要执行的操作。具体代码如下所示：\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <script src=\"../js/react.development.js\" crossorigin></script>\n        <script src=\"../js/react-dom.development.js\" crossorigin></script>\n        <script src=\"../js/babel.min.js\"></script>\n    </head>\n    <body>\n        <div id=\"test1\"></div>\n\n    </body>\n    <script type=\"text/babel\">\n        //表单的运用\n\n        //通过类自定义的内有方法来更方便迅捷地操作表单\n\n        //自定义表单组件\n        class NameForm extends React.Component{\n            constructor(props){\n                super(props);\n                //定义可更改的变量，即表单输入元素\n                this.state={\n                    nameValue:'',\n                    textValue:'',\n                    selected:'aa',\n                };\n                //在具体方法中绑定this来实现对state的改变。\n                this.handleChange=this.handleChange.bind(this);\n                this.handleSubmit=this.handleSubmit.bind(this);\n            }\n\n            handleChange(event){\n                const value=event.target.value;\n                const name=event.target.name;\n                this.setState({\n                    [name]:value\n                })\n            }\n            handleSubmit(event){\n                //提交前显示名字\n                alert('提交的名字：'+this.state.value);\n                console.log('state',this.state)\n                event.preventDefault();\n            }\n            render(){\n                return(\n                  <form onSubmit={this.handleSubmit}>\n                    <label>\n                      名字:\n                      <input name=\"nameValue\" type=\"text\" value={this.state.value} onChange={this.handleChange} />\n                     </label>\n                     <label>\n                         内容：\n                         <textarea name=\"textValue\"  value={this.state.textValue} onChange={this.handleChange}/>\n                     </label>\n                     <label>\n                         选择：\n                         <select name=\"selected\" value={this.state.selected} onChange={this.handleChange} >\n                             <option value='aa'>aa</ option>\n                             <option value='bb'>bb</ option>\n                             <option value='cc'>cc</ option>\n                         </select>\n                     </label>\n                      <button type=\"submit\">提交</button>\n                    </form>  \n                )\n            }\n        }\n        ReactDOM.render(<NameForm />,document.getElementById('test1'))\n\n        </script>\n</html>\n```\n","slug":"React学习四","published":1,"updated":"2022-03-11T03:42:46.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh11000d6wtvh5510ktc","content":"<h3 id=\"一、状态提升\"><a href=\"#一、状态提升\" class=\"headerlink\" title=\"一、状态提升\"></a>一、状态提升</h3><p>通常，多个组件需要反应同一个数据变化时，建议使用状态提升，即共享状态提升到最近的父组件中</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//通过map的方式渲染列表</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">List</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//获取列表参数</span></span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">const</span> numbers=props.numbers;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//利用map进行渲染</span></span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">const</span> listItem=numbers.map((<span class=\"hljs-function\"><span class=\"hljs-params\">number</span>=&gt;</span></span><br><span class=\"javascript\">            <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>&#123;number&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span>));</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"javascript\">              <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>&#123;listItem&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></span></span><br><span class=\"javascript\">            )</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-keyword\">const</span> numbers=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>];</span><br><span class=\"javascript\">        ReactDOM.render(</span><br><span class=\"javascript\">        <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">List</span> <span class=\"hljs-attr\">numbers</span>=<span class=\"hljs-string\">&#123;numbers&#125;</span> /&gt;</span></span>,</span><br><span class=\"javascript\">        <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;test1&#x27;</span>))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>运行以上代码，发现已成功渲染列表，但是在控制台获得警告如下：</p>\n<p><img src=\"/images/react/2021121903.png\"></p>\n<p>提示对于列表的每一个元素都需要key关键词，给每一列添加key:<code>&lt;li key=&#123;number.toString()&#125;&gt;&#123;number&#125;&lt;/li&gt;));</code>，key作为列表中每个元素的唯一标识符，是有优化性能的作用。对于应该在哪里设置元素的key，一个好的经验法则是：在 <code>map()</code> 方法中的元素需要设置 key 属性。</p>\n<p>以上情况可以也通过以下方法实现</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\">funtion <span class=\"hljs-function\"><span class=\"hljs-title\">ListItem</span>(<span class=\"hljs-params\">props</span>)</span>&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>&#123;props.value&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">List2</span>(<span class=\"hljs-params\">props</span>)</span>&#123;<br>    <span class=\"hljs-keyword\">const</span> numbers=props.numbers;<br>    <span class=\"hljs-keyword\">return</span> (<br>         <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span></span><br><span class=\"xml\">            &#123;numbers.map((number=&gt;</span><br><span class=\"xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ListItem</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#123;number.toString()&#125;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;number&#125;</span> /&gt;</span></span><br><span class=\"xml\">            ))&#125;</span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"二、表单\"><a href=\"#二、表单\" class=\"headerlink\" title=\"二、表单\"></a>二、表单</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//表单的运用</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//自定义表单组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NameForm</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props);</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//定义可更改的变量，即表单输入元素</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;<span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>&#125;;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChange=<span class=\"hljs-built_in\">this</span>.handleChange.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleSubmit=<span class=\"hljs-built_in\">this</span>.handleSubmit.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChange</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;<span class=\"hljs-attr\">value</span>:event.target.value&#125;);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleSubmit</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//提交前显示名字</span></span><br><span class=\"javascript\">                alert(<span class=\"hljs-string\">&#x27;提交的名字：&#x27;</span>+<span class=\"hljs-built_in\">this</span>.state.value);</span><br><span class=\"javascript\">                event.preventDefault();</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span>(</span><br><span class=\"javascript\">                  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                      名字:</span></span><br><span class=\"xml\"><span class=\"javascript\">                      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;this.state.value&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                     <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;submit&quot;</span>&gt;</span>提交<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></span>  </span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">NameForm</span> /&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;test1&#x27;</span>))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>以上例子实现了一个自定义表单的应用。</p>\n<p>注意：在Html中<code>&lt;textarea&gt;</code> 组件直接通过子元素定义其文本，而在React中通过属性value来确定其文本。针对<code>&lt;select&gt;</code>组件React 并不会使用 <code>selected</code> 属性，而是在根 <code>select</code> 标签上使用 <code>value</code> 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。</p>\n<p>具体关于textarea 和select在React里的具体操作如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//表单的运用</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//自定义表单组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NameForm</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props);</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//定义可更改的变量，即表单输入元素</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">textValue</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">selected</span>:<span class=\"hljs-string\">&#x27;aa&#x27;</span>,</span><br><span class=\"javascript\">                &#125;;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChange=<span class=\"hljs-built_in\">this</span>.handleChange.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleSubmit=<span class=\"hljs-built_in\">this</span>.handleSubmit.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChangeSelect=<span class=\"hljs-built_in\">this</span>.handleChangeSelect.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChangeTextarea=<span class=\"hljs-built_in\">this</span>.handleChangeTextarea.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChange</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;<span class=\"hljs-attr\">value</span>:event.target.value&#125;);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleSubmit</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//提交前显示名字</span></span><br><span class=\"javascript\">                alert(<span class=\"hljs-string\">&#x27;提交的名字：&#x27;</span>+<span class=\"hljs-built_in\">this</span>.state.value);</span><br><span class=\"javascript\">                event.preventDefault();</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChangeTextarea</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;<span class=\"hljs-attr\">textValue</span>:event.target.value&#125;)</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChangeSelect</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;event&#x27;</span>,event)</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;<span class=\"hljs-attr\">selected</span>:event.target.value&#125;);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span>(</span><br><span class=\"javascript\">                  &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class=\"javascript\">                    &lt;label&gt;</span><br><span class=\"javascript\">                      名字:</span><br><span class=\"javascript\">                      &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                     &lt;label&gt;</span><br><span class=\"javascript\">                         内容：</span><br><span class=\"javascript\">                         &lt;textarea  value=&#123;this.state.textValue&#125; onChange=&#123;this.handleChangeTextarea&#125;/&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                     &lt;label&gt;</span><br><span class=\"javascript\">                         选择：</span><br><span class=\"javascript\">                         &lt;select value=&#123;this.state.selected&#125; onChange=&#123;this.handleChangeSelect&#125; &gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;aa&#x27;&gt;aa&lt;/ option&gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;bb&#x27;&gt;bb&lt;/ option&gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;cc&#x27;&gt;cc&lt;/ option&gt;</span><br><span class=\"javascript\">                         &lt;/select&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                      &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"javascript\">                    &lt;/form&gt;  </span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(&lt;NameForm /&gt;,document.getElementById(&#x27;test1&#x27;))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>以上的形式在一个表单中调用了多个onChange，也可以只调用同一个onChange函数同时监听并改变多个数据，可以给每个元素添加 <code>name</code> 属性，并让处理函数根据 <code>event.target.name</code> 的值选择要执行的操作。具体代码如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//表单的运用</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//自定义表单组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NameForm</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props);</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//定义可更改的变量，即表单输入元素</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">nameValue</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">textValue</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">selected</span>:<span class=\"hljs-string\">&#x27;aa&#x27;</span>,</span><br><span class=\"javascript\">                &#125;;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChange=<span class=\"hljs-built_in\">this</span>.handleChange.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleSubmit=<span class=\"hljs-built_in\">this</span>.handleSubmit.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChange</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">const</span> value=event.target.value;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">const</span> name=event.target.name;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;</span><br><span class=\"javascript\">                    [name]:value</span><br><span class=\"javascript\">                &#125;)</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleSubmit</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//提交前显示名字</span></span><br><span class=\"javascript\">                alert(<span class=\"hljs-string\">&#x27;提交的名字：&#x27;</span>+<span class=\"hljs-built_in\">this</span>.state.value);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;state&#x27;</span>,<span class=\"hljs-built_in\">this</span>.state)</span><br><span class=\"javascript\">                event.preventDefault();</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span>(</span><br><span class=\"javascript\">                  &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class=\"javascript\">                    &lt;label&gt;</span><br><span class=\"javascript\">                      名字:</span><br><span class=\"javascript\">                      &lt;input name=&quot;nameValue&quot; type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                     &lt;label&gt;</span><br><span class=\"javascript\">                         内容：</span><br><span class=\"javascript\">                         &lt;textarea name=&quot;textValue&quot;  value=&#123;this.state.textValue&#125; onChange=&#123;this.handleChange&#125;/&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                     &lt;label&gt;</span><br><span class=\"javascript\">                         选择：</span><br><span class=\"javascript\">                         &lt;select name=&quot;selected&quot; value=&#123;this.state.selected&#125; onChange=&#123;this.handleChange&#125; &gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;aa&#x27;&gt;aa&lt;/ option&gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;bb&#x27;&gt;bb&lt;/ option&gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;cc&#x27;&gt;cc&lt;/ option&gt;</span><br><span class=\"javascript\">                         &lt;/select&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                      &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"javascript\">                    &lt;/form&gt;  </span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(&lt;NameForm /&gt;,document.getElementById(&#x27;test1&#x27;))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<h3 id=\"一、状态提升\"><a href=\"#一、状态提升\" class=\"headerlink\" title=\"一、状态提升\"></a>一、状态提升</h3><p>通常，多个组件需要反应同一个数据变化时，建议使用状态提升，即共享状态提升到最近的父组件中</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//通过map的方式渲染列表</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">List</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//获取列表参数</span></span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">const</span> numbers=props.numbers;</span><br><span class=\"javascript\">            <span class=\"hljs-comment\">//利用map进行渲染</span></span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">const</span> listItem=numbers.map((<span class=\"hljs-function\"><span class=\"hljs-params\">number</span>=&gt;</span></span><br><span class=\"javascript\">            <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>&#123;number&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span>));</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"javascript\">              <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>&#123;listItem&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></span></span><br><span class=\"javascript\">            )</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-keyword\">const</span> numbers=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>];</span><br><span class=\"javascript\">        ReactDOM.render(</span><br><span class=\"javascript\">        <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">List</span> <span class=\"hljs-attr\">numbers</span>=<span class=\"hljs-string\">&#123;numbers&#125;</span> /&gt;</span></span>,</span><br><span class=\"javascript\">        <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;test1&#x27;</span>))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>运行以上代码，发现已成功渲染列表，但是在控制台获得警告如下：</p>\n<p><img src=\"/images/react/2021121903.png\"></p>\n<p>提示对于列表的每一个元素都需要key关键词，给每一列添加key:<code>&lt;li key=&#123;number.toString()&#125;&gt;&#123;number&#125;&lt;/li&gt;));</code>，key作为列表中每个元素的唯一标识符，是有优化性能的作用。对于应该在哪里设置元素的key，一个好的经验法则是：在 <code>map()</code> 方法中的元素需要设置 key 属性。</p>\n<p>以上情况可以也通过以下方法实现</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\">funtion <span class=\"hljs-function\"><span class=\"hljs-title\">ListItem</span>(<span class=\"hljs-params\">props</span>)</span>&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>&#123;props.value&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">List2</span>(<span class=\"hljs-params\">props</span>)</span>&#123;<br>    <span class=\"hljs-keyword\">const</span> numbers=props.numbers;<br>    <span class=\"hljs-keyword\">return</span> (<br>         <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span></span><br><span class=\"xml\">            &#123;numbers.map((number=&gt;</span><br><span class=\"xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ListItem</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#123;number.toString()&#125;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;number&#125;</span> /&gt;</span></span><br><span class=\"xml\">            ))&#125;</span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"二、表单\"><a href=\"#二、表单\" class=\"headerlink\" title=\"二、表单\"></a>二、表单</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//表单的运用</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//自定义表单组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NameForm</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props);</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//定义可更改的变量，即表单输入元素</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;<span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>&#125;;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChange=<span class=\"hljs-built_in\">this</span>.handleChange.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleSubmit=<span class=\"hljs-built_in\">this</span>.handleSubmit.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChange</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;<span class=\"hljs-attr\">value</span>:event.target.value&#125;);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleSubmit</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//提交前显示名字</span></span><br><span class=\"javascript\">                alert(<span class=\"hljs-string\">&#x27;提交的名字：&#x27;</span>+<span class=\"hljs-built_in\">this</span>.state.value);</span><br><span class=\"javascript\">                event.preventDefault();</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span>(</span><br><span class=\"javascript\">                  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                      名字:</span></span><br><span class=\"xml\"><span class=\"javascript\">                      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;this.state.value&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                     <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;submit&quot;</span>&gt;</span>提交<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span></span><br><span class=\"xml\"><span class=\"javascript\">                    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></span>  </span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">NameForm</span> /&gt;</span></span>,<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;test1&#x27;</span>))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>以上例子实现了一个自定义表单的应用。</p>\n<p>注意：在Html中<code>&lt;textarea&gt;</code> 组件直接通过子元素定义其文本，而在React中通过属性value来确定其文本。针对<code>&lt;select&gt;</code>组件React 并不会使用 <code>selected</code> 属性，而是在根 <code>select</code> 标签上使用 <code>value</code> 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。</p>\n<p>具体关于textarea 和select在React里的具体操作如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//表单的运用</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//自定义表单组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NameForm</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props);</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//定义可更改的变量，即表单输入元素</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">textValue</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">selected</span>:<span class=\"hljs-string\">&#x27;aa&#x27;</span>,</span><br><span class=\"javascript\">                &#125;;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChange=<span class=\"hljs-built_in\">this</span>.handleChange.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleSubmit=<span class=\"hljs-built_in\">this</span>.handleSubmit.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChangeSelect=<span class=\"hljs-built_in\">this</span>.handleChangeSelect.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChangeTextarea=<span class=\"hljs-built_in\">this</span>.handleChangeTextarea.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChange</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;<span class=\"hljs-attr\">value</span>:event.target.value&#125;);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleSubmit</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//提交前显示名字</span></span><br><span class=\"javascript\">                alert(<span class=\"hljs-string\">&#x27;提交的名字：&#x27;</span>+<span class=\"hljs-built_in\">this</span>.state.value);</span><br><span class=\"javascript\">                event.preventDefault();</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChangeTextarea</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;<span class=\"hljs-attr\">textValue</span>:event.target.value&#125;)</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChangeSelect</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;event&#x27;</span>,event)</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;<span class=\"hljs-attr\">selected</span>:event.target.value&#125;);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span>(</span><br><span class=\"javascript\">                  &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class=\"javascript\">                    &lt;label&gt;</span><br><span class=\"javascript\">                      名字:</span><br><span class=\"javascript\">                      &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                     &lt;label&gt;</span><br><span class=\"javascript\">                         内容：</span><br><span class=\"javascript\">                         &lt;textarea  value=&#123;this.state.textValue&#125; onChange=&#123;this.handleChangeTextarea&#125;/&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                     &lt;label&gt;</span><br><span class=\"javascript\">                         选择：</span><br><span class=\"javascript\">                         &lt;select value=&#123;this.state.selected&#125; onChange=&#123;this.handleChangeSelect&#125; &gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;aa&#x27;&gt;aa&lt;/ option&gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;bb&#x27;&gt;bb&lt;/ option&gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;cc&#x27;&gt;cc&lt;/ option&gt;</span><br><span class=\"javascript\">                         &lt;/select&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                      &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"javascript\">                    &lt;/form&gt;  </span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(&lt;NameForm /&gt;,document.getElementById(&#x27;test1&#x27;))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>以上的形式在一个表单中调用了多个onChange，也可以只调用同一个onChange函数同时监听并改变多个数据，可以给每个元素添加 <code>name</code> 属性，并让处理函数根据 <code>event.target.name</code> 的值选择要执行的操作。具体代码如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/react-dom.development.js&quot;</span> <span class=\"hljs-attr\">crossorigin</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;test1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//表单的运用</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//通过类自定义的内有方法来更方便迅捷地操作表单</span></span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//自定义表单组件</span></span><br><span class=\"javascript\">        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NameForm</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>&#123;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">super</span>(props);</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//定义可更改的变量，即表单输入元素</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.state=&#123;</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">nameValue</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">textValue</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>,</span><br><span class=\"javascript\">                    <span class=\"hljs-attr\">selected</span>:<span class=\"hljs-string\">&#x27;aa&#x27;</span>,</span><br><span class=\"javascript\">                &#125;;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//在具体方法中绑定this来实现对state的改变。</span></span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleChange=<span class=\"hljs-built_in\">this</span>.handleChange.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.handleSubmit=<span class=\"hljs-built_in\">this</span>.handleSubmit.bind(<span class=\"hljs-built_in\">this</span>);</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleChange</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">const</span> value=event.target.value;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">const</span> name=event.target.name;</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">this</span>.setState(&#123;</span><br><span class=\"javascript\">                    [name]:value</span><br><span class=\"javascript\">                &#125;)</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">handleSubmit</span>(<span class=\"hljs-params\">event</span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-comment\">//提交前显示名字</span></span><br><span class=\"javascript\">                alert(<span class=\"hljs-string\">&#x27;提交的名字：&#x27;</span>+<span class=\"hljs-built_in\">this</span>.state.value);</span><br><span class=\"javascript\">                <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;state&#x27;</span>,<span class=\"hljs-built_in\">this</span>.state)</span><br><span class=\"javascript\">                event.preventDefault();</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">            <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span><br><span class=\"javascript\">                <span class=\"hljs-keyword\">return</span>(</span><br><span class=\"javascript\">                  &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class=\"javascript\">                    &lt;label&gt;</span><br><span class=\"javascript\">                      名字:</span><br><span class=\"javascript\">                      &lt;input name=&quot;nameValue&quot; type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                     &lt;label&gt;</span><br><span class=\"javascript\">                         内容：</span><br><span class=\"javascript\">                         &lt;textarea name=&quot;textValue&quot;  value=&#123;this.state.textValue&#125; onChange=&#123;this.handleChange&#125;/&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                     &lt;label&gt;</span><br><span class=\"javascript\">                         选择：</span><br><span class=\"javascript\">                         &lt;select name=&quot;selected&quot; value=&#123;this.state.selected&#125; onChange=&#123;this.handleChange&#125; &gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;aa&#x27;&gt;aa&lt;/ option&gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;bb&#x27;&gt;bb&lt;/ option&gt;</span><br><span class=\"javascript\">                             &lt;option value=&#x27;cc&#x27;&gt;cc&lt;/ option&gt;</span><br><span class=\"javascript\">                         &lt;/select&gt;</span><br><span class=\"javascript\">                     &lt;/label&gt;</span><br><span class=\"javascript\">                      &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"javascript\">                    &lt;/form&gt;  </span><br><span class=\"javascript\">                )</span><br><span class=\"javascript\">            &#125;</span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">        ReactDOM.render(&lt;NameForm /&gt;,document.getElementById(&#x27;test1&#x27;))</span><br><span class=\"javascript\"></span><br><span class=\"javascript\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n"},{"title":"V8工作原理","date":"2022-01-11T07:29:49.000Z","_content":"\n---\n\n*本文来源于[http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程](http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82)[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。*\n\n---\n\nV8是谷歌团队研发的一种JavaScript引擎。本文将从数据存储、数据回收、编译机制三个角度来分析JavaScript。\n\n## 1.数据存储\n\n### 1.1 JavaScript是什么类型的语言\n\n如C语言、Java语言就是在定义变量时就<u>需要声明变量类型</u>的语言，这种语言称为<u>静态语言</u>，像Python、JavaScript语言就是定义变量时无需声明变量类型的语言，这种语言叫做<u>动态语言</u>。如下段代码就是静态语言和动态语言的案例对比。\n\n```\n//静态语言-C语言\nint main()\n{\n   int a = 1;\n   char* b = \" 极客时间 \";\n   bool c = true;\n   return 0;\n}\n\n//动态语言-JavaScript语言\nvar a=1\nconsole.log(a,typeof(a))\n```\n\n如C语言、JavaScript语言又可称为<u>弱类型语言</u>，弱类型语言是指可以<u>支持隐式类型转换</u>的语言。反之，不支持隐式类型转换的语言就是<u>强类型语言</u>，如Java、Python。\n\n所以，JavaScript是一种动态的、弱类型的语言。\n\n### 1.2 JavaScript的数据类型\n\nJavaScript一共有<u>8种</u>数据类型，这8种类型可以分为两大类型，分别是<u>基础类型（原始类型）和引用类型</u>。基础类型包括Boolean布尔类型、Null空值、Underfined未定义类型、Nubmber基于IEEE754标准的双精度64位数据类型、BigInt可以曹处Number的安全整数范围限制的新的数据类型、String文本类型、Symbol符号类型不可修改且唯一。引用类型的数据只有一种即<u>Object对象类型</u>。\n\n其中要注意的是，使用typeof方法检测Null类型时返回的是Object（这是一个JavaScript一直以来的Bug）；Object类型是一种由基础类型组成的包含了key-value对的数据类型；基础数据类型和原始数据类型存储的位置不同。\n\n### 1.3 内存空间\n\nJavaScript运行时需要利用内存来存储数据，其中可以将内存分为三个部分分别是<u>代码空间</u>——用来存储可执行代码，<u>栈空间</u>——用来存储执行上下文，以及<u>堆空间</u>。\n\n栈空间用来存储可执行上下文，一般基础数据都直接存储在栈中，而Object数据由于其往往需要占较大内存所以会将其存储在堆中，栈中只存储其内存地址。一般而言，栈空间的大小都是较小的，因为栈空间若是较大，则释放或添加执行上下文则会调用更大的时间，而堆空间一般较大，也可以存储更多的数据。\n\n### 1.4 再谈闭包\n\n以下这段代码涉及到了闭包。\n\n```\nfunction foo() {\n    var myName = \" 极客时间 \"\n    let test1 = 1\n    const test2 = 2\n    var innerBar = { \n        setName:function(newName){\n            myName = newName\n        },\n        getName:function(){\n            console.log(test1)\n            return myName\n        }\n    }\n    return innerBar\n}\nvar bar = foo()\nbar.setName(\" 极客邦 \")\nbar.getName()\nconsole.log(bar.getName())\n```\n\n按道理，foo函数中的 `myName`、`test1`变量都是基础数据，应该直接存储在栈中，而随着foo函数执行完毕也会随之销毁，那么闭包又是怎么形成的呢？这就要分析这段代码的执行流程。\n\n首先JavaScript引擎执行foo函数时，会先编译，并创建一个空的执行上下文，编译过程中，遇到`setName`内部函数时会对其进行<u>一次快速的词法扫描</u>，发现在内部函数中遇到了其外部函数中定义的变量，JavaScript引擎就会判断这是一个闭包，就会在堆空间中创建一个<u>closure(foo)</u>的对象来存储相关变量。同理在`getName`函数中也会将`test1`变量存储在堆中对应位置。这样即使foo函数的执行上下文被移除，闭包中的变量也可以保留。\n\n## 2.垃圾回收\n\n有一些数据使用之后就不再需要，我们将这些数据称为<u>垃圾数据</u>，不同语言都有不同的垃圾回收政策，对于JavaScript语言则有一个<u>自动垃圾回收策略</u>。\n\n### 2.1 调用栈中的数据回收\n\n和操作系统中涉及到的栈结构相似，调用栈是利用<u>ESP指针</u>（永远指向栈顶的指针）来进行数据回收，因为栈是一种先入后出的结构，栈顶的数据是最先废弃掉的，所以通过移动ESP指针来确定栈顶的位置，ESP指针以上的部分就是被回收的可以重新覆盖的数据区域。\n\n### 2.2 堆中的数据如何回收\n\n在回收栈数据中，有一些数据类似Object数据是存储在堆中的，所以即使回收掉栈中的数据，堆中这些垃圾数据依旧没有被处理，那么这些数据该如何处理呢？这要涉及到<u>代际假说</u>的概念。\n\n代际假说有<u>两个特点</u>，分别是大部分对象在对村中存在时间很短，很多对象一经分配内存就会变得不可访问，第二个特点是不死的对象会活很久。\n\n代际假说适用于大多数的<u>动态语言</u>。V8通过将堆分为<u>新生代和老生代</u>两个区域，分别使用<u>副垃圾回收器和主垃圾回收器</u>来实现垃圾回收。\n\n### 2.3 垃圾回收器的工作流程\n\nV8的两个垃圾回收器拥有一套共同的执行流程。\n\n第一步：标记空间中活动对象和非活动对象，活动对象就是还在使用的对象。\n\n第二步：回收非活动对象所占据的内存。\n\n第三步：进行内存整理，一般在回收对象后，内存中会出现大量不连续的空间，如果需要分配较大连续空间时就会出现内存不足的情况，所以需要进行内存整理。而整理<u>内存碎片</u>其实只在老生代中会进行，使用副垃圾回收器无需再新生代进行此步骤。\n\n**副垃圾回收器**：主要负责新生区的垃圾回收，通常情况，大多数<u>小的对象</u>都会被分配到新生区，所以该区域虽然不大但是使用频繁。新生区又对半分为对象区域和空间区域。如下图所示为堆的结构图：\n\n![](/images/react/2022011102.png)\n\n新加入的对象会被放入对象区域，当对象区域被写满时，则需要执行一次垃圾清理操作。\n\n在垃圾回收过程，首先要对对象进行标记，标记完成后会将存货的对象<u>复制</u>到空闲区域，并且将它们<u>有序排列</u>起来，这个过程也相当于完成了<u>内存整理</u>工作。完成复制后会将对象区域和空闲区与进行<u>角色翻转</u>，原来被填满的对象区域变成了空闲区域。以此这样反复循环的使用就是在新生代中采用的<u>Scavenge算法</u>。\n\n由于新生区的空间不大，很容易就被存活对象装满整个区域，所以JavaScript引擎采用了<u>对象晋升策略</u>，将两次垃圾回收仍然存活的新生区对象转移到老生区中。\n\n**主垃圾回收器**：主要负责老生区中的垃圾回收，对比于新生区，它的对象总是<u>占用较大空间或者是存活时间较长</u>。\n\n因为老生区空间较大不适合采用Scavenge算法，其采用了<u>标记-清除（Mark-Sweep）算法</u>进行垃圾回收。\n\n比如，当调用栈中要移除顶部的执行上下文后，就会进行一次数据扫描——此时便利调用栈，发现找不到相应堆中某数据的引用地址，则会标记堆中该数据为垃圾数据，标记完垃圾数据后就是清除阶段，直接清除被标记为垃圾数据的数据，然后采用<u>标记-整理（Mark-Compact）算法</u>进行内存整理。具体的老生区标记清除过程和标记整理过程如下两张图所示。\n\n![](/images/react/2022011103.png)\n\n![](/images/react/2022011104.png)\n\n### 2.4 全停顿\n\n我们已经知道V8是如何进行垃圾回收的，但由于JavaScript是运行在主线程上，一旦执行垃圾回收算法，就需要暂停其他正在执行的JavaScript脚本，直到垃圾回收执行完毕才能继续执行脚本，这种行为叫做<u>全停顿（Stop-The-World）</u>。\n\n全停顿总是会消耗一定时间导致<u>页面卡顿</u>的问题，为了解决这样的现象V8将主垃圾回收器的标记过程分为一个个的<u>子标记</u>过程，让这些块过程和JS脚本交叉运行，这个算法叫做<u>增量标记（Incremental Marking)算法</u>。\n\n## 3.代码编译\n\n要深入理解V8的工作原理，需要理解一些概念和原理，比如接下来要详细介绍的<u>编译器(Compiler)、解释器(Interpreter)、抽象语法树(AST）、字节码(Bytecode)、及时编译器(JIT)</u>。\n\n### 3.1 编译器和解释器\n\n从程序员能够理解的高级语言到机器能够理解的机器语言之间需要使用到编译器/解释器来进行语言的转换。如C/C++、GO等是通过编译器来解析语言的<u>编译型语言</u>；如Python、JavaScript等则是通过解释器来解析语言的<u>解释型语言</u>。以下是编译器和解析器翻译代码的过程图。\n\n![](/images/react/2022011105.png)\n\n从图中你可以看出这二者的执行流程，大致可阐述为如下：\n\n在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功\n\n在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。\n\n### 3.2 V8执行一段JavaScript代码过程\n\n如图所示为V8执行一段JavaScript代码的流程图。\n\n![](/images/react/2022011106.png)\n\n第一步：源代码生成<u>抽象语法树</u>和执行上下文。\n\n这个步骤相当于Html文件转化为浏览器可以理解的DOM树情况雷系，Javascript也是要转化为计算机能够理解的AST结构。这个过程分别运用到了<u>词法分析</u>和<u>语法分析</u>。\n\n第二步：<u>解释器Lgnition</u>根据AST生成<u>字节码</u>。\n\n第三步：判断是否为<u>热点代码(HotSpot)</u>，如果不是则将字节码放入<u>解释器</u>逐条解释执行，如果是则将字节码放入<u>JIT编译器</u>编译成高效的机器码来执行。这样能够提高代码的整体执行效率。\n\n### 3.3 JavaScript的性能优化\n\n主要关注以下三个方面。\n\n- 提升但此脚本的执行速度，避免JavaScript的长任务霸占主线程，这样可以使得页面快速响应交互。\n\n- 避免大的内联脚本，因为在解析HTML的过程中，解析和编译也会占用主线程。\n\n- 减少JavaScript文件容量，因为更小的文件会提升下载速度，并且占用更低的内存。\n","source":"_posts/V8工作原理.md","raw":"---\ntitle: V8工作原理\ndate: 2022-01-11 15:29:49\ntags: [浏览器, JavaScript, 前端面试]\ncategories:\n- 浏览器\n---\n\n---\n\n*本文来源于[http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程](http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82)[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。*\n\n---\n\nV8是谷歌团队研发的一种JavaScript引擎。本文将从数据存储、数据回收、编译机制三个角度来分析JavaScript。\n\n## 1.数据存储\n\n### 1.1 JavaScript是什么类型的语言\n\n如C语言、Java语言就是在定义变量时就<u>需要声明变量类型</u>的语言，这种语言称为<u>静态语言</u>，像Python、JavaScript语言就是定义变量时无需声明变量类型的语言，这种语言叫做<u>动态语言</u>。如下段代码就是静态语言和动态语言的案例对比。\n\n```\n//静态语言-C语言\nint main()\n{\n   int a = 1;\n   char* b = \" 极客时间 \";\n   bool c = true;\n   return 0;\n}\n\n//动态语言-JavaScript语言\nvar a=1\nconsole.log(a,typeof(a))\n```\n\n如C语言、JavaScript语言又可称为<u>弱类型语言</u>，弱类型语言是指可以<u>支持隐式类型转换</u>的语言。反之，不支持隐式类型转换的语言就是<u>强类型语言</u>，如Java、Python。\n\n所以，JavaScript是一种动态的、弱类型的语言。\n\n### 1.2 JavaScript的数据类型\n\nJavaScript一共有<u>8种</u>数据类型，这8种类型可以分为两大类型，分别是<u>基础类型（原始类型）和引用类型</u>。基础类型包括Boolean布尔类型、Null空值、Underfined未定义类型、Nubmber基于IEEE754标准的双精度64位数据类型、BigInt可以曹处Number的安全整数范围限制的新的数据类型、String文本类型、Symbol符号类型不可修改且唯一。引用类型的数据只有一种即<u>Object对象类型</u>。\n\n其中要注意的是，使用typeof方法检测Null类型时返回的是Object（这是一个JavaScript一直以来的Bug）；Object类型是一种由基础类型组成的包含了key-value对的数据类型；基础数据类型和原始数据类型存储的位置不同。\n\n### 1.3 内存空间\n\nJavaScript运行时需要利用内存来存储数据，其中可以将内存分为三个部分分别是<u>代码空间</u>——用来存储可执行代码，<u>栈空间</u>——用来存储执行上下文，以及<u>堆空间</u>。\n\n栈空间用来存储可执行上下文，一般基础数据都直接存储在栈中，而Object数据由于其往往需要占较大内存所以会将其存储在堆中，栈中只存储其内存地址。一般而言，栈空间的大小都是较小的，因为栈空间若是较大，则释放或添加执行上下文则会调用更大的时间，而堆空间一般较大，也可以存储更多的数据。\n\n### 1.4 再谈闭包\n\n以下这段代码涉及到了闭包。\n\n```\nfunction foo() {\n    var myName = \" 极客时间 \"\n    let test1 = 1\n    const test2 = 2\n    var innerBar = { \n        setName:function(newName){\n            myName = newName\n        },\n        getName:function(){\n            console.log(test1)\n            return myName\n        }\n    }\n    return innerBar\n}\nvar bar = foo()\nbar.setName(\" 极客邦 \")\nbar.getName()\nconsole.log(bar.getName())\n```\n\n按道理，foo函数中的 `myName`、`test1`变量都是基础数据，应该直接存储在栈中，而随着foo函数执行完毕也会随之销毁，那么闭包又是怎么形成的呢？这就要分析这段代码的执行流程。\n\n首先JavaScript引擎执行foo函数时，会先编译，并创建一个空的执行上下文，编译过程中，遇到`setName`内部函数时会对其进行<u>一次快速的词法扫描</u>，发现在内部函数中遇到了其外部函数中定义的变量，JavaScript引擎就会判断这是一个闭包，就会在堆空间中创建一个<u>closure(foo)</u>的对象来存储相关变量。同理在`getName`函数中也会将`test1`变量存储在堆中对应位置。这样即使foo函数的执行上下文被移除，闭包中的变量也可以保留。\n\n## 2.垃圾回收\n\n有一些数据使用之后就不再需要，我们将这些数据称为<u>垃圾数据</u>，不同语言都有不同的垃圾回收政策，对于JavaScript语言则有一个<u>自动垃圾回收策略</u>。\n\n### 2.1 调用栈中的数据回收\n\n和操作系统中涉及到的栈结构相似，调用栈是利用<u>ESP指针</u>（永远指向栈顶的指针）来进行数据回收，因为栈是一种先入后出的结构，栈顶的数据是最先废弃掉的，所以通过移动ESP指针来确定栈顶的位置，ESP指针以上的部分就是被回收的可以重新覆盖的数据区域。\n\n### 2.2 堆中的数据如何回收\n\n在回收栈数据中，有一些数据类似Object数据是存储在堆中的，所以即使回收掉栈中的数据，堆中这些垃圾数据依旧没有被处理，那么这些数据该如何处理呢？这要涉及到<u>代际假说</u>的概念。\n\n代际假说有<u>两个特点</u>，分别是大部分对象在对村中存在时间很短，很多对象一经分配内存就会变得不可访问，第二个特点是不死的对象会活很久。\n\n代际假说适用于大多数的<u>动态语言</u>。V8通过将堆分为<u>新生代和老生代</u>两个区域，分别使用<u>副垃圾回收器和主垃圾回收器</u>来实现垃圾回收。\n\n### 2.3 垃圾回收器的工作流程\n\nV8的两个垃圾回收器拥有一套共同的执行流程。\n\n第一步：标记空间中活动对象和非活动对象，活动对象就是还在使用的对象。\n\n第二步：回收非活动对象所占据的内存。\n\n第三步：进行内存整理，一般在回收对象后，内存中会出现大量不连续的空间，如果需要分配较大连续空间时就会出现内存不足的情况，所以需要进行内存整理。而整理<u>内存碎片</u>其实只在老生代中会进行，使用副垃圾回收器无需再新生代进行此步骤。\n\n**副垃圾回收器**：主要负责新生区的垃圾回收，通常情况，大多数<u>小的对象</u>都会被分配到新生区，所以该区域虽然不大但是使用频繁。新生区又对半分为对象区域和空间区域。如下图所示为堆的结构图：\n\n![](/images/react/2022011102.png)\n\n新加入的对象会被放入对象区域，当对象区域被写满时，则需要执行一次垃圾清理操作。\n\n在垃圾回收过程，首先要对对象进行标记，标记完成后会将存货的对象<u>复制</u>到空闲区域，并且将它们<u>有序排列</u>起来，这个过程也相当于完成了<u>内存整理</u>工作。完成复制后会将对象区域和空闲区与进行<u>角色翻转</u>，原来被填满的对象区域变成了空闲区域。以此这样反复循环的使用就是在新生代中采用的<u>Scavenge算法</u>。\n\n由于新生区的空间不大，很容易就被存活对象装满整个区域，所以JavaScript引擎采用了<u>对象晋升策略</u>，将两次垃圾回收仍然存活的新生区对象转移到老生区中。\n\n**主垃圾回收器**：主要负责老生区中的垃圾回收，对比于新生区，它的对象总是<u>占用较大空间或者是存活时间较长</u>。\n\n因为老生区空间较大不适合采用Scavenge算法，其采用了<u>标记-清除（Mark-Sweep）算法</u>进行垃圾回收。\n\n比如，当调用栈中要移除顶部的执行上下文后，就会进行一次数据扫描——此时便利调用栈，发现找不到相应堆中某数据的引用地址，则会标记堆中该数据为垃圾数据，标记完垃圾数据后就是清除阶段，直接清除被标记为垃圾数据的数据，然后采用<u>标记-整理（Mark-Compact）算法</u>进行内存整理。具体的老生区标记清除过程和标记整理过程如下两张图所示。\n\n![](/images/react/2022011103.png)\n\n![](/images/react/2022011104.png)\n\n### 2.4 全停顿\n\n我们已经知道V8是如何进行垃圾回收的，但由于JavaScript是运行在主线程上，一旦执行垃圾回收算法，就需要暂停其他正在执行的JavaScript脚本，直到垃圾回收执行完毕才能继续执行脚本，这种行为叫做<u>全停顿（Stop-The-World）</u>。\n\n全停顿总是会消耗一定时间导致<u>页面卡顿</u>的问题，为了解决这样的现象V8将主垃圾回收器的标记过程分为一个个的<u>子标记</u>过程，让这些块过程和JS脚本交叉运行，这个算法叫做<u>增量标记（Incremental Marking)算法</u>。\n\n## 3.代码编译\n\n要深入理解V8的工作原理，需要理解一些概念和原理，比如接下来要详细介绍的<u>编译器(Compiler)、解释器(Interpreter)、抽象语法树(AST）、字节码(Bytecode)、及时编译器(JIT)</u>。\n\n### 3.1 编译器和解释器\n\n从程序员能够理解的高级语言到机器能够理解的机器语言之间需要使用到编译器/解释器来进行语言的转换。如C/C++、GO等是通过编译器来解析语言的<u>编译型语言</u>；如Python、JavaScript等则是通过解释器来解析语言的<u>解释型语言</u>。以下是编译器和解析器翻译代码的过程图。\n\n![](/images/react/2022011105.png)\n\n从图中你可以看出这二者的执行流程，大致可阐述为如下：\n\n在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功\n\n在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。\n\n### 3.2 V8执行一段JavaScript代码过程\n\n如图所示为V8执行一段JavaScript代码的流程图。\n\n![](/images/react/2022011106.png)\n\n第一步：源代码生成<u>抽象语法树</u>和执行上下文。\n\n这个步骤相当于Html文件转化为浏览器可以理解的DOM树情况雷系，Javascript也是要转化为计算机能够理解的AST结构。这个过程分别运用到了<u>词法分析</u>和<u>语法分析</u>。\n\n第二步：<u>解释器Lgnition</u>根据AST生成<u>字节码</u>。\n\n第三步：判断是否为<u>热点代码(HotSpot)</u>，如果不是则将字节码放入<u>解释器</u>逐条解释执行，如果是则将字节码放入<u>JIT编译器</u>编译成高效的机器码来执行。这样能够提高代码的整体执行效率。\n\n### 3.3 JavaScript的性能优化\n\n主要关注以下三个方面。\n\n- 提升但此脚本的执行速度，避免JavaScript的长任务霸占主线程，这样可以使得页面快速响应交互。\n\n- 避免大的内联脚本，因为在解析HTML的过程中，解析和编译也会占用主线程。\n\n- 减少JavaScript文件容量，因为更小的文件会提升下载速度，并且占用更低的内存。\n","slug":"V8工作原理","published":1,"updated":"2022-01-11T09:31:28.910Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh15000h6wtvfhvl888c","content":"<hr>\n<p><em>本文来源于<a href=\"http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82\">http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程</a><a href=\"https://time.geekbang.org/column/intro/216\">《浏览器工作原理与实践》_-极客时间</a>。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。</em></p>\n<hr>\n<p>V8是谷歌团队研发的一种JavaScript引擎。本文将从数据存储、数据回收、编译机制三个角度来分析JavaScript。</p>\n<h2 id=\"1-数据存储\"><a href=\"#1-数据存储\" class=\"headerlink\" title=\"1.数据存储\"></a>1.数据存储</h2><h3 id=\"1-1-JavaScript是什么类型的语言\"><a href=\"#1-1-JavaScript是什么类型的语言\" class=\"headerlink\" title=\"1.1 JavaScript是什么类型的语言\"></a>1.1 JavaScript是什么类型的语言</h3><p>如C语言、Java语言就是在定义变量时就<u>需要声明变量类型</u>的语言，这种语言称为<u>静态语言</u>，像Python、JavaScript语言就是定义变量时无需声明变量类型的语言，这种语言叫做<u>动态语言</u>。如下段代码就是静态语言和动态语言的案例对比。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-comment\">//静态语言-C语言</span><br><span class=\"hljs-function\"><span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>)</span><br>&#123;<br>   <span class=\"hljs-built_in\">int</span> a = <span class=\"hljs-number\">1</span>;<br>   <span class=\"hljs-built_in\">char</span>* b = <span class=\"hljs-string\">&quot; 极客时间 &quot;</span>;<br>   <span class=\"hljs-built_in\">bool</span> c = <span class=\"hljs-literal\">true</span>;<br>   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">//动态语言-JavaScript语言</span><br><span class=\"hljs-keyword\">var</span> a=<span class=\"hljs-number\">1</span><br>console.log(a,<span class=\"hljs-keyword\">typeof</span>(a))<br></code></pre></td></tr></table></figure>\n\n<p>如C语言、JavaScript语言又可称为<u>弱类型语言</u>，弱类型语言是指可以<u>支持隐式类型转换</u>的语言。反之，不支持隐式类型转换的语言就是<u>强类型语言</u>，如Java、Python。</p>\n<p>所以，JavaScript是一种动态的、弱类型的语言。</p>\n<h3 id=\"1-2-JavaScript的数据类型\"><a href=\"#1-2-JavaScript的数据类型\" class=\"headerlink\" title=\"1.2 JavaScript的数据类型\"></a>1.2 JavaScript的数据类型</h3><p>JavaScript一共有<u>8种</u>数据类型，这8种类型可以分为两大类型，分别是<u>基础类型（原始类型）和引用类型</u>。基础类型包括Boolean布尔类型、Null空值、Underfined未定义类型、Nubmber基于IEEE754标准的双精度64位数据类型、BigInt可以曹处Number的安全整数范围限制的新的数据类型、String文本类型、Symbol符号类型不可修改且唯一。引用类型的数据只有一种即<u>Object对象类型</u>。</p>\n<p>其中要注意的是，使用typeof方法检测Null类型时返回的是Object（这是一个JavaScript一直以来的Bug）；Object类型是一种由基础类型组成的包含了key-value对的数据类型；基础数据类型和原始数据类型存储的位置不同。</p>\n<h3 id=\"1-3-内存空间\"><a href=\"#1-3-内存空间\" class=\"headerlink\" title=\"1.3 内存空间\"></a>1.3 内存空间</h3><p>JavaScript运行时需要利用内存来存储数据，其中可以将内存分为三个部分分别是<u>代码空间</u>——用来存储可执行代码，<u>栈空间</u>——用来存储执行上下文，以及<u>堆空间</u>。</p>\n<p>栈空间用来存储可执行上下文，一般基础数据都直接存储在栈中，而Object数据由于其往往需要占较大内存所以会将其存储在堆中，栈中只存储其内存地址。一般而言，栈空间的大小都是较小的，因为栈空间若是较大，则释放或添加执行上下文则会调用更大的时间，而堆空间一般较大，也可以存储更多的数据。</p>\n<h3 id=\"1-4-再谈闭包\"><a href=\"#1-4-再谈闭包\" class=\"headerlink\" title=\"1.4 再谈闭包\"></a>1.4 再谈闭包</h3><p>以下这段代码涉及到了闭包。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">var</span> myName = <span class=\"hljs-string\">&quot; 极客时间 &quot;</span><br>    <span class=\"hljs-keyword\">let</span> test1 = <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">const</span> test2 = <span class=\"hljs-number\">2</span><br>    <span class=\"hljs-keyword\">var</span> innerBar = &#123; <br>        <span class=\"hljs-attr\">setName</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">newName</span>)</span>&#123;<br>            myName = newName<br>        &#125;,<br>        <span class=\"hljs-attr\">getName</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>            <span class=\"hljs-built_in\">console</span>.log(test1)<br>            <span class=\"hljs-keyword\">return</span> myName<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> innerBar<br>&#125;<br><span class=\"hljs-keyword\">var</span> bar = foo()<br>bar.setName(<span class=\"hljs-string\">&quot; 极客邦 &quot;</span>)<br>bar.getName()<br><span class=\"hljs-built_in\">console</span>.log(bar.getName())<br></code></pre></td></tr></table></figure>\n\n<p>按道理，foo函数中的 <code>myName</code>、<code>test1</code>变量都是基础数据，应该直接存储在栈中，而随着foo函数执行完毕也会随之销毁，那么闭包又是怎么形成的呢？这就要分析这段代码的执行流程。</p>\n<p>首先JavaScript引擎执行foo函数时，会先编译，并创建一个空的执行上下文，编译过程中，遇到<code>setName</code>内部函数时会对其进行<u>一次快速的词法扫描</u>，发现在内部函数中遇到了其外部函数中定义的变量，JavaScript引擎就会判断这是一个闭包，就会在堆空间中创建一个<u>closure(foo)</u>的对象来存储相关变量。同理在<code>getName</code>函数中也会将<code>test1</code>变量存储在堆中对应位置。这样即使foo函数的执行上下文被移除，闭包中的变量也可以保留。</p>\n<h2 id=\"2-垃圾回收\"><a href=\"#2-垃圾回收\" class=\"headerlink\" title=\"2.垃圾回收\"></a>2.垃圾回收</h2><p>有一些数据使用之后就不再需要，我们将这些数据称为<u>垃圾数据</u>，不同语言都有不同的垃圾回收政策，对于JavaScript语言则有一个<u>自动垃圾回收策略</u>。</p>\n<h3 id=\"2-1-调用栈中的数据回收\"><a href=\"#2-1-调用栈中的数据回收\" class=\"headerlink\" title=\"2.1 调用栈中的数据回收\"></a>2.1 调用栈中的数据回收</h3><p>和操作系统中涉及到的栈结构相似，调用栈是利用<u>ESP指针</u>（永远指向栈顶的指针）来进行数据回收，因为栈是一种先入后出的结构，栈顶的数据是最先废弃掉的，所以通过移动ESP指针来确定栈顶的位置，ESP指针以上的部分就是被回收的可以重新覆盖的数据区域。</p>\n<h3 id=\"2-2-堆中的数据如何回收\"><a href=\"#2-2-堆中的数据如何回收\" class=\"headerlink\" title=\"2.2 堆中的数据如何回收\"></a>2.2 堆中的数据如何回收</h3><p>在回收栈数据中，有一些数据类似Object数据是存储在堆中的，所以即使回收掉栈中的数据，堆中这些垃圾数据依旧没有被处理，那么这些数据该如何处理呢？这要涉及到<u>代际假说</u>的概念。</p>\n<p>代际假说有<u>两个特点</u>，分别是大部分对象在对村中存在时间很短，很多对象一经分配内存就会变得不可访问，第二个特点是不死的对象会活很久。</p>\n<p>代际假说适用于大多数的<u>动态语言</u>。V8通过将堆分为<u>新生代和老生代</u>两个区域，分别使用<u>副垃圾回收器和主垃圾回收器</u>来实现垃圾回收。</p>\n<h3 id=\"2-3-垃圾回收器的工作流程\"><a href=\"#2-3-垃圾回收器的工作流程\" class=\"headerlink\" title=\"2.3 垃圾回收器的工作流程\"></a>2.3 垃圾回收器的工作流程</h3><p>V8的两个垃圾回收器拥有一套共同的执行流程。</p>\n<p>第一步：标记空间中活动对象和非活动对象，活动对象就是还在使用的对象。</p>\n<p>第二步：回收非活动对象所占据的内存。</p>\n<p>第三步：进行内存整理，一般在回收对象后，内存中会出现大量不连续的空间，如果需要分配较大连续空间时就会出现内存不足的情况，所以需要进行内存整理。而整理<u>内存碎片</u>其实只在老生代中会进行，使用副垃圾回收器无需再新生代进行此步骤。</p>\n<p><strong>副垃圾回收器</strong>：主要负责新生区的垃圾回收，通常情况，大多数<u>小的对象</u>都会被分配到新生区，所以该区域虽然不大但是使用频繁。新生区又对半分为对象区域和空间区域。如下图所示为堆的结构图：</p>\n<p><img src=\"/images/react/2022011102.png\"></p>\n<p>新加入的对象会被放入对象区域，当对象区域被写满时，则需要执行一次垃圾清理操作。</p>\n<p>在垃圾回收过程，首先要对对象进行标记，标记完成后会将存货的对象<u>复制</u>到空闲区域，并且将它们<u>有序排列</u>起来，这个过程也相当于完成了<u>内存整理</u>工作。完成复制后会将对象区域和空闲区与进行<u>角色翻转</u>，原来被填满的对象区域变成了空闲区域。以此这样反复循环的使用就是在新生代中采用的<u>Scavenge算法</u>。</p>\n<p>由于新生区的空间不大，很容易就被存活对象装满整个区域，所以JavaScript引擎采用了<u>对象晋升策略</u>，将两次垃圾回收仍然存活的新生区对象转移到老生区中。</p>\n<p><strong>主垃圾回收器</strong>：主要负责老生区中的垃圾回收，对比于新生区，它的对象总是<u>占用较大空间或者是存活时间较长</u>。</p>\n<p>因为老生区空间较大不适合采用Scavenge算法，其采用了<u>标记-清除（Mark-Sweep）算法</u>进行垃圾回收。</p>\n<p>比如，当调用栈中要移除顶部的执行上下文后，就会进行一次数据扫描——此时便利调用栈，发现找不到相应堆中某数据的引用地址，则会标记堆中该数据为垃圾数据，标记完垃圾数据后就是清除阶段，直接清除被标记为垃圾数据的数据，然后采用<u>标记-整理（Mark-Compact）算法</u>进行内存整理。具体的老生区标记清除过程和标记整理过程如下两张图所示。</p>\n<p><img src=\"/images/react/2022011103.png\"></p>\n<p><img src=\"/images/react/2022011104.png\"></p>\n<h3 id=\"2-4-全停顿\"><a href=\"#2-4-全停顿\" class=\"headerlink\" title=\"2.4 全停顿\"></a>2.4 全停顿</h3><p>我们已经知道V8是如何进行垃圾回收的，但由于JavaScript是运行在主线程上，一旦执行垃圾回收算法，就需要暂停其他正在执行的JavaScript脚本，直到垃圾回收执行完毕才能继续执行脚本，这种行为叫做<u>全停顿（Stop-The-World）</u>。</p>\n<p>全停顿总是会消耗一定时间导致<u>页面卡顿</u>的问题，为了解决这样的现象V8将主垃圾回收器的标记过程分为一个个的<u>子标记</u>过程，让这些块过程和JS脚本交叉运行，这个算法叫做<u>增量标记（Incremental Marking)算法</u>。</p>\n<h2 id=\"3-代码编译\"><a href=\"#3-代码编译\" class=\"headerlink\" title=\"3.代码编译\"></a>3.代码编译</h2><p>要深入理解V8的工作原理，需要理解一些概念和原理，比如接下来要详细介绍的<u>编译器(Compiler)、解释器(Interpreter)、抽象语法树(AST）、字节码(Bytecode)、及时编译器(JIT)</u>。</p>\n<h3 id=\"3-1-编译器和解释器\"><a href=\"#3-1-编译器和解释器\" class=\"headerlink\" title=\"3.1 编译器和解释器\"></a>3.1 编译器和解释器</h3><p>从程序员能够理解的高级语言到机器能够理解的机器语言之间需要使用到编译器/解释器来进行语言的转换。如C/C++、GO等是通过编译器来解析语言的<u>编译型语言</u>；如Python、JavaScript等则是通过解释器来解析语言的<u>解释型语言</u>。以下是编译器和解析器翻译代码的过程图。</p>\n<p><img src=\"/images/react/2022011105.png\"></p>\n<p>从图中你可以看出这二者的执行流程，大致可阐述为如下：</p>\n<p>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功</p>\n<p>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</p>\n<h3 id=\"3-2-V8执行一段JavaScript代码过程\"><a href=\"#3-2-V8执行一段JavaScript代码过程\" class=\"headerlink\" title=\"3.2 V8执行一段JavaScript代码过程\"></a>3.2 V8执行一段JavaScript代码过程</h3><p>如图所示为V8执行一段JavaScript代码的流程图。</p>\n<p><img src=\"/images/react/2022011106.png\"></p>\n<p>第一步：源代码生成<u>抽象语法树</u>和执行上下文。</p>\n<p>这个步骤相当于Html文件转化为浏览器可以理解的DOM树情况雷系，Javascript也是要转化为计算机能够理解的AST结构。这个过程分别运用到了<u>词法分析</u>和<u>语法分析</u>。</p>\n<p>第二步：<u>解释器Lgnition</u>根据AST生成<u>字节码</u>。</p>\n<p>第三步：判断是否为<u>热点代码(HotSpot)</u>，如果不是则将字节码放入<u>解释器</u>逐条解释执行，如果是则将字节码放入<u>JIT编译器</u>编译成高效的机器码来执行。这样能够提高代码的整体执行效率。</p>\n<h3 id=\"3-3-JavaScript的性能优化\"><a href=\"#3-3-JavaScript的性能优化\" class=\"headerlink\" title=\"3.3 JavaScript的性能优化\"></a>3.3 JavaScript的性能优化</h3><p>主要关注以下三个方面。</p>\n<ul>\n<li><p>提升但此脚本的执行速度，避免JavaScript的长任务霸占主线程，这样可以使得页面快速响应交互。</p>\n</li>\n<li><p>避免大的内联脚本，因为在解析HTML的过程中，解析和编译也会占用主线程。</p>\n</li>\n<li><p>减少JavaScript文件容量，因为更小的文件会提升下载速度，并且占用更低的内存。</p>\n</li>\n</ul>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>本文来源于<a href=\"http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82\">http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程</a><a href=\"https://time.geekbang.org/column/intro/216\">《浏览器工作原理与实践》_-极客时间</a>。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。</em></p>\n<hr>\n<p>V8是谷歌团队研发的一种JavaScript引擎。本文将从数据存储、数据回收、编译机制三个角度来分析JavaScript。</p>\n<h2 id=\"1-数据存储\"><a href=\"#1-数据存储\" class=\"headerlink\" title=\"1.数据存储\"></a>1.数据存储</h2><h3 id=\"1-1-JavaScript是什么类型的语言\"><a href=\"#1-1-JavaScript是什么类型的语言\" class=\"headerlink\" title=\"1.1 JavaScript是什么类型的语言\"></a>1.1 JavaScript是什么类型的语言</h3><p>如C语言、Java语言就是在定义变量时就<u>需要声明变量类型</u>的语言，这种语言称为<u>静态语言</u>，像Python、JavaScript语言就是定义变量时无需声明变量类型的语言，这种语言叫做<u>动态语言</u>。如下段代码就是静态语言和动态语言的案例对比。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-comment\">//静态语言-C语言</span><br><span class=\"hljs-function\"><span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>)</span><br>&#123;<br>   <span class=\"hljs-built_in\">int</span> a = <span class=\"hljs-number\">1</span>;<br>   <span class=\"hljs-built_in\">char</span>* b = <span class=\"hljs-string\">&quot; 极客时间 &quot;</span>;<br>   <span class=\"hljs-built_in\">bool</span> c = <span class=\"hljs-literal\">true</span>;<br>   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">//动态语言-JavaScript语言</span><br><span class=\"hljs-keyword\">var</span> a=<span class=\"hljs-number\">1</span><br>console.log(a,<span class=\"hljs-keyword\">typeof</span>(a))<br></code></pre></td></tr></table></figure>\n\n<p>如C语言、JavaScript语言又可称为<u>弱类型语言</u>，弱类型语言是指可以<u>支持隐式类型转换</u>的语言。反之，不支持隐式类型转换的语言就是<u>强类型语言</u>，如Java、Python。</p>\n<p>所以，JavaScript是一种动态的、弱类型的语言。</p>\n<h3 id=\"1-2-JavaScript的数据类型\"><a href=\"#1-2-JavaScript的数据类型\" class=\"headerlink\" title=\"1.2 JavaScript的数据类型\"></a>1.2 JavaScript的数据类型</h3><p>JavaScript一共有<u>8种</u>数据类型，这8种类型可以分为两大类型，分别是<u>基础类型（原始类型）和引用类型</u>。基础类型包括Boolean布尔类型、Null空值、Underfined未定义类型、Nubmber基于IEEE754标准的双精度64位数据类型、BigInt可以曹处Number的安全整数范围限制的新的数据类型、String文本类型、Symbol符号类型不可修改且唯一。引用类型的数据只有一种即<u>Object对象类型</u>。</p>\n<p>其中要注意的是，使用typeof方法检测Null类型时返回的是Object（这是一个JavaScript一直以来的Bug）；Object类型是一种由基础类型组成的包含了key-value对的数据类型；基础数据类型和原始数据类型存储的位置不同。</p>\n<h3 id=\"1-3-内存空间\"><a href=\"#1-3-内存空间\" class=\"headerlink\" title=\"1.3 内存空间\"></a>1.3 内存空间</h3><p>JavaScript运行时需要利用内存来存储数据，其中可以将内存分为三个部分分别是<u>代码空间</u>——用来存储可执行代码，<u>栈空间</u>——用来存储执行上下文，以及<u>堆空间</u>。</p>\n<p>栈空间用来存储可执行上下文，一般基础数据都直接存储在栈中，而Object数据由于其往往需要占较大内存所以会将其存储在堆中，栈中只存储其内存地址。一般而言，栈空间的大小都是较小的，因为栈空间若是较大，则释放或添加执行上下文则会调用更大的时间，而堆空间一般较大，也可以存储更多的数据。</p>\n<h3 id=\"1-4-再谈闭包\"><a href=\"#1-4-再谈闭包\" class=\"headerlink\" title=\"1.4 再谈闭包\"></a>1.4 再谈闭包</h3><p>以下这段代码涉及到了闭包。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">var</span> myName = <span class=\"hljs-string\">&quot; 极客时间 &quot;</span><br>    <span class=\"hljs-keyword\">let</span> test1 = <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">const</span> test2 = <span class=\"hljs-number\">2</span><br>    <span class=\"hljs-keyword\">var</span> innerBar = &#123; <br>        <span class=\"hljs-attr\">setName</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">newName</span>)</span>&#123;<br>            myName = newName<br>        &#125;,<br>        <span class=\"hljs-attr\">getName</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>            <span class=\"hljs-built_in\">console</span>.log(test1)<br>            <span class=\"hljs-keyword\">return</span> myName<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> innerBar<br>&#125;<br><span class=\"hljs-keyword\">var</span> bar = foo()<br>bar.setName(<span class=\"hljs-string\">&quot; 极客邦 &quot;</span>)<br>bar.getName()<br><span class=\"hljs-built_in\">console</span>.log(bar.getName())<br></code></pre></td></tr></table></figure>\n\n<p>按道理，foo函数中的 <code>myName</code>、<code>test1</code>变量都是基础数据，应该直接存储在栈中，而随着foo函数执行完毕也会随之销毁，那么闭包又是怎么形成的呢？这就要分析这段代码的执行流程。</p>\n<p>首先JavaScript引擎执行foo函数时，会先编译，并创建一个空的执行上下文，编译过程中，遇到<code>setName</code>内部函数时会对其进行<u>一次快速的词法扫描</u>，发现在内部函数中遇到了其外部函数中定义的变量，JavaScript引擎就会判断这是一个闭包，就会在堆空间中创建一个<u>closure(foo)</u>的对象来存储相关变量。同理在<code>getName</code>函数中也会将<code>test1</code>变量存储在堆中对应位置。这样即使foo函数的执行上下文被移除，闭包中的变量也可以保留。</p>\n<h2 id=\"2-垃圾回收\"><a href=\"#2-垃圾回收\" class=\"headerlink\" title=\"2.垃圾回收\"></a>2.垃圾回收</h2><p>有一些数据使用之后就不再需要，我们将这些数据称为<u>垃圾数据</u>，不同语言都有不同的垃圾回收政策，对于JavaScript语言则有一个<u>自动垃圾回收策略</u>。</p>\n<h3 id=\"2-1-调用栈中的数据回收\"><a href=\"#2-1-调用栈中的数据回收\" class=\"headerlink\" title=\"2.1 调用栈中的数据回收\"></a>2.1 调用栈中的数据回收</h3><p>和操作系统中涉及到的栈结构相似，调用栈是利用<u>ESP指针</u>（永远指向栈顶的指针）来进行数据回收，因为栈是一种先入后出的结构，栈顶的数据是最先废弃掉的，所以通过移动ESP指针来确定栈顶的位置，ESP指针以上的部分就是被回收的可以重新覆盖的数据区域。</p>\n<h3 id=\"2-2-堆中的数据如何回收\"><a href=\"#2-2-堆中的数据如何回收\" class=\"headerlink\" title=\"2.2 堆中的数据如何回收\"></a>2.2 堆中的数据如何回收</h3><p>在回收栈数据中，有一些数据类似Object数据是存储在堆中的，所以即使回收掉栈中的数据，堆中这些垃圾数据依旧没有被处理，那么这些数据该如何处理呢？这要涉及到<u>代际假说</u>的概念。</p>\n<p>代际假说有<u>两个特点</u>，分别是大部分对象在对村中存在时间很短，很多对象一经分配内存就会变得不可访问，第二个特点是不死的对象会活很久。</p>\n<p>代际假说适用于大多数的<u>动态语言</u>。V8通过将堆分为<u>新生代和老生代</u>两个区域，分别使用<u>副垃圾回收器和主垃圾回收器</u>来实现垃圾回收。</p>\n<h3 id=\"2-3-垃圾回收器的工作流程\"><a href=\"#2-3-垃圾回收器的工作流程\" class=\"headerlink\" title=\"2.3 垃圾回收器的工作流程\"></a>2.3 垃圾回收器的工作流程</h3><p>V8的两个垃圾回收器拥有一套共同的执行流程。</p>\n<p>第一步：标记空间中活动对象和非活动对象，活动对象就是还在使用的对象。</p>\n<p>第二步：回收非活动对象所占据的内存。</p>\n<p>第三步：进行内存整理，一般在回收对象后，内存中会出现大量不连续的空间，如果需要分配较大连续空间时就会出现内存不足的情况，所以需要进行内存整理。而整理<u>内存碎片</u>其实只在老生代中会进行，使用副垃圾回收器无需再新生代进行此步骤。</p>\n<p><strong>副垃圾回收器</strong>：主要负责新生区的垃圾回收，通常情况，大多数<u>小的对象</u>都会被分配到新生区，所以该区域虽然不大但是使用频繁。新生区又对半分为对象区域和空间区域。如下图所示为堆的结构图：</p>\n<p><img src=\"/images/react/2022011102.png\"></p>\n<p>新加入的对象会被放入对象区域，当对象区域被写满时，则需要执行一次垃圾清理操作。</p>\n<p>在垃圾回收过程，首先要对对象进行标记，标记完成后会将存货的对象<u>复制</u>到空闲区域，并且将它们<u>有序排列</u>起来，这个过程也相当于完成了<u>内存整理</u>工作。完成复制后会将对象区域和空闲区与进行<u>角色翻转</u>，原来被填满的对象区域变成了空闲区域。以此这样反复循环的使用就是在新生代中采用的<u>Scavenge算法</u>。</p>\n<p>由于新生区的空间不大，很容易就被存活对象装满整个区域，所以JavaScript引擎采用了<u>对象晋升策略</u>，将两次垃圾回收仍然存活的新生区对象转移到老生区中。</p>\n<p><strong>主垃圾回收器</strong>：主要负责老生区中的垃圾回收，对比于新生区，它的对象总是<u>占用较大空间或者是存活时间较长</u>。</p>\n<p>因为老生区空间较大不适合采用Scavenge算法，其采用了<u>标记-清除（Mark-Sweep）算法</u>进行垃圾回收。</p>\n<p>比如，当调用栈中要移除顶部的执行上下文后，就会进行一次数据扫描——此时便利调用栈，发现找不到相应堆中某数据的引用地址，则会标记堆中该数据为垃圾数据，标记完垃圾数据后就是清除阶段，直接清除被标记为垃圾数据的数据，然后采用<u>标记-整理（Mark-Compact）算法</u>进行内存整理。具体的老生区标记清除过程和标记整理过程如下两张图所示。</p>\n<p><img src=\"/images/react/2022011103.png\"></p>\n<p><img src=\"/images/react/2022011104.png\"></p>\n<h3 id=\"2-4-全停顿\"><a href=\"#2-4-全停顿\" class=\"headerlink\" title=\"2.4 全停顿\"></a>2.4 全停顿</h3><p>我们已经知道V8是如何进行垃圾回收的，但由于JavaScript是运行在主线程上，一旦执行垃圾回收算法，就需要暂停其他正在执行的JavaScript脚本，直到垃圾回收执行完毕才能继续执行脚本，这种行为叫做<u>全停顿（Stop-The-World）</u>。</p>\n<p>全停顿总是会消耗一定时间导致<u>页面卡顿</u>的问题，为了解决这样的现象V8将主垃圾回收器的标记过程分为一个个的<u>子标记</u>过程，让这些块过程和JS脚本交叉运行，这个算法叫做<u>增量标记（Incremental Marking)算法</u>。</p>\n<h2 id=\"3-代码编译\"><a href=\"#3-代码编译\" class=\"headerlink\" title=\"3.代码编译\"></a>3.代码编译</h2><p>要深入理解V8的工作原理，需要理解一些概念和原理，比如接下来要详细介绍的<u>编译器(Compiler)、解释器(Interpreter)、抽象语法树(AST）、字节码(Bytecode)、及时编译器(JIT)</u>。</p>\n<h3 id=\"3-1-编译器和解释器\"><a href=\"#3-1-编译器和解释器\" class=\"headerlink\" title=\"3.1 编译器和解释器\"></a>3.1 编译器和解释器</h3><p>从程序员能够理解的高级语言到机器能够理解的机器语言之间需要使用到编译器/解释器来进行语言的转换。如C/C++、GO等是通过编译器来解析语言的<u>编译型语言</u>；如Python、JavaScript等则是通过解释器来解析语言的<u>解释型语言</u>。以下是编译器和解析器翻译代码的过程图。</p>\n<p><img src=\"/images/react/2022011105.png\"></p>\n<p>从图中你可以看出这二者的执行流程，大致可阐述为如下：</p>\n<p>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功</p>\n<p>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</p>\n<h3 id=\"3-2-V8执行一段JavaScript代码过程\"><a href=\"#3-2-V8执行一段JavaScript代码过程\" class=\"headerlink\" title=\"3.2 V8执行一段JavaScript代码过程\"></a>3.2 V8执行一段JavaScript代码过程</h3><p>如图所示为V8执行一段JavaScript代码的流程图。</p>\n<p><img src=\"/images/react/2022011106.png\"></p>\n<p>第一步：源代码生成<u>抽象语法树</u>和执行上下文。</p>\n<p>这个步骤相当于Html文件转化为浏览器可以理解的DOM树情况雷系，Javascript也是要转化为计算机能够理解的AST结构。这个过程分别运用到了<u>词法分析</u>和<u>语法分析</u>。</p>\n<p>第二步：<u>解释器Lgnition</u>根据AST生成<u>字节码</u>。</p>\n<p>第三步：判断是否为<u>热点代码(HotSpot)</u>，如果不是则将字节码放入<u>解释器</u>逐条解释执行，如果是则将字节码放入<u>JIT编译器</u>编译成高效的机器码来执行。这样能够提高代码的整体执行效率。</p>\n<h3 id=\"3-3-JavaScript的性能优化\"><a href=\"#3-3-JavaScript的性能优化\" class=\"headerlink\" title=\"3.3 JavaScript的性能优化\"></a>3.3 JavaScript的性能优化</h3><p>主要关注以下三个方面。</p>\n<ul>\n<li><p>提升但此脚本的执行速度，避免JavaScript的长任务霸占主线程，这样可以使得页面快速响应交互。</p>\n</li>\n<li><p>避免大的内联脚本，因为在解析HTML的过程中，解析和编译也会占用主线程。</p>\n</li>\n<li><p>减少JavaScript文件容量，因为更小的文件会提升下载速度，并且占用更低的内存。</p>\n</li>\n</ul>\n"},{"title":"一封信","date":"2022-01-12T06:15:43.000Z","toc":false,"image":"/images/2022011201.png","_content":"\n我时常在浪漫和理智中徘徊。\n\n一个在浪漫和理智中徘徊的人到底是一个理想主义者还是现实主义者呢？\n\n我总是对自己说：别写这么傻的信，即使你看了也只会扫上两眼然后对别人说：XXX给我写了一封无聊的东西。最后用草稿纸的背面写几个字回我。\n\n此外，时间过去很久了，久到我似乎没有理由写这样的信，久到这封信变得不是为你写的，而是为我自己写的。可是，写来写去也是欺骗自己，为自己打造一副自己情深的可笑场面。因为我明明已经释然了已经习惯了却偏偏还要回忆。\n\n前天晚上梦见了你，以前，三年前的时候，我每次梦见你都会在备忘录上记下一笔，不过后来梦见你的次数实在太多了，也就没再记录。前天我梦见，你对你的专业不满意，你想要转专业，你转了我这个专业，又和我一起读书了。大概是因为我有基础吧，老师总是表扬我，然后你也对我刮目相看，我在梦里想：现在你应该注意到我了，我该找个什么机会和你自然地和好呢。\n\n其实每一次梦见你都是这样的，每一次我都想在梦里与你和好，有几次和好成功了，有几次正在试探中，有几次非常浪漫，有一次的梦里，我要回高中处理一些事情，我抬头看到了宛如极光的天空，我发出感慨，朝着这绚烂的天边走去，然后我遇见了也在抬头看天的你。有一次的梦里，你主动来和好，我真开心，第二天我们一起吃早饭，我问你：为什么想要和好呢？你说：因为你是主角啊（因为是在你的梦里啊），然后突然意识到自己是在做梦。有一次的梦非常真实，我已经忘记了到底梦见什么，不外乎我们和好了，我太高兴了，高兴到在梦中反复询问这不会是在做梦吧这不会是在做梦吧，然后我突然被闹钟吵醒了，从混沌到彻底清醒的那段时间似乎变得很漫长，我的心脏从开始的狂跳不止逐渐恢复正常，然后就是失望、心灰意冷、一种无法相信那竟然只是梦的质疑。\n\n2017年的时候，我写过一封表白信给你，发送出去了的，给十年后的你，前段日子我再次浏览那个网站的时候，发现有追溯以前信件的功能，我搜了一下，发现我写给你的信失踪了。没有逃过一劫的窃喜，只有遗憾。虽然打扰未来的你是一件不太负责任的事情，但我还是希望那份心意能沿着时空隧道传到未来的你那里。2017年秋天的那个晚上，我写了又删，小心翼翼打下一个个幼稚的文字（现在隐约记得，是蛮幼稚和天真的），选择的时间是十年后，填写的收件人邮箱是你的QQ邮箱，然后我点了公开信。我还以为公开信是对方收到信后才公开，可是我点击发送后就在公开列表中看到了它。\n\n非常慌张，我害怕被你看到，我只要一考虑到有这个可能性，一考虑到你有可能会看到，一想到如果你那时就看了我们也许连朋友都做不了，我就慌张地不知所措，然后我就非常笨拙地写下了几十封上百封的公开信吧，收件人一开始是我的邮箱，然后是不知道是谁的邮箱，信的内容也是乱七八糟的复制粘贴的，那一天我大概花了四五个小时都在写公开信，只是想把我写给你的那封信隐藏在角落里。即使这样，我还是不放心，我记得那个时候已经是早上四点了，我找到了网站开发者的微博账号，在账号上私信他，发了很多很多骚扰文字，然后终于还是睡着了，醒来后第一件事就是看微博私信，收到他的回复：已删——我才松了一口气。\n\n可是，没想到他是把这封信彻底删了。我好遗憾啊。\n\n我为什么就喜欢上你了呢？回忆已经被美化滤镜过滤了一遍，我偶尔回忆起来的也只是你很美好这件事了，现在我回忆起你的时间越来越短，回忆的内容也越来越单薄，过去，不知道是前年还是去年的时候，我突然回忆起关于你的什么事情来，然后一阵恍惚，因为我意识到我已经忘记了好多好多回忆了，是很难受的，我不希望忘记这些回忆。\n\n还是说现在的事情吧，也许是因为我不知道怎么去讲述我过去对你的感情，我担心你不会想听的，因为，我在那段时间里总是在悲伤中、痛苦中、嫉妒中。\n\n昨天我在b站上看到了一个刚刚从失恋中走出来的up主发的新视频，她说她失恋时非常地痛苦，让我突然觉得我那时的痛苦好像变得无所谓了，因为不是只有我一个人经历过这样的痛苦，也许百分之五十的人都会经历过，这样就显得我的过去是一段很寻常的往事。可是我还是会觉得，我和那个up主是不一样的，因为我喜欢的人比她喜欢的人要好很多。大概是因为我一直都是暗恋你的缘故吧，所以你真的变得无比美好了，不，即使排除这些区别，你也比别人好上很多，你真的无比美好，我现在还是觉得你是我应该追逐的存在。我以前做了很多很多愚蠢的事情，比方说我为了给你一个人写明信片，我会给全班交好的女生都写上一张明信片，大概这样就能隐藏我对你的情感了吧。\n\n如果我记得没错的话，那张明信片上其实只有一句话：遇见你是一件很幸运的事情。一开始是写满了整张明信片的文字，只有最后一句是这句话，我觉得文字太多显得我絮叨，就重写了一张，写着写着，换了很多明信片，变得只剩下这一句话了。又因为我的字实在是不好看，这句话我也写了好几遍。但是，即使是现在我也想对你说：谢谢你，遇见你是一件很幸运的事。\n\n我翻高中的日记，我在日记里是这样形容我对你的感情：我确定我对她的感情不是爱情，因为爱情可能会冷淡但是我对她的感情永远也不会改变。不过我还是偷偷写了很多表白信给你，不是写给未来的你，是写给那时的你。有一阵子，我每天都在被子里练字——是写表白信，只是白天总是不敢交给你而已。不过那都是高三后面的事情了，我和你“绝交”时的事情了。我很早就对你有了超过友谊的情感，有一天晚上我突然梦见你对我表白，让我意识到我喜欢上你了，当然我是害怕的，我那时更傻，女生喜欢女生对于我来说是很不可思议的事情，我下意识地忽略和遗忘这件事，所以那段时间很多情况我自己都没有意识到我在做什么。现在想想真好笑，我甚至还在无意间和你表白过，那句话太露骨了，其实就等于表白了，可是我是出自真心说出的，完全不加思考，当时也完全意识不到这句话意味着什么。\n\n对不起，对不起，真的很对不起，我突然想起了很多画面，我想起了你的眼神，我想起了你对我说的话，你大概是知道我喜欢你的，甚至不需要大概，你就是知道我喜欢你吧，也许不只是你，其他人也多少意识到了，那时我真的很傻，我喜欢一个人，但是我完全不知道该怎么表达自己的喜欢，完全不知道要怎么去追求她，谢谢你，真的谢谢你，我觉得我是应该满足了，我真后悔那次毕业散伙饭我没有穿的好看一点。谢谢你。\n\n你就是我的莉拉，我是莱农，我是爱上莉拉的莱农，真可惜她们两个人走散了，也许不再相聚了，可是，莱农是因为莉拉才变成莱农的。谢谢你。\n","source":"_posts/一封信.md","raw":"---\ntitle: 一封信\ndate: 2022-01-12 14:15:43\ntoc: false\nimage: /images/2022011201.png\ntags:\n\n---\n\n我时常在浪漫和理智中徘徊。\n\n一个在浪漫和理智中徘徊的人到底是一个理想主义者还是现实主义者呢？\n\n我总是对自己说：别写这么傻的信，即使你看了也只会扫上两眼然后对别人说：XXX给我写了一封无聊的东西。最后用草稿纸的背面写几个字回我。\n\n此外，时间过去很久了，久到我似乎没有理由写这样的信，久到这封信变得不是为你写的，而是为我自己写的。可是，写来写去也是欺骗自己，为自己打造一副自己情深的可笑场面。因为我明明已经释然了已经习惯了却偏偏还要回忆。\n\n前天晚上梦见了你，以前，三年前的时候，我每次梦见你都会在备忘录上记下一笔，不过后来梦见你的次数实在太多了，也就没再记录。前天我梦见，你对你的专业不满意，你想要转专业，你转了我这个专业，又和我一起读书了。大概是因为我有基础吧，老师总是表扬我，然后你也对我刮目相看，我在梦里想：现在你应该注意到我了，我该找个什么机会和你自然地和好呢。\n\n其实每一次梦见你都是这样的，每一次我都想在梦里与你和好，有几次和好成功了，有几次正在试探中，有几次非常浪漫，有一次的梦里，我要回高中处理一些事情，我抬头看到了宛如极光的天空，我发出感慨，朝着这绚烂的天边走去，然后我遇见了也在抬头看天的你。有一次的梦里，你主动来和好，我真开心，第二天我们一起吃早饭，我问你：为什么想要和好呢？你说：因为你是主角啊（因为是在你的梦里啊），然后突然意识到自己是在做梦。有一次的梦非常真实，我已经忘记了到底梦见什么，不外乎我们和好了，我太高兴了，高兴到在梦中反复询问这不会是在做梦吧这不会是在做梦吧，然后我突然被闹钟吵醒了，从混沌到彻底清醒的那段时间似乎变得很漫长，我的心脏从开始的狂跳不止逐渐恢复正常，然后就是失望、心灰意冷、一种无法相信那竟然只是梦的质疑。\n\n2017年的时候，我写过一封表白信给你，发送出去了的，给十年后的你，前段日子我再次浏览那个网站的时候，发现有追溯以前信件的功能，我搜了一下，发现我写给你的信失踪了。没有逃过一劫的窃喜，只有遗憾。虽然打扰未来的你是一件不太负责任的事情，但我还是希望那份心意能沿着时空隧道传到未来的你那里。2017年秋天的那个晚上，我写了又删，小心翼翼打下一个个幼稚的文字（现在隐约记得，是蛮幼稚和天真的），选择的时间是十年后，填写的收件人邮箱是你的QQ邮箱，然后我点了公开信。我还以为公开信是对方收到信后才公开，可是我点击发送后就在公开列表中看到了它。\n\n非常慌张，我害怕被你看到，我只要一考虑到有这个可能性，一考虑到你有可能会看到，一想到如果你那时就看了我们也许连朋友都做不了，我就慌张地不知所措，然后我就非常笨拙地写下了几十封上百封的公开信吧，收件人一开始是我的邮箱，然后是不知道是谁的邮箱，信的内容也是乱七八糟的复制粘贴的，那一天我大概花了四五个小时都在写公开信，只是想把我写给你的那封信隐藏在角落里。即使这样，我还是不放心，我记得那个时候已经是早上四点了，我找到了网站开发者的微博账号，在账号上私信他，发了很多很多骚扰文字，然后终于还是睡着了，醒来后第一件事就是看微博私信，收到他的回复：已删——我才松了一口气。\n\n可是，没想到他是把这封信彻底删了。我好遗憾啊。\n\n我为什么就喜欢上你了呢？回忆已经被美化滤镜过滤了一遍，我偶尔回忆起来的也只是你很美好这件事了，现在我回忆起你的时间越来越短，回忆的内容也越来越单薄，过去，不知道是前年还是去年的时候，我突然回忆起关于你的什么事情来，然后一阵恍惚，因为我意识到我已经忘记了好多好多回忆了，是很难受的，我不希望忘记这些回忆。\n\n还是说现在的事情吧，也许是因为我不知道怎么去讲述我过去对你的感情，我担心你不会想听的，因为，我在那段时间里总是在悲伤中、痛苦中、嫉妒中。\n\n昨天我在b站上看到了一个刚刚从失恋中走出来的up主发的新视频，她说她失恋时非常地痛苦，让我突然觉得我那时的痛苦好像变得无所谓了，因为不是只有我一个人经历过这样的痛苦，也许百分之五十的人都会经历过，这样就显得我的过去是一段很寻常的往事。可是我还是会觉得，我和那个up主是不一样的，因为我喜欢的人比她喜欢的人要好很多。大概是因为我一直都是暗恋你的缘故吧，所以你真的变得无比美好了，不，即使排除这些区别，你也比别人好上很多，你真的无比美好，我现在还是觉得你是我应该追逐的存在。我以前做了很多很多愚蠢的事情，比方说我为了给你一个人写明信片，我会给全班交好的女生都写上一张明信片，大概这样就能隐藏我对你的情感了吧。\n\n如果我记得没错的话，那张明信片上其实只有一句话：遇见你是一件很幸运的事情。一开始是写满了整张明信片的文字，只有最后一句是这句话，我觉得文字太多显得我絮叨，就重写了一张，写着写着，换了很多明信片，变得只剩下这一句话了。又因为我的字实在是不好看，这句话我也写了好几遍。但是，即使是现在我也想对你说：谢谢你，遇见你是一件很幸运的事。\n\n我翻高中的日记，我在日记里是这样形容我对你的感情：我确定我对她的感情不是爱情，因为爱情可能会冷淡但是我对她的感情永远也不会改变。不过我还是偷偷写了很多表白信给你，不是写给未来的你，是写给那时的你。有一阵子，我每天都在被子里练字——是写表白信，只是白天总是不敢交给你而已。不过那都是高三后面的事情了，我和你“绝交”时的事情了。我很早就对你有了超过友谊的情感，有一天晚上我突然梦见你对我表白，让我意识到我喜欢上你了，当然我是害怕的，我那时更傻，女生喜欢女生对于我来说是很不可思议的事情，我下意识地忽略和遗忘这件事，所以那段时间很多情况我自己都没有意识到我在做什么。现在想想真好笑，我甚至还在无意间和你表白过，那句话太露骨了，其实就等于表白了，可是我是出自真心说出的，完全不加思考，当时也完全意识不到这句话意味着什么。\n\n对不起，对不起，真的很对不起，我突然想起了很多画面，我想起了你的眼神，我想起了你对我说的话，你大概是知道我喜欢你的，甚至不需要大概，你就是知道我喜欢你吧，也许不只是你，其他人也多少意识到了，那时我真的很傻，我喜欢一个人，但是我完全不知道该怎么表达自己的喜欢，完全不知道要怎么去追求她，谢谢你，真的谢谢你，我觉得我是应该满足了，我真后悔那次毕业散伙饭我没有穿的好看一点。谢谢你。\n\n你就是我的莉拉，我是莱农，我是爱上莉拉的莱农，真可惜她们两个人走散了，也许不再相聚了，可是，莱农是因为莉拉才变成莱农的。谢谢你。\n","slug":"一封信","published":1,"updated":"2022-01-12T08:27:09.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh18000i6wtv4crc0km6","content":"<p>我时常在浪漫和理智中徘徊。</p>\n<p>一个在浪漫和理智中徘徊的人到底是一个理想主义者还是现实主义者呢？</p>\n<p>我总是对自己说：别写这么傻的信，即使你看了也只会扫上两眼然后对别人说：XXX给我写了一封无聊的东西。最后用草稿纸的背面写几个字回我。</p>\n<p>此外，时间过去很久了，久到我似乎没有理由写这样的信，久到这封信变得不是为你写的，而是为我自己写的。可是，写来写去也是欺骗自己，为自己打造一副自己情深的可笑场面。因为我明明已经释然了已经习惯了却偏偏还要回忆。</p>\n<p>前天晚上梦见了你，以前，三年前的时候，我每次梦见你都会在备忘录上记下一笔，不过后来梦见你的次数实在太多了，也就没再记录。前天我梦见，你对你的专业不满意，你想要转专业，你转了我这个专业，又和我一起读书了。大概是因为我有基础吧，老师总是表扬我，然后你也对我刮目相看，我在梦里想：现在你应该注意到我了，我该找个什么机会和你自然地和好呢。</p>\n<p>其实每一次梦见你都是这样的，每一次我都想在梦里与你和好，有几次和好成功了，有几次正在试探中，有几次非常浪漫，有一次的梦里，我要回高中处理一些事情，我抬头看到了宛如极光的天空，我发出感慨，朝着这绚烂的天边走去，然后我遇见了也在抬头看天的你。有一次的梦里，你主动来和好，我真开心，第二天我们一起吃早饭，我问你：为什么想要和好呢？你说：因为你是主角啊（因为是在你的梦里啊），然后突然意识到自己是在做梦。有一次的梦非常真实，我已经忘记了到底梦见什么，不外乎我们和好了，我太高兴了，高兴到在梦中反复询问这不会是在做梦吧这不会是在做梦吧，然后我突然被闹钟吵醒了，从混沌到彻底清醒的那段时间似乎变得很漫长，我的心脏从开始的狂跳不止逐渐恢复正常，然后就是失望、心灰意冷、一种无法相信那竟然只是梦的质疑。</p>\n<p>2017年的时候，我写过一封表白信给你，发送出去了的，给十年后的你，前段日子我再次浏览那个网站的时候，发现有追溯以前信件的功能，我搜了一下，发现我写给你的信失踪了。没有逃过一劫的窃喜，只有遗憾。虽然打扰未来的你是一件不太负责任的事情，但我还是希望那份心意能沿着时空隧道传到未来的你那里。2017年秋天的那个晚上，我写了又删，小心翼翼打下一个个幼稚的文字（现在隐约记得，是蛮幼稚和天真的），选择的时间是十年后，填写的收件人邮箱是你的QQ邮箱，然后我点了公开信。我还以为公开信是对方收到信后才公开，可是我点击发送后就在公开列表中看到了它。</p>\n<p>非常慌张，我害怕被你看到，我只要一考虑到有这个可能性，一考虑到你有可能会看到，一想到如果你那时就看了我们也许连朋友都做不了，我就慌张地不知所措，然后我就非常笨拙地写下了几十封上百封的公开信吧，收件人一开始是我的邮箱，然后是不知道是谁的邮箱，信的内容也是乱七八糟的复制粘贴的，那一天我大概花了四五个小时都在写公开信，只是想把我写给你的那封信隐藏在角落里。即使这样，我还是不放心，我记得那个时候已经是早上四点了，我找到了网站开发者的微博账号，在账号上私信他，发了很多很多骚扰文字，然后终于还是睡着了，醒来后第一件事就是看微博私信，收到他的回复：已删——我才松了一口气。</p>\n<p>可是，没想到他是把这封信彻底删了。我好遗憾啊。</p>\n<p>我为什么就喜欢上你了呢？回忆已经被美化滤镜过滤了一遍，我偶尔回忆起来的也只是你很美好这件事了，现在我回忆起你的时间越来越短，回忆的内容也越来越单薄，过去，不知道是前年还是去年的时候，我突然回忆起关于你的什么事情来，然后一阵恍惚，因为我意识到我已经忘记了好多好多回忆了，是很难受的，我不希望忘记这些回忆。</p>\n<p>还是说现在的事情吧，也许是因为我不知道怎么去讲述我过去对你的感情，我担心你不会想听的，因为，我在那段时间里总是在悲伤中、痛苦中、嫉妒中。</p>\n<p>昨天我在b站上看到了一个刚刚从失恋中走出来的up主发的新视频，她说她失恋时非常地痛苦，让我突然觉得我那时的痛苦好像变得无所谓了，因为不是只有我一个人经历过这样的痛苦，也许百分之五十的人都会经历过，这样就显得我的过去是一段很寻常的往事。可是我还是会觉得，我和那个up主是不一样的，因为我喜欢的人比她喜欢的人要好很多。大概是因为我一直都是暗恋你的缘故吧，所以你真的变得无比美好了，不，即使排除这些区别，你也比别人好上很多，你真的无比美好，我现在还是觉得你是我应该追逐的存在。我以前做了很多很多愚蠢的事情，比方说我为了给你一个人写明信片，我会给全班交好的女生都写上一张明信片，大概这样就能隐藏我对你的情感了吧。</p>\n<p>如果我记得没错的话，那张明信片上其实只有一句话：遇见你是一件很幸运的事情。一开始是写满了整张明信片的文字，只有最后一句是这句话，我觉得文字太多显得我絮叨，就重写了一张，写着写着，换了很多明信片，变得只剩下这一句话了。又因为我的字实在是不好看，这句话我也写了好几遍。但是，即使是现在我也想对你说：谢谢你，遇见你是一件很幸运的事。</p>\n<p>我翻高中的日记，我在日记里是这样形容我对你的感情：我确定我对她的感情不是爱情，因为爱情可能会冷淡但是我对她的感情永远也不会改变。不过我还是偷偷写了很多表白信给你，不是写给未来的你，是写给那时的你。有一阵子，我每天都在被子里练字——是写表白信，只是白天总是不敢交给你而已。不过那都是高三后面的事情了，我和你“绝交”时的事情了。我很早就对你有了超过友谊的情感，有一天晚上我突然梦见你对我表白，让我意识到我喜欢上你了，当然我是害怕的，我那时更傻，女生喜欢女生对于我来说是很不可思议的事情，我下意识地忽略和遗忘这件事，所以那段时间很多情况我自己都没有意识到我在做什么。现在想想真好笑，我甚至还在无意间和你表白过，那句话太露骨了，其实就等于表白了，可是我是出自真心说出的，完全不加思考，当时也完全意识不到这句话意味着什么。</p>\n<p>对不起，对不起，真的很对不起，我突然想起了很多画面，我想起了你的眼神，我想起了你对我说的话，你大概是知道我喜欢你的，甚至不需要大概，你就是知道我喜欢你吧，也许不只是你，其他人也多少意识到了，那时我真的很傻，我喜欢一个人，但是我完全不知道该怎么表达自己的喜欢，完全不知道要怎么去追求她，谢谢你，真的谢谢你，我觉得我是应该满足了，我真后悔那次毕业散伙饭我没有穿的好看一点。谢谢你。</p>\n<p>你就是我的莉拉，我是莱农，我是爱上莉拉的莱农，真可惜她们两个人走散了，也许不再相聚了，可是，莱农是因为莉拉才变成莱农的。谢谢你。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<p>我时常在浪漫和理智中徘徊。</p>\n<p>一个在浪漫和理智中徘徊的人到底是一个理想主义者还是现实主义者呢？</p>\n<p>我总是对自己说：别写这么傻的信，即使你看了也只会扫上两眼然后对别人说：XXX给我写了一封无聊的东西。最后用草稿纸的背面写几个字回我。</p>\n<p>此外，时间过去很久了，久到我似乎没有理由写这样的信，久到这封信变得不是为你写的，而是为我自己写的。可是，写来写去也是欺骗自己，为自己打造一副自己情深的可笑场面。因为我明明已经释然了已经习惯了却偏偏还要回忆。</p>\n<p>前天晚上梦见了你，以前，三年前的时候，我每次梦见你都会在备忘录上记下一笔，不过后来梦见你的次数实在太多了，也就没再记录。前天我梦见，你对你的专业不满意，你想要转专业，你转了我这个专业，又和我一起读书了。大概是因为我有基础吧，老师总是表扬我，然后你也对我刮目相看，我在梦里想：现在你应该注意到我了，我该找个什么机会和你自然地和好呢。</p>\n<p>其实每一次梦见你都是这样的，每一次我都想在梦里与你和好，有几次和好成功了，有几次正在试探中，有几次非常浪漫，有一次的梦里，我要回高中处理一些事情，我抬头看到了宛如极光的天空，我发出感慨，朝着这绚烂的天边走去，然后我遇见了也在抬头看天的你。有一次的梦里，你主动来和好，我真开心，第二天我们一起吃早饭，我问你：为什么想要和好呢？你说：因为你是主角啊（因为是在你的梦里啊），然后突然意识到自己是在做梦。有一次的梦非常真实，我已经忘记了到底梦见什么，不外乎我们和好了，我太高兴了，高兴到在梦中反复询问这不会是在做梦吧这不会是在做梦吧，然后我突然被闹钟吵醒了，从混沌到彻底清醒的那段时间似乎变得很漫长，我的心脏从开始的狂跳不止逐渐恢复正常，然后就是失望、心灰意冷、一种无法相信那竟然只是梦的质疑。</p>\n<p>2017年的时候，我写过一封表白信给你，发送出去了的，给十年后的你，前段日子我再次浏览那个网站的时候，发现有追溯以前信件的功能，我搜了一下，发现我写给你的信失踪了。没有逃过一劫的窃喜，只有遗憾。虽然打扰未来的你是一件不太负责任的事情，但我还是希望那份心意能沿着时空隧道传到未来的你那里。2017年秋天的那个晚上，我写了又删，小心翼翼打下一个个幼稚的文字（现在隐约记得，是蛮幼稚和天真的），选择的时间是十年后，填写的收件人邮箱是你的QQ邮箱，然后我点了公开信。我还以为公开信是对方收到信后才公开，可是我点击发送后就在公开列表中看到了它。</p>\n<p>非常慌张，我害怕被你看到，我只要一考虑到有这个可能性，一考虑到你有可能会看到，一想到如果你那时就看了我们也许连朋友都做不了，我就慌张地不知所措，然后我就非常笨拙地写下了几十封上百封的公开信吧，收件人一开始是我的邮箱，然后是不知道是谁的邮箱，信的内容也是乱七八糟的复制粘贴的，那一天我大概花了四五个小时都在写公开信，只是想把我写给你的那封信隐藏在角落里。即使这样，我还是不放心，我记得那个时候已经是早上四点了，我找到了网站开发者的微博账号，在账号上私信他，发了很多很多骚扰文字，然后终于还是睡着了，醒来后第一件事就是看微博私信，收到他的回复：已删——我才松了一口气。</p>\n<p>可是，没想到他是把这封信彻底删了。我好遗憾啊。</p>\n<p>我为什么就喜欢上你了呢？回忆已经被美化滤镜过滤了一遍，我偶尔回忆起来的也只是你很美好这件事了，现在我回忆起你的时间越来越短，回忆的内容也越来越单薄，过去，不知道是前年还是去年的时候，我突然回忆起关于你的什么事情来，然后一阵恍惚，因为我意识到我已经忘记了好多好多回忆了，是很难受的，我不希望忘记这些回忆。</p>\n<p>还是说现在的事情吧，也许是因为我不知道怎么去讲述我过去对你的感情，我担心你不会想听的，因为，我在那段时间里总是在悲伤中、痛苦中、嫉妒中。</p>\n<p>昨天我在b站上看到了一个刚刚从失恋中走出来的up主发的新视频，她说她失恋时非常地痛苦，让我突然觉得我那时的痛苦好像变得无所谓了，因为不是只有我一个人经历过这样的痛苦，也许百分之五十的人都会经历过，这样就显得我的过去是一段很寻常的往事。可是我还是会觉得，我和那个up主是不一样的，因为我喜欢的人比她喜欢的人要好很多。大概是因为我一直都是暗恋你的缘故吧，所以你真的变得无比美好了，不，即使排除这些区别，你也比别人好上很多，你真的无比美好，我现在还是觉得你是我应该追逐的存在。我以前做了很多很多愚蠢的事情，比方说我为了给你一个人写明信片，我会给全班交好的女生都写上一张明信片，大概这样就能隐藏我对你的情感了吧。</p>\n<p>如果我记得没错的话，那张明信片上其实只有一句话：遇见你是一件很幸运的事情。一开始是写满了整张明信片的文字，只有最后一句是这句话，我觉得文字太多显得我絮叨，就重写了一张，写着写着，换了很多明信片，变得只剩下这一句话了。又因为我的字实在是不好看，这句话我也写了好几遍。但是，即使是现在我也想对你说：谢谢你，遇见你是一件很幸运的事。</p>\n<p>我翻高中的日记，我在日记里是这样形容我对你的感情：我确定我对她的感情不是爱情，因为爱情可能会冷淡但是我对她的感情永远也不会改变。不过我还是偷偷写了很多表白信给你，不是写给未来的你，是写给那时的你。有一阵子，我每天都在被子里练字——是写表白信，只是白天总是不敢交给你而已。不过那都是高三后面的事情了，我和你“绝交”时的事情了。我很早就对你有了超过友谊的情感，有一天晚上我突然梦见你对我表白，让我意识到我喜欢上你了，当然我是害怕的，我那时更傻，女生喜欢女生对于我来说是很不可思议的事情，我下意识地忽略和遗忘这件事，所以那段时间很多情况我自己都没有意识到我在做什么。现在想想真好笑，我甚至还在无意间和你表白过，那句话太露骨了，其实就等于表白了，可是我是出自真心说出的，完全不加思考，当时也完全意识不到这句话意味着什么。</p>\n<p>对不起，对不起，真的很对不起，我突然想起了很多画面，我想起了你的眼神，我想起了你对我说的话，你大概是知道我喜欢你的，甚至不需要大概，你就是知道我喜欢你吧，也许不只是你，其他人也多少意识到了，那时我真的很傻，我喜欢一个人，但是我完全不知道该怎么表达自己的喜欢，完全不知道要怎么去追求她，谢谢你，真的谢谢你，我觉得我是应该满足了，我真后悔那次毕业散伙饭我没有穿的好看一点。谢谢你。</p>\n<p>你就是我的莉拉，我是莱农，我是爱上莉拉的莱农，真可惜她们两个人走散了，也许不再相聚了，可是，莱农是因为莉拉才变成莱农的。谢谢你。</p>\n"},{"title":"二零二一年十二月二十三日","date":"2021-12-23T14:49:05.000Z","toc":false,"image":"/images/2021122301.png","_content":"\n------\n\n*失望。*\n\n*高兴。*\n\n------\n\n没有什么比书看了一半去看豆瓣评分发现好友评分只有五分多更失望的了。虽然轻易被左右思想说起来很难听但是我已经不想看下去了，这本书。\n\n晚上又看了一部很好的电影，于是心情变得很好。这个电影讲述了永无止境的一日。当你过着枯燥、乏味、格式化的生活，当你每一天都被社会规则和世俗观念束缚，当你养着一身因为懒惰、贪婪和虚无而滋生的赘肉时，突然有一天醒来，你发现”今天是昨天“，然后你发现不仅”今天是昨天“，”今天还是明天“，或者说明天是今天，昨天也是今天，永远只有今天，世界宛如陷入一个while(1)的无限循环的程序，而你就是那个不断累积次数的变量，其他所有人的日子都会在新的一天开始时被默认重置，那么你会怎么选择过你的生活呢？\n\n这真的是一个很简单的问题吗？我在看电影的时候也想了无数种可能，我在想，我也许会因为这无限的重复而感到绝望，我也许会自杀，我想过我也许会突破任何束缚变得彻底自由无所顾忌，我可以尝试任何我想尝试的事情。我在想我可以像玩攻略游戏一样去认识了解身边的每一个人，发展出尽量多的可能性，我又想我可能无法忍受我搭建好的友谊的小船在第二天完全消失，甚至不曾出现过。我想过我可能彻底陷入虚无的泥潭一蹶不起（然后我发现我想的电影主角都做了，他唯一没做的就是我想过了解身边每一个陌生人然后告诉他们我就是神我来统治你们了，然后建立起个人崇拜的大旗——不过主角也说过：我就是上帝）。看到最后我才明白一件事情，就是我们过着的“连续的每一天”和电影里的“重复的某一天”可能没有什么区别。只有那些非常珍惜当下并且了解到自己真正需要什么的人才会觉得二者之间是有区别的。起码对于我来说，这两者可以没有区别。当我现在不重复过着每一天时，我却企图用最低地成本过着重复的日子，看起来我的每一天都是不同的，但其实我的每一天的许多时候都是相同的。如此想来，“重复的某一天”的日子或许才能找到更多的生命力，就像是电影里的主角一样，我们开始认真过好这一天，因为我们只有这一天，因为我们已经度过了虚无的这一天、贪婪的这一天、愤怒的这一天、颓废的这一天、绝望的这一天。因为我们意识到了这一天的单调性，因为我们无法真正地忍受重复，所以我们只有不断地创造，创造自己、创造周围。\n\n“连续的每一天”和“重复的某一天”到底有什么区别？他们本质上是没有区别的，他们只不过都是由时间堆叠的日子而已，只不过两种情况延续的方向轴不在同一个维度而已。可是似乎只有在“重复的某一天”里，我们才能去突破去创新去利用时间，因为我们畏惧重复。可是当我们只过着“连续的每一天”时我们又开始依赖重复，因为这种重复构建的稳定让我们在不重复的日子里找到了安全感。\n\n所以，我真希望自己能经历重复的某一天，这样我就知道如何度过连续的每一天了。\n","source":"_posts/二零二一年十二月二十三日.md","raw":"---\ntitle: 二零二一年十二月二十三日\ndate: 2021-12-23 22:49:05\ntags: 日记\ntoc: false\nimage: /images/2021122301.png\ncategories:\n- 日记\n---\n\n------\n\n*失望。*\n\n*高兴。*\n\n------\n\n没有什么比书看了一半去看豆瓣评分发现好友评分只有五分多更失望的了。虽然轻易被左右思想说起来很难听但是我已经不想看下去了，这本书。\n\n晚上又看了一部很好的电影，于是心情变得很好。这个电影讲述了永无止境的一日。当你过着枯燥、乏味、格式化的生活，当你每一天都被社会规则和世俗观念束缚，当你养着一身因为懒惰、贪婪和虚无而滋生的赘肉时，突然有一天醒来，你发现”今天是昨天“，然后你发现不仅”今天是昨天“，”今天还是明天“，或者说明天是今天，昨天也是今天，永远只有今天，世界宛如陷入一个while(1)的无限循环的程序，而你就是那个不断累积次数的变量，其他所有人的日子都会在新的一天开始时被默认重置，那么你会怎么选择过你的生活呢？\n\n这真的是一个很简单的问题吗？我在看电影的时候也想了无数种可能，我在想，我也许会因为这无限的重复而感到绝望，我也许会自杀，我想过我也许会突破任何束缚变得彻底自由无所顾忌，我可以尝试任何我想尝试的事情。我在想我可以像玩攻略游戏一样去认识了解身边的每一个人，发展出尽量多的可能性，我又想我可能无法忍受我搭建好的友谊的小船在第二天完全消失，甚至不曾出现过。我想过我可能彻底陷入虚无的泥潭一蹶不起（然后我发现我想的电影主角都做了，他唯一没做的就是我想过了解身边每一个陌生人然后告诉他们我就是神我来统治你们了，然后建立起个人崇拜的大旗——不过主角也说过：我就是上帝）。看到最后我才明白一件事情，就是我们过着的“连续的每一天”和电影里的“重复的某一天”可能没有什么区别。只有那些非常珍惜当下并且了解到自己真正需要什么的人才会觉得二者之间是有区别的。起码对于我来说，这两者可以没有区别。当我现在不重复过着每一天时，我却企图用最低地成本过着重复的日子，看起来我的每一天都是不同的，但其实我的每一天的许多时候都是相同的。如此想来，“重复的某一天”的日子或许才能找到更多的生命力，就像是电影里的主角一样，我们开始认真过好这一天，因为我们只有这一天，因为我们已经度过了虚无的这一天、贪婪的这一天、愤怒的这一天、颓废的这一天、绝望的这一天。因为我们意识到了这一天的单调性，因为我们无法真正地忍受重复，所以我们只有不断地创造，创造自己、创造周围。\n\n“连续的每一天”和“重复的某一天”到底有什么区别？他们本质上是没有区别的，他们只不过都是由时间堆叠的日子而已，只不过两种情况延续的方向轴不在同一个维度而已。可是似乎只有在“重复的某一天”里，我们才能去突破去创新去利用时间，因为我们畏惧重复。可是当我们只过着“连续的每一天”时我们又开始依赖重复，因为这种重复构建的稳定让我们在不重复的日子里找到了安全感。\n\n所以，我真希望自己能经历重复的某一天，这样我就知道如何度过连续的每一天了。\n","slug":"二零二一年十二月二十三日","published":1,"updated":"2021-12-23T15:26:32.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh1d000m6wtv9rn74dd6","content":"<hr>\n<p><em>失望。</em></p>\n<p><em>高兴。</em></p>\n<hr>\n<p>没有什么比书看了一半去看豆瓣评分发现好友评分只有五分多更失望的了。虽然轻易被左右思想说起来很难听但是我已经不想看下去了，这本书。</p>\n<p>晚上又看了一部很好的电影，于是心情变得很好。这个电影讲述了永无止境的一日。当你过着枯燥、乏味、格式化的生活，当你每一天都被社会规则和世俗观念束缚，当你养着一身因为懒惰、贪婪和虚无而滋生的赘肉时，突然有一天醒来，你发现”今天是昨天“，然后你发现不仅”今天是昨天“，”今天还是明天“，或者说明天是今天，昨天也是今天，永远只有今天，世界宛如陷入一个while(1)的无限循环的程序，而你就是那个不断累积次数的变量，其他所有人的日子都会在新的一天开始时被默认重置，那么你会怎么选择过你的生活呢？</p>\n<p>这真的是一个很简单的问题吗？我在看电影的时候也想了无数种可能，我在想，我也许会因为这无限的重复而感到绝望，我也许会自杀，我想过我也许会突破任何束缚变得彻底自由无所顾忌，我可以尝试任何我想尝试的事情。我在想我可以像玩攻略游戏一样去认识了解身边的每一个人，发展出尽量多的可能性，我又想我可能无法忍受我搭建好的友谊的小船在第二天完全消失，甚至不曾出现过。我想过我可能彻底陷入虚无的泥潭一蹶不起（然后我发现我想的电影主角都做了，他唯一没做的就是我想过了解身边每一个陌生人然后告诉他们我就是神我来统治你们了，然后建立起个人崇拜的大旗——不过主角也说过：我就是上帝）。看到最后我才明白一件事情，就是我们过着的“连续的每一天”和电影里的“重复的某一天”可能没有什么区别。只有那些非常珍惜当下并且了解到自己真正需要什么的人才会觉得二者之间是有区别的。起码对于我来说，这两者可以没有区别。当我现在不重复过着每一天时，我却企图用最低地成本过着重复的日子，看起来我的每一天都是不同的，但其实我的每一天的许多时候都是相同的。如此想来，“重复的某一天”的日子或许才能找到更多的生命力，就像是电影里的主角一样，我们开始认真过好这一天，因为我们只有这一天，因为我们已经度过了虚无的这一天、贪婪的这一天、愤怒的这一天、颓废的这一天、绝望的这一天。因为我们意识到了这一天的单调性，因为我们无法真正地忍受重复，所以我们只有不断地创造，创造自己、创造周围。</p>\n<p>“连续的每一天”和“重复的某一天”到底有什么区别？他们本质上是没有区别的，他们只不过都是由时间堆叠的日子而已，只不过两种情况延续的方向轴不在同一个维度而已。可是似乎只有在“重复的某一天”里，我们才能去突破去创新去利用时间，因为我们畏惧重复。可是当我们只过着“连续的每一天”时我们又开始依赖重复，因为这种重复构建的稳定让我们在不重复的日子里找到了安全感。</p>\n<p>所以，我真希望自己能经历重复的某一天，这样我就知道如何度过连续的每一天了。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>失望。</em></p>\n<p><em>高兴。</em></p>\n<hr>\n<p>没有什么比书看了一半去看豆瓣评分发现好友评分只有五分多更失望的了。虽然轻易被左右思想说起来很难听但是我已经不想看下去了，这本书。</p>\n<p>晚上又看了一部很好的电影，于是心情变得很好。这个电影讲述了永无止境的一日。当你过着枯燥、乏味、格式化的生活，当你每一天都被社会规则和世俗观念束缚，当你养着一身因为懒惰、贪婪和虚无而滋生的赘肉时，突然有一天醒来，你发现”今天是昨天“，然后你发现不仅”今天是昨天“，”今天还是明天“，或者说明天是今天，昨天也是今天，永远只有今天，世界宛如陷入一个while(1)的无限循环的程序，而你就是那个不断累积次数的变量，其他所有人的日子都会在新的一天开始时被默认重置，那么你会怎么选择过你的生活呢？</p>\n<p>这真的是一个很简单的问题吗？我在看电影的时候也想了无数种可能，我在想，我也许会因为这无限的重复而感到绝望，我也许会自杀，我想过我也许会突破任何束缚变得彻底自由无所顾忌，我可以尝试任何我想尝试的事情。我在想我可以像玩攻略游戏一样去认识了解身边的每一个人，发展出尽量多的可能性，我又想我可能无法忍受我搭建好的友谊的小船在第二天完全消失，甚至不曾出现过。我想过我可能彻底陷入虚无的泥潭一蹶不起（然后我发现我想的电影主角都做了，他唯一没做的就是我想过了解身边每一个陌生人然后告诉他们我就是神我来统治你们了，然后建立起个人崇拜的大旗——不过主角也说过：我就是上帝）。看到最后我才明白一件事情，就是我们过着的“连续的每一天”和电影里的“重复的某一天”可能没有什么区别。只有那些非常珍惜当下并且了解到自己真正需要什么的人才会觉得二者之间是有区别的。起码对于我来说，这两者可以没有区别。当我现在不重复过着每一天时，我却企图用最低地成本过着重复的日子，看起来我的每一天都是不同的，但其实我的每一天的许多时候都是相同的。如此想来，“重复的某一天”的日子或许才能找到更多的生命力，就像是电影里的主角一样，我们开始认真过好这一天，因为我们只有这一天，因为我们已经度过了虚无的这一天、贪婪的这一天、愤怒的这一天、颓废的这一天、绝望的这一天。因为我们意识到了这一天的单调性，因为我们无法真正地忍受重复，所以我们只有不断地创造，创造自己、创造周围。</p>\n<p>“连续的每一天”和“重复的某一天”到底有什么区别？他们本质上是没有区别的，他们只不过都是由时间堆叠的日子而已，只不过两种情况延续的方向轴不在同一个维度而已。可是似乎只有在“重复的某一天”里，我们才能去突破去创新去利用时间，因为我们畏惧重复。可是当我们只过着“连续的每一天”时我们又开始依赖重复，因为这种重复构建的稳定让我们在不重复的日子里找到了安全感。</p>\n<p>所以，我真希望自己能经历重复的某一天，这样我就知道如何度过连续的每一天了。</p>\n"},{"title":"二零二一年十二月二十七日","date":"2021-12-27T13:47:05.000Z","toc":false,"image":"/images/2021122701.png","_content":"\n------\n\n*莉拉和娜斯塔霞*\n\n------\n\n当我读完《白痴》时，我也许会默念无数遍娜斯塔霞这个名字，就像是当初读完那不勒斯四部曲时无数遍的“莉拉”。前面一百八十页都只是轻飘飘地压着，第一部的最后二十页突然沉重地如同深海里的陨石一样压得我喘不过气来。我仔细凝视书中的一张画像，然后翻到了影视版莉拉的剧照——太像了，连长得都如此相像，我甚至怀疑导演就是举着这张画像找的演员。莉拉的那张剧照在平板上看着好美，她的美是摄人心魄的，她产生的冲击力，大概只有《时时刻刻》里的伍尔夫才能相提并论吧。\n\n真想一口气读完，可这是陀思妥耶夫斯基，可不是费兰特。\n","source":"_posts/二零二一年十二月二十七日.md","raw":"---\ntitle: 二零二一年十二月二十七日\ndate: 2021-12-27 21:47:05\ntags: 日记\ntoc: false\nimage: /images/2021122701.png\ncategories:\n- 日记\n---\n\n------\n\n*莉拉和娜斯塔霞*\n\n------\n\n当我读完《白痴》时，我也许会默念无数遍娜斯塔霞这个名字，就像是当初读完那不勒斯四部曲时无数遍的“莉拉”。前面一百八十页都只是轻飘飘地压着，第一部的最后二十页突然沉重地如同深海里的陨石一样压得我喘不过气来。我仔细凝视书中的一张画像，然后翻到了影视版莉拉的剧照——太像了，连长得都如此相像，我甚至怀疑导演就是举着这张画像找的演员。莉拉的那张剧照在平板上看着好美，她的美是摄人心魄的，她产生的冲击力，大概只有《时时刻刻》里的伍尔夫才能相提并论吧。\n\n真想一口气读完，可这是陀思妥耶夫斯基，可不是费兰特。\n","slug":"二零二一年十二月二十七日","published":1,"updated":"2021-12-27T14:02:34.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh1f000p6wtv345sgwil","content":"<hr>\n<p><em>莉拉和娜斯塔霞</em></p>\n<hr>\n<p>当我读完《白痴》时，我也许会默念无数遍娜斯塔霞这个名字，就像是当初读完那不勒斯四部曲时无数遍的“莉拉”。前面一百八十页都只是轻飘飘地压着，第一部的最后二十页突然沉重地如同深海里的陨石一样压得我喘不过气来。我仔细凝视书中的一张画像，然后翻到了影视版莉拉的剧照——太像了，连长得都如此相像，我甚至怀疑导演就是举着这张画像找的演员。莉拉的那张剧照在平板上看着好美，她的美是摄人心魄的，她产生的冲击力，大概只有《时时刻刻》里的伍尔夫才能相提并论吧。</p>\n<p>真想一口气读完，可这是陀思妥耶夫斯基，可不是费兰特。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>莉拉和娜斯塔霞</em></p>\n<hr>\n<p>当我读完《白痴》时，我也许会默念无数遍娜斯塔霞这个名字，就像是当初读完那不勒斯四部曲时无数遍的“莉拉”。前面一百八十页都只是轻飘飘地压着，第一部的最后二十页突然沉重地如同深海里的陨石一样压得我喘不过气来。我仔细凝视书中的一张画像，然后翻到了影视版莉拉的剧照——太像了，连长得都如此相像，我甚至怀疑导演就是举着这张画像找的演员。莉拉的那张剧照在平板上看着好美，她的美是摄人心魄的，她产生的冲击力，大概只有《时时刻刻》里的伍尔夫才能相提并论吧。</p>\n<p>真想一口气读完，可这是陀思妥耶夫斯基，可不是费兰特。</p>\n"},{"title":"二零二一年十二月二十二日","date":"2021-12-22T15:57:21.000Z","toc":false,"image":"/images/2021122201.png","_content":"\n------\n\n*好开心。*\n\n------\n\n刚刚看完《Tokyo！》，真的是好喜欢好喜欢这部电影啊！然后就好开心好开心，就是因为看了一部很好的电影就很开心。喜欢卡拉克斯，喜欢Alex！三个短片，每一个都好喜欢！喜欢到想要迫不及待地写年末观影小结然后写很多很多文字赞美它，虽然我现在都挤不出什么来，只能不停地说好喜欢。\n\n今天上午看一本上半年没看完的书，发现了两片花瓣。想起了前两天在杂志堆里发现的几片黑漆漆干巴巴的玉兰花，这两片花瓣对比之下非常干净可爱，即使已经没有水分了依旧留有几分柔软，但是由于我太猛烈地翻页所以还是撕开了一个裂痕，颜色也是，依稀能够看出曾经的颜色来，但是现在的颜色也不讨人嫌弃。\n\n![](/images/2021122202.png)\n","source":"_posts/二零二一年十二月二十二日.md","raw":"---\ntitle: 二零二一年十二月二十二日\ndate: 2021-12-22 23:57:21\ntags: 日记\ntoc: false\nimage: /images/2021122201.png\ncategories:\n- 日记\n---\n\n------\n\n*好开心。*\n\n------\n\n刚刚看完《Tokyo！》，真的是好喜欢好喜欢这部电影啊！然后就好开心好开心，就是因为看了一部很好的电影就很开心。喜欢卡拉克斯，喜欢Alex！三个短片，每一个都好喜欢！喜欢到想要迫不及待地写年末观影小结然后写很多很多文字赞美它，虽然我现在都挤不出什么来，只能不停地说好喜欢。\n\n今天上午看一本上半年没看完的书，发现了两片花瓣。想起了前两天在杂志堆里发现的几片黑漆漆干巴巴的玉兰花，这两片花瓣对比之下非常干净可爱，即使已经没有水分了依旧留有几分柔软，但是由于我太猛烈地翻页所以还是撕开了一个裂痕，颜色也是，依稀能够看出曾经的颜色来，但是现在的颜色也不讨人嫌弃。\n\n![](/images/2021122202.png)\n","slug":"二零二一年十二月二十二日","published":1,"updated":"2021-12-22T16:11:06.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh1i000u6wtvd6atev5j","content":"<hr>\n<p><em>好开心。</em></p>\n<hr>\n<p>刚刚看完《Tokyo！》，真的是好喜欢好喜欢这部电影啊！然后就好开心好开心，就是因为看了一部很好的电影就很开心。喜欢卡拉克斯，喜欢Alex！三个短片，每一个都好喜欢！喜欢到想要迫不及待地写年末观影小结然后写很多很多文字赞美它，虽然我现在都挤不出什么来，只能不停地说好喜欢。</p>\n<p>今天上午看一本上半年没看完的书，发现了两片花瓣。想起了前两天在杂志堆里发现的几片黑漆漆干巴巴的玉兰花，这两片花瓣对比之下非常干净可爱，即使已经没有水分了依旧留有几分柔软，但是由于我太猛烈地翻页所以还是撕开了一个裂痕，颜色也是，依稀能够看出曾经的颜色来，但是现在的颜色也不讨人嫌弃。</p>\n<p><img src=\"/images/2021122202.png\"></p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>好开心。</em></p>\n<hr>\n<p>刚刚看完《Tokyo！》，真的是好喜欢好喜欢这部电影啊！然后就好开心好开心，就是因为看了一部很好的电影就很开心。喜欢卡拉克斯，喜欢Alex！三个短片，每一个都好喜欢！喜欢到想要迫不及待地写年末观影小结然后写很多很多文字赞美它，虽然我现在都挤不出什么来，只能不停地说好喜欢。</p>\n<p>今天上午看一本上半年没看完的书，发现了两片花瓣。想起了前两天在杂志堆里发现的几片黑漆漆干巴巴的玉兰花，这两片花瓣对比之下非常干净可爱，即使已经没有水分了依旧留有几分柔软，但是由于我太猛烈地翻页所以还是撕开了一个裂痕，颜色也是，依稀能够看出曾经的颜色来，但是现在的颜色也不讨人嫌弃。</p>\n<p><img src=\"/images/2021122202.png\"></p>\n"},{"title":"二零二一年十二月十八日","date":"2021-12-18T12:11:15.000Z","toc":false,"image":"/images/2021121802.png","_content":"\n\n\n------\n\n*包书。*\n\n------\n\n包杂志的时候抖出了一堆黑乎乎的玉兰花干片，怪丑的，还蛮多的。不知道我以前抱着什么心情收集的，想要留住玉兰花的美好吗？\n\n","source":"_posts/二零二一年十二月十八日.md","raw":"---\ntitle: 二零二一年十二月十八日\ndate: 2021-12-18 20:11:15\ntags: 日记\ntoc: false\nimage: /images/2021121802.png\ncategories:\n- 日记\n---\n\n\n\n------\n\n*包书。*\n\n------\n\n包杂志的时候抖出了一堆黑乎乎的玉兰花干片，怪丑的，还蛮多的。不知道我以前抱着什么心情收集的，想要留住玉兰花的美好吗？\n\n","slug":"二零二一年十二月十八日","published":1,"updated":"2021-12-20T13:39:36.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh1k000w6wtvgegz6yr8","content":"<hr>\n<p><em>包书。</em></p>\n<hr>\n<p>包杂志的时候抖出了一堆黑乎乎的玉兰花干片，怪丑的，还蛮多的。不知道我以前抱着什么心情收集的，想要留住玉兰花的美好吗？</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>包书。</em></p>\n<hr>\n<p>包杂志的时候抖出了一堆黑乎乎的玉兰花干片，怪丑的，还蛮多的。不知道我以前抱着什么心情收集的，想要留住玉兰花的美好吗？</p>\n"},{"title":"二零二一年十二月十七日","date":"2021-12-17T10:43:03.000Z","toc":false,"image":"/images/2021121701.png","_content":"\n\n\n------\n\n*重看《寄生虫》。*\n\n------\n\n喜欢小右的眼睛，好美。\n\n![](/images/2021121702.png)\n\n![](/images/2021121801.png)\n\n看完后百感交集，想到这次的新冠，那句共存的口号，以及《素食者》这本书。也许以后可以谈谈。","source":"_posts/二零二一年十二月十七日.md","raw":"---\ntitle: 二零二一年十二月十七日\ndate: 2021-12-17 18:43:03\ntags: 日记\ntoc: false\nimage: /images/2021121701.png\ncategories:\n- 日记\n---\n\n\n\n------\n\n*重看《寄生虫》。*\n\n------\n\n喜欢小右的眼睛，好美。\n\n![](/images/2021121702.png)\n\n![](/images/2021121801.png)\n\n看完后百感交集，想到这次的新冠，那句共存的口号，以及《素食者》这本书。也许以后可以谈谈。","slug":"二零二一年十二月十七日","published":1,"updated":"2021-12-20T14:03:51.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh1n00106wtv3a32acbv","content":"<hr>\n<p><em>重看《寄生虫》。</em></p>\n<hr>\n<p>喜欢小右的眼睛，好美。</p>\n<p><img src=\"/images/2021121702.png\"></p>\n<p><img src=\"/images/2021121801.png\"></p>\n<p>看完后百感交集，想到这次的新冠，那句共存的口号，以及《素食者》这本书。也许以后可以谈谈。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>重看《寄生虫》。</em></p>\n<hr>\n<p>喜欢小右的眼睛，好美。</p>\n<p><img src=\"/images/2021121702.png\"></p>\n<p><img src=\"/images/2021121801.png\"></p>\n<p>看完后百感交集，想到这次的新冠，那句共存的口号，以及《素食者》这本书。也许以后可以谈谈。</p>\n"},{"title":"二零二一年十二月二十五日","date":"2021-12-25T05:07:17.000Z","toc":false,"image":"/images/2021122501.png","_content":"\n------\n\n*圣诞节快乐*\n\n------\n\n圣诞节这一天下雪了。\n\n外面在下雪，我读着似乎永远都读不完的陀思妥耶夫斯基。\n\n昨天两个小时竟然只读了五十页，今天再尝试了一下，两个半小时五十页。\n\n俄国人的名字真长，真难记，昨天认识的人名今天全给弄混了，一页出现了三个人名，往前追溯发现竟然全都是一个人的名字，可是这个人的名字我又和另一个人的名字弄混了，以至于读的非常糊涂。\n","source":"_posts/二零二一年十二月二十五日.md","raw":"---\ntitle: 二零二一年十二月二十五日\ndate: 2021-12-25 13:07:17\ntags: 日记\ntoc: false\nimage: /images/2021122501.png\ncategories:\n- 日记\n---\n\n------\n\n*圣诞节快乐*\n\n------\n\n圣诞节这一天下雪了。\n\n外面在下雪，我读着似乎永远都读不完的陀思妥耶夫斯基。\n\n昨天两个小时竟然只读了五十页，今天再尝试了一下，两个半小时五十页。\n\n俄国人的名字真长，真难记，昨天认识的人名今天全给弄混了，一页出现了三个人名，往前追溯发现竟然全都是一个人的名字，可是这个人的名字我又和另一个人的名字弄混了，以至于读的非常糊涂。\n","slug":"二零二一年十二月二十五日","published":1,"updated":"2021-12-27T14:20:13.533Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh1p00126wtv7bgb2fd8","content":"<hr>\n<p><em>圣诞节快乐</em></p>\n<hr>\n<p>圣诞节这一天下雪了。</p>\n<p>外面在下雪，我读着似乎永远都读不完的陀思妥耶夫斯基。</p>\n<p>昨天两个小时竟然只读了五十页，今天再尝试了一下，两个半小时五十页。</p>\n<p>俄国人的名字真长，真难记，昨天认识的人名今天全给弄混了，一页出现了三个人名，往前追溯发现竟然全都是一个人的名字，可是这个人的名字我又和另一个人的名字弄混了，以至于读的非常糊涂。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>圣诞节快乐</em></p>\n<hr>\n<p>圣诞节这一天下雪了。</p>\n<p>外面在下雪，我读着似乎永远都读不完的陀思妥耶夫斯基。</p>\n<p>昨天两个小时竟然只读了五十页，今天再尝试了一下，两个半小时五十页。</p>\n<p>俄国人的名字真长，真难记，昨天认识的人名今天全给弄混了，一页出现了三个人名，往前追溯发现竟然全都是一个人的名字，可是这个人的名字我又和另一个人的名字弄混了，以至于读的非常糊涂。</p>\n"},{"title":"二零二一年十二月十四日","date":"2021-12-14T15:41:35.000Z","toc":false,"image":"/images/2021121405.png","_content":"\n\n\n------\n\n*开展“新生活”是一件很困难的事情。*\n\n------\n\n![](/images/2021121401.png)\n\n整理书架，先拿出从学校带回的书。\n\n![](/images/2021121402.png)\n\n发现了一个小发绳，是妹妹的发绳。\n\n![](/images/2021121403.png)\n\n书上全都是灰尘，翻开最厚的那本，书页全都泛黄了。毛姆的《人性的枷锁》，高三的课间和午间休息时拿出来读，现在想想真佩服那时的自己，上了大学反而没有耐性读这么厚的书了。\n\n![](/images/2021121404.png)\n\n书架坏了。垃圾书架，便宜没好货。\n\n![](/images/2021121405.png)\n\n晚上用新买来的幕布看电影，看《新桥恋人》，好喜欢好喜欢这部电影，想为Alex新建一个相册。\n\n\n\n","source":"_posts/二零二一年十二月十四日.md","raw":"---\ntitle: 二零二一年十二月十四日\ndate: 2021-12-14 23:41:35\ntags: 日记\ntoc: false\nimage: /images/2021121405.png\ncategories:\n- 日记\n---\n\n\n\n------\n\n*开展“新生活”是一件很困难的事情。*\n\n------\n\n![](/images/2021121401.png)\n\n整理书架，先拿出从学校带回的书。\n\n![](/images/2021121402.png)\n\n发现了一个小发绳，是妹妹的发绳。\n\n![](/images/2021121403.png)\n\n书上全都是灰尘，翻开最厚的那本，书页全都泛黄了。毛姆的《人性的枷锁》，高三的课间和午间休息时拿出来读，现在想想真佩服那时的自己，上了大学反而没有耐性读这么厚的书了。\n\n![](/images/2021121404.png)\n\n书架坏了。垃圾书架，便宜没好货。\n\n![](/images/2021121405.png)\n\n晚上用新买来的幕布看电影，看《新桥恋人》，好喜欢好喜欢这部电影，想为Alex新建一个相册。\n\n\n\n","slug":"二零二一年十二月十四日","published":1,"updated":"2021-12-16T08:26:00.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh1r00176wtv6lrd49x3","content":"<hr>\n<p><em>开展“新生活”是一件很困难的事情。</em></p>\n<hr>\n<p><img src=\"/images/2021121401.png\"></p>\n<p>整理书架，先拿出从学校带回的书。</p>\n<p><img src=\"/images/2021121402.png\"></p>\n<p>发现了一个小发绳，是妹妹的发绳。</p>\n<p><img src=\"/images/2021121403.png\"></p>\n<p>书上全都是灰尘，翻开最厚的那本，书页全都泛黄了。毛姆的《人性的枷锁》，高三的课间和午间休息时拿出来读，现在想想真佩服那时的自己，上了大学反而没有耐性读这么厚的书了。</p>\n<p><img src=\"/images/2021121404.png\"></p>\n<p>书架坏了。垃圾书架，便宜没好货。</p>\n<p><img src=\"/images/2021121405.png\"></p>\n<p>晚上用新买来的幕布看电影，看《新桥恋人》，好喜欢好喜欢这部电影，想为Alex新建一个相册。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>开展“新生活”是一件很困难的事情。</em></p>\n<hr>\n<p><img src=\"/images/2021121401.png\"></p>\n<p>整理书架，先拿出从学校带回的书。</p>\n<p><img src=\"/images/2021121402.png\"></p>\n<p>发现了一个小发绳，是妹妹的发绳。</p>\n<p><img src=\"/images/2021121403.png\"></p>\n<p>书上全都是灰尘，翻开最厚的那本，书页全都泛黄了。毛姆的《人性的枷锁》，高三的课间和午间休息时拿出来读，现在想想真佩服那时的自己，上了大学反而没有耐性读这么厚的书了。</p>\n<p><img src=\"/images/2021121404.png\"></p>\n<p>书架坏了。垃圾书架，便宜没好货。</p>\n<p><img src=\"/images/2021121405.png\"></p>\n<p>晚上用新买来的幕布看电影，看《新桥恋人》，好喜欢好喜欢这部电影，想为Alex新建一个相册。</p>\n"},{"title":"数据库系统原理基础知识点","date":"2021-12-21T02:01:12.000Z","_content":"\n------\n\n*本文来源于https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过*。\n\n------\n\n## 1.事务\n\n事务是指满足<u>ACID特性</u>的一组操作。ACID特性分别包括以下四个特性：\n\n**原子性**（Atomicity）：事务被视为不可分割最小单元。事务的操作要么全部提交成功，要么全部失败滚回。\n\n**一致性**（Consistency）：数据库在事务执行的前后都保持一致性状态。在一致性状态下，所有事务对同一数据的读取结构是相同的。\n\n**隔离性**（Islation）一个事务所做的修改在最终提交以前，对其他食物不可见。\n\n**持久性**（Durability）一旦事务提交，则其所做的修改将会永远保存在数据库中。即使系统崩溃，事务执行结构也不会丢失。\n\n## 2.并发一致性问题\n\n在并发环境下，事务隔离性很难保证，因此会出现以下并发一致性问题。\n\n**丢失修改**：一个事务的更新操作被另一个事务的更新操作替换，如下图所示：\n\n![](/images/react/2021122103.png)\n\n**读脏数据**：当前事务可以读到另外事务未提交的数据，如下图所示：\n\n![](/images/react/2021122104.png)\n\n**不可重复读**：在一个事务内多次读取同一数据，期间该数据被另一事务进行了修改，会导致重复读统一数据的结果不一致，如下图所示：\n\n![](/images/react/2021122105.png)\n\n\n\n## 3.封锁\n\n**封锁粒度**：封锁粒度越细，锁定数据越少，发生锁争用的可能越小，系统的并发程度就越高，但是也会消耗更多的资源，所以在选择封锁粒度时需要有所权衡。\n\n**封锁类型**：读写锁和意向锁。\n\n**封锁协议**：包括一、二、三级封锁协议和两段锁协议。\n\n## 4.关系数据库设计理论\n\n### 4.1 函数依赖\n\n记A - >B表示A决定B，也可以说B依赖于A。\n\n**键码**：若（A1,A2,...An）是关系的一个或多个属性集合，该集合函数决定了关系的其他属性并且是最小的，那么该集合就是键码。\n\n**部份依赖**：若A->B，但A的真子集A'->B成立，则A->B是部份依赖。\n\n**完全依赖**：若A->B，且无A的真子集A'->B成立，则A->B是完全依赖。\n\n**依赖传递**：A->B,B->C，则A->C。\n\n### 4.2 范式\n\n高级别范式的依赖于低级别的范式，1NF（第一范式） 是最低级别的范式。\n\n**INF**：属性不可分。\n\n**2NF**：每个非主属性完全依赖于键码。\n\n**3NF**：非主属性之间必须互相独立，不存在依赖关系。\n\n### 4.3 异常\n\n不符合范式的关系，会出现很多异常，主要有以下四种：\n\n**冗余数据**：比如一个记录多次出现在表内。\n\n**修改异常**：修改了一个记录中的信息，但另一个记录中相同的信息却没有被修改。\n\n**删除异常**：删除一个信息，那么也会丢失其他信息。\n\n**插入异常**：因为关联问题出现无法插入记录错误。\n\n## 5.ER图\n\n实体关系图（Entity-Relationship），有三个组成部分：<u>实体、属性、联系</u>。\n\n实体之间存在三种关系，分别是<u>一对一、一对多和多对多关系</u>。","source":"_posts/数据库原理复习.md","raw":"---\ntitle: 数据库系统原理基础知识点\ndate: 2021-12-21 10:01:12\ntags: [学习,前端面试，数据库系统原理]\ncategories:\n- 计算机基础复习\n---\n\n------\n\n*本文来源于https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过*。\n\n------\n\n## 1.事务\n\n事务是指满足<u>ACID特性</u>的一组操作。ACID特性分别包括以下四个特性：\n\n**原子性**（Atomicity）：事务被视为不可分割最小单元。事务的操作要么全部提交成功，要么全部失败滚回。\n\n**一致性**（Consistency）：数据库在事务执行的前后都保持一致性状态。在一致性状态下，所有事务对同一数据的读取结构是相同的。\n\n**隔离性**（Islation）一个事务所做的修改在最终提交以前，对其他食物不可见。\n\n**持久性**（Durability）一旦事务提交，则其所做的修改将会永远保存在数据库中。即使系统崩溃，事务执行结构也不会丢失。\n\n## 2.并发一致性问题\n\n在并发环境下，事务隔离性很难保证，因此会出现以下并发一致性问题。\n\n**丢失修改**：一个事务的更新操作被另一个事务的更新操作替换，如下图所示：\n\n![](/images/react/2021122103.png)\n\n**读脏数据**：当前事务可以读到另外事务未提交的数据，如下图所示：\n\n![](/images/react/2021122104.png)\n\n**不可重复读**：在一个事务内多次读取同一数据，期间该数据被另一事务进行了修改，会导致重复读统一数据的结果不一致，如下图所示：\n\n![](/images/react/2021122105.png)\n\n\n\n## 3.封锁\n\n**封锁粒度**：封锁粒度越细，锁定数据越少，发生锁争用的可能越小，系统的并发程度就越高，但是也会消耗更多的资源，所以在选择封锁粒度时需要有所权衡。\n\n**封锁类型**：读写锁和意向锁。\n\n**封锁协议**：包括一、二、三级封锁协议和两段锁协议。\n\n## 4.关系数据库设计理论\n\n### 4.1 函数依赖\n\n记A - >B表示A决定B，也可以说B依赖于A。\n\n**键码**：若（A1,A2,...An）是关系的一个或多个属性集合，该集合函数决定了关系的其他属性并且是最小的，那么该集合就是键码。\n\n**部份依赖**：若A->B，但A的真子集A'->B成立，则A->B是部份依赖。\n\n**完全依赖**：若A->B，且无A的真子集A'->B成立，则A->B是完全依赖。\n\n**依赖传递**：A->B,B->C，则A->C。\n\n### 4.2 范式\n\n高级别范式的依赖于低级别的范式，1NF（第一范式） 是最低级别的范式。\n\n**INF**：属性不可分。\n\n**2NF**：每个非主属性完全依赖于键码。\n\n**3NF**：非主属性之间必须互相独立，不存在依赖关系。\n\n### 4.3 异常\n\n不符合范式的关系，会出现很多异常，主要有以下四种：\n\n**冗余数据**：比如一个记录多次出现在表内。\n\n**修改异常**：修改了一个记录中的信息，但另一个记录中相同的信息却没有被修改。\n\n**删除异常**：删除一个信息，那么也会丢失其他信息。\n\n**插入异常**：因为关联问题出现无法插入记录错误。\n\n## 5.ER图\n\n实体关系图（Entity-Relationship），有三个组成部分：<u>实体、属性、联系</u>。\n\n实体之间存在三种关系，分别是<u>一对一、一对多和多对多关系</u>。","slug":"数据库原理复习","published":1,"updated":"2021-12-21T12:24:14.911Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh1t00186wtvfxoi69od","content":"<hr>\n<p><em>本文来源于<a href=\"https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82%E5%B9%B6%E4%B8%94%E5%9B%A0%E4%B8%BA%E6%9C%AC%E6%AC%A1%E5%A4%8D%E4%B9%A0%E6%98%AF%E4%BA%89%E5%AF%B9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E4%BC%9A%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%88%BB%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%AA%E4%BC%9A%E7%B2%97%E7%95%A5%E6%89%AB%E8%BF%87\">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过</a></em>。</p>\n<hr>\n<h2 id=\"1-事务\"><a href=\"#1-事务\" class=\"headerlink\" title=\"1.事务\"></a>1.事务</h2><p>事务是指满足<u>ACID特性</u>的一组操作。ACID特性分别包括以下四个特性：</p>\n<p><strong>原子性</strong>（Atomicity）：事务被视为不可分割最小单元。事务的操作要么全部提交成功，要么全部失败滚回。</p>\n<p><strong>一致性</strong>（Consistency）：数据库在事务执行的前后都保持一致性状态。在一致性状态下，所有事务对同一数据的读取结构是相同的。</p>\n<p><strong>隔离性</strong>（Islation）一个事务所做的修改在最终提交以前，对其他食物不可见。</p>\n<p><strong>持久性</strong>（Durability）一旦事务提交，则其所做的修改将会永远保存在数据库中。即使系统崩溃，事务执行结构也不会丢失。</p>\n<h2 id=\"2-并发一致性问题\"><a href=\"#2-并发一致性问题\" class=\"headerlink\" title=\"2.并发一致性问题\"></a>2.并发一致性问题</h2><p>在并发环境下，事务隔离性很难保证，因此会出现以下并发一致性问题。</p>\n<p><strong>丢失修改</strong>：一个事务的更新操作被另一个事务的更新操作替换，如下图所示：</p>\n<p><img src=\"/images/react/2021122103.png\"></p>\n<p><strong>读脏数据</strong>：当前事务可以读到另外事务未提交的数据，如下图所示：</p>\n<p><img src=\"/images/react/2021122104.png\"></p>\n<p><strong>不可重复读</strong>：在一个事务内多次读取同一数据，期间该数据被另一事务进行了修改，会导致重复读统一数据的结果不一致，如下图所示：</p>\n<p><img src=\"/images/react/2021122105.png\"></p>\n<h2 id=\"3-封锁\"><a href=\"#3-封锁\" class=\"headerlink\" title=\"3.封锁\"></a>3.封锁</h2><p><strong>封锁粒度</strong>：封锁粒度越细，锁定数据越少，发生锁争用的可能越小，系统的并发程度就越高，但是也会消耗更多的资源，所以在选择封锁粒度时需要有所权衡。</p>\n<p><strong>封锁类型</strong>：读写锁和意向锁。</p>\n<p><strong>封锁协议</strong>：包括一、二、三级封锁协议和两段锁协议。</p>\n<h2 id=\"4-关系数据库设计理论\"><a href=\"#4-关系数据库设计理论\" class=\"headerlink\" title=\"4.关系数据库设计理论\"></a>4.关系数据库设计理论</h2><h3 id=\"4-1-函数依赖\"><a href=\"#4-1-函数依赖\" class=\"headerlink\" title=\"4.1 函数依赖\"></a>4.1 函数依赖</h3><p>记A - &gt;B表示A决定B，也可以说B依赖于A。</p>\n<p><strong>键码</strong>：若（A1,A2,…An）是关系的一个或多个属性集合，该集合函数决定了关系的其他属性并且是最小的，那么该集合就是键码。</p>\n<p><strong>部份依赖</strong>：若A-&gt;B，但A的真子集A’-&gt;B成立，则A-&gt;B是部份依赖。</p>\n<p><strong>完全依赖</strong>：若A-&gt;B，且无A的真子集A’-&gt;B成立，则A-&gt;B是完全依赖。</p>\n<p><strong>依赖传递</strong>：A-&gt;B,B-&gt;C，则A-&gt;C。</p>\n<h3 id=\"4-2-范式\"><a href=\"#4-2-范式\" class=\"headerlink\" title=\"4.2 范式\"></a>4.2 范式</h3><p>高级别范式的依赖于低级别的范式，1NF（第一范式） 是最低级别的范式。</p>\n<p><strong>INF</strong>：属性不可分。</p>\n<p><strong>2NF</strong>：每个非主属性完全依赖于键码。</p>\n<p><strong>3NF</strong>：非主属性之间必须互相独立，不存在依赖关系。</p>\n<h3 id=\"4-3-异常\"><a href=\"#4-3-异常\" class=\"headerlink\" title=\"4.3 异常\"></a>4.3 异常</h3><p>不符合范式的关系，会出现很多异常，主要有以下四种：</p>\n<p><strong>冗余数据</strong>：比如一个记录多次出现在表内。</p>\n<p><strong>修改异常</strong>：修改了一个记录中的信息，但另一个记录中相同的信息却没有被修改。</p>\n<p><strong>删除异常</strong>：删除一个信息，那么也会丢失其他信息。</p>\n<p><strong>插入异常</strong>：因为关联问题出现无法插入记录错误。</p>\n<h2 id=\"5-ER图\"><a href=\"#5-ER图\" class=\"headerlink\" title=\"5.ER图\"></a>5.ER图</h2><p>实体关系图（Entity-Relationship），有三个组成部分：<u>实体、属性、联系</u>。</p>\n<p>实体之间存在三种关系，分别是<u>一对一、一对多和多对多关系</u>。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>本文来源于<a href=\"https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82%E5%B9%B6%E4%B8%94%E5%9B%A0%E4%B8%BA%E6%9C%AC%E6%AC%A1%E5%A4%8D%E4%B9%A0%E6%98%AF%E4%BA%89%E5%AF%B9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E4%BC%9A%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%88%BB%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%AA%E4%BC%9A%E7%B2%97%E7%95%A5%E6%89%AB%E8%BF%87\">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过</a></em>。</p>\n<hr>\n<h2 id=\"1-事务\"><a href=\"#1-事务\" class=\"headerlink\" title=\"1.事务\"></a>1.事务</h2><p>事务是指满足<u>ACID特性</u>的一组操作。ACID特性分别包括以下四个特性：</p>\n<p><strong>原子性</strong>（Atomicity）：事务被视为不可分割最小单元。事务的操作要么全部提交成功，要么全部失败滚回。</p>\n<p><strong>一致性</strong>（Consistency）：数据库在事务执行的前后都保持一致性状态。在一致性状态下，所有事务对同一数据的读取结构是相同的。</p>\n<p><strong>隔离性</strong>（Islation）一个事务所做的修改在最终提交以前，对其他食物不可见。</p>\n<p><strong>持久性</strong>（Durability）一旦事务提交，则其所做的修改将会永远保存在数据库中。即使系统崩溃，事务执行结构也不会丢失。</p>\n<h2 id=\"2-并发一致性问题\"><a href=\"#2-并发一致性问题\" class=\"headerlink\" title=\"2.并发一致性问题\"></a>2.并发一致性问题</h2><p>在并发环境下，事务隔离性很难保证，因此会出现以下并发一致性问题。</p>\n<p><strong>丢失修改</strong>：一个事务的更新操作被另一个事务的更新操作替换，如下图所示：</p>\n<p><img src=\"/images/react/2021122103.png\"></p>\n<p><strong>读脏数据</strong>：当前事务可以读到另外事务未提交的数据，如下图所示：</p>\n<p><img src=\"/images/react/2021122104.png\"></p>\n<p><strong>不可重复读</strong>：在一个事务内多次读取同一数据，期间该数据被另一事务进行了修改，会导致重复读统一数据的结果不一致，如下图所示：</p>\n<p><img src=\"/images/react/2021122105.png\"></p>\n<h2 id=\"3-封锁\"><a href=\"#3-封锁\" class=\"headerlink\" title=\"3.封锁\"></a>3.封锁</h2><p><strong>封锁粒度</strong>：封锁粒度越细，锁定数据越少，发生锁争用的可能越小，系统的并发程度就越高，但是也会消耗更多的资源，所以在选择封锁粒度时需要有所权衡。</p>\n<p><strong>封锁类型</strong>：读写锁和意向锁。</p>\n<p><strong>封锁协议</strong>：包括一、二、三级封锁协议和两段锁协议。</p>\n<h2 id=\"4-关系数据库设计理论\"><a href=\"#4-关系数据库设计理论\" class=\"headerlink\" title=\"4.关系数据库设计理论\"></a>4.关系数据库设计理论</h2><h3 id=\"4-1-函数依赖\"><a href=\"#4-1-函数依赖\" class=\"headerlink\" title=\"4.1 函数依赖\"></a>4.1 函数依赖</h3><p>记A - &gt;B表示A决定B，也可以说B依赖于A。</p>\n<p><strong>键码</strong>：若（A1,A2,…An）是关系的一个或多个属性集合，该集合函数决定了关系的其他属性并且是最小的，那么该集合就是键码。</p>\n<p><strong>部份依赖</strong>：若A-&gt;B，但A的真子集A’-&gt;B成立，则A-&gt;B是部份依赖。</p>\n<p><strong>完全依赖</strong>：若A-&gt;B，且无A的真子集A’-&gt;B成立，则A-&gt;B是完全依赖。</p>\n<p><strong>依赖传递</strong>：A-&gt;B,B-&gt;C，则A-&gt;C。</p>\n<h3 id=\"4-2-范式\"><a href=\"#4-2-范式\" class=\"headerlink\" title=\"4.2 范式\"></a>4.2 范式</h3><p>高级别范式的依赖于低级别的范式，1NF（第一范式） 是最低级别的范式。</p>\n<p><strong>INF</strong>：属性不可分。</p>\n<p><strong>2NF</strong>：每个非主属性完全依赖于键码。</p>\n<p><strong>3NF</strong>：非主属性之间必须互相独立，不存在依赖关系。</p>\n<h3 id=\"4-3-异常\"><a href=\"#4-3-异常\" class=\"headerlink\" title=\"4.3 异常\"></a>4.3 异常</h3><p>不符合范式的关系，会出现很多异常，主要有以下四种：</p>\n<p><strong>冗余数据</strong>：比如一个记录多次出现在表内。</p>\n<p><strong>修改异常</strong>：修改了一个记录中的信息，但另一个记录中相同的信息却没有被修改。</p>\n<p><strong>删除异常</strong>：删除一个信息，那么也会丢失其他信息。</p>\n<p><strong>插入异常</strong>：因为关联问题出现无法插入记录错误。</p>\n<h2 id=\"5-ER图\"><a href=\"#5-ER图\" class=\"headerlink\" title=\"5.ER图\"></a>5.ER图</h2><p>实体关系图（Entity-Relationship），有三个组成部分：<u>实体、属性、联系</u>。</p>\n<p>实体之间存在三种关系，分别是<u>一对一、一对多和多对多关系</u>。</p>\n"},{"title":"使用hexo搭建博客时遇到的问题","date":"2021-12-11T05:40:40.000Z","_content":"\n主要是deploy部署问题的坑\n\n### 1.需要输入Github账号和密码，输入之后依旧部署失败\n\n问题描述：在输入命令 `hexo d` 来部署时提示需要输入Github的账号和密码进行验证，输入后提示登陆验证失败。\n\n解决方法：网上查询后得知是2021年8月13日之后github不支持输入账号密码登陆而要求输入token登陆，在参考了这篇博客资料后成功解决了该问题，直接在需要输入密码的地方输入token。\n\nhttps://blog.csdn.net/yjw123456/article/details/119696726#commentBox\n\n### 2.解决上面的问题，但是出现openSSL问题\n\n问题描述：错误信息：`OpenSSL SSL_read: Connection was reset, errno 10054`\n\n解决方法：删掉项目根目录下的 `.deploy_git` 文件，重新执行命令 `hexo d` ,参考以下这篇博客：\n\nhttps://www.cnblogs.com/tenderwx/p/5783432.html\n\n","source":"_posts/搭建hexo博客时出现的问题.md","raw":"---\ntitle: 使用hexo搭建博客时遇到的问题\ndate: 2021-12-11 13:40:40\ntags: [hexo, 学习]\ncategories:\n- 博客\n---\n\n主要是deploy部署问题的坑\n\n### 1.需要输入Github账号和密码，输入之后依旧部署失败\n\n问题描述：在输入命令 `hexo d` 来部署时提示需要输入Github的账号和密码进行验证，输入后提示登陆验证失败。\n\n解决方法：网上查询后得知是2021年8月13日之后github不支持输入账号密码登陆而要求输入token登陆，在参考了这篇博客资料后成功解决了该问题，直接在需要输入密码的地方输入token。\n\nhttps://blog.csdn.net/yjw123456/article/details/119696726#commentBox\n\n### 2.解决上面的问题，但是出现openSSL问题\n\n问题描述：错误信息：`OpenSSL SSL_read: Connection was reset, errno 10054`\n\n解决方法：删掉项目根目录下的 `.deploy_git` 文件，重新执行命令 `hexo d` ,参考以下这篇博客：\n\nhttps://www.cnblogs.com/tenderwx/p/5783432.html\n\n","slug":"搭建hexo博客时出现的问题","published":1,"updated":"2021-12-12T05:47:14.291Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh1w001c6wtv9i493ior","content":"<p>主要是deploy部署问题的坑</p>\n<h3 id=\"1-需要输入Github账号和密码，输入之后依旧部署失败\"><a href=\"#1-需要输入Github账号和密码，输入之后依旧部署失败\" class=\"headerlink\" title=\"1.需要输入Github账号和密码，输入之后依旧部署失败\"></a>1.需要输入Github账号和密码，输入之后依旧部署失败</h3><p>问题描述：在输入命令 <code>hexo d</code> 来部署时提示需要输入Github的账号和密码进行验证，输入后提示登陆验证失败。</p>\n<p>解决方法：网上查询后得知是2021年8月13日之后github不支持输入账号密码登陆而要求输入token登陆，在参考了这篇博客资料后成功解决了该问题，直接在需要输入密码的地方输入token。</p>\n<p><a href=\"https://blog.csdn.net/yjw123456/article/details/119696726#commentBox\">https://blog.csdn.net/yjw123456/article/details/119696726#commentBox</a></p>\n<h3 id=\"2-解决上面的问题，但是出现openSSL问题\"><a href=\"#2-解决上面的问题，但是出现openSSL问题\" class=\"headerlink\" title=\"2.解决上面的问题，但是出现openSSL问题\"></a>2.解决上面的问题，但是出现openSSL问题</h3><p>问题描述：错误信息：<code>OpenSSL SSL_read: Connection was reset, errno 10054</code></p>\n<p>解决方法：删掉项目根目录下的 <code>.deploy_git</code> 文件，重新执行命令 <code>hexo d</code> ,参考以下这篇博客：</p>\n<p><a href=\"https://www.cnblogs.com/tenderwx/p/5783432.html\">https://www.cnblogs.com/tenderwx/p/5783432.html</a></p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<p>主要是deploy部署问题的坑</p>\n<h3 id=\"1-需要输入Github账号和密码，输入之后依旧部署失败\"><a href=\"#1-需要输入Github账号和密码，输入之后依旧部署失败\" class=\"headerlink\" title=\"1.需要输入Github账号和密码，输入之后依旧部署失败\"></a>1.需要输入Github账号和密码，输入之后依旧部署失败</h3><p>问题描述：在输入命令 <code>hexo d</code> 来部署时提示需要输入Github的账号和密码进行验证，输入后提示登陆验证失败。</p>\n<p>解决方法：网上查询后得知是2021年8月13日之后github不支持输入账号密码登陆而要求输入token登陆，在参考了这篇博客资料后成功解决了该问题，直接在需要输入密码的地方输入token。</p>\n<p><a href=\"https://blog.csdn.net/yjw123456/article/details/119696726#commentBox\">https://blog.csdn.net/yjw123456/article/details/119696726#commentBox</a></p>\n<h3 id=\"2-解决上面的问题，但是出现openSSL问题\"><a href=\"#2-解决上面的问题，但是出现openSSL问题\" class=\"headerlink\" title=\"2.解决上面的问题，但是出现openSSL问题\"></a>2.解决上面的问题，但是出现openSSL问题</h3><p>问题描述：错误信息：<code>OpenSSL SSL_read: Connection was reset, errno 10054</code></p>\n<p>解决方法：删掉项目根目录下的 <code>.deploy_git</code> 文件，重新执行命令 <code>hexo d</code> ,参考以下这篇博客：</p>\n<p><a href=\"https://www.cnblogs.com/tenderwx/p/5783432.html\">https://www.cnblogs.com/tenderwx/p/5783432.html</a></p>\n"},{"title":"操作系统原理基础知识点","date":"2021-12-21T00:35:25.000Z","_content":"\n------\n\n*本文来源于https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过*。\n\n------\n\n\n\n## 1.基本特质\n\n操作系统的基本特征为并发、共享、虚拟、异步。\n\n**并发**：同一时间段运行多个程序，区分<u>并行</u>，并行指同一时刻运行多个指令，需要硬件支持。\n\n**共享**：指系统的资源可以被多个并发进程同时共享。共享方式分为<u>互斥共享</u>（同一时刻只允许一个进程访问，其共享资源被称为临界资源，比如打印机）和<u>同时共享</u>。\n\n**虚拟**：把一个物理实体转换为多个逻辑实体，虚拟技术有<u>时分复用技术</u>（比如多个进程并发执行）和<u>空分复用技术</u>（比如虚拟内存）。\n\n**异步**：进程不是一次性执行完毕。\n\n## 2.基本功能\n\n包括<u>进程管理</u>、<u>内存管理</u>、<u>文件管理</u>和<u>设备管理</u>。\n\n## 3.系统调用\n\n如果一个进程在用户态需要使用内核态功能，则进行系统调度，Linux的系统调度有<u>进程控制、进程通信、文件操作、设备操作、信息维护、安全</u>。\n\n## 4.大内核和微内核\n\n**大内核**：将操作系统功能作为一个紧密结合的整体放在内核中，各模块共享信息，具有高性能。\n\n**微内核**：将部分操作系统功能移除内核，只有微内核这部分模块处在内核态，可降低系统的复杂性。\n\n## 5.中断分类\n\n**外中断**：由CPU执行指令以外的事件引起的中断，如I/O完成中断等。\n\n**异常**：由CPU执行指令内部事件引起的中断，如地址越界等。\n\n**陷入**：在用户程序中使用系统调用引起。\n\n## 6.进程管理\n\n### 6.1 进程和线程\n\n**进程**：资源分配的基本单位，PCB（进程控制块）描述进程的基本信息和运行状态。\n\n**线程**：独立调度的基本单位，一个进程有多个线程，它们共享进程资源。\n\n**进程和线程的区别（面试题）：**\n\n进程是<u>资源分配</u>的基本单位，线程不拥有资源，但是线程可以访问所属进程的资源。\n\n进程<u>开销</u>大，在创建、撤销和切换进程时，系统都要为之分配或回收资源，而线程切换只需要保存和设置少量寄存器内容，开销小。\n\n进程<u>通信</u>需要借助IPC，线程间通过直接读写同一进程数据可进行通信。\n\n### 6.2 进程状态转换\n\n进程的状态转换如图所示：\n\n![](/images/react/2021122006.png)\n\n其中，<u>处于就绪状态和运行状态的进程可以相互转换</u>，其他状态进程只能单向转换。处于阻塞状态的进程是缺少资源（不包括时间资源）的进程。\n\n### 6.3 批处理系统\n\n该系统没有太多用户操作，调度算法包括<u>FCFS</u>（先来先服务，有利于长作业）、<u>SJF</u>（短作业优先，不利于长作业）、<u>SRTN</u>（最短剩余时间优先）。该系统的调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。\n\n### 6.4 交互式系统\n\n该系统有大量用户交互操作，调度算法包括<u>时间片轮转</u>、<u>优先级调度</u>、<u>多级反馈列表</u>。该系统的调度算法目标是快速进行响应。\n\n### 6.5 实时系统\n\n实时系统要求一个请求在一个确定时间内得到响应。分为<u>硬实时和软实时</u>，前者必须满足绝对的截止时间，后者可以容忍一定的超时。\n\n### 6.6 进程同步\n\n**临界区**：对临界资源进行访问的那段代码\n\n**同步**：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系\n\n**互斥**：多个进程在同一时刻只有一个进程能进入临界区。\n\n**信号量**：是一个整型变量，可以对其执行P/V操作，即-1/+1操作。\n\n## 7.内存管理\n\n**虚拟内存**：其目的是为了让物理内存扩充成更大的<u>逻辑内存</u>，让程序获得更多可用内存。\n\n**存储方式**：<u>分页存储</u>和<u>分段存储</u>。分页存储更加透明，分段存储需要程序员显示划分每个段。分页存储的地址空间是一维的，分段是二维的。页的大小不可改变，段的大小可以动态改变。分页主要用于实现虚拟内存，从而获得更大的地址空间，分段主要是为了使程序和数据可以被划分为逻辑独立的地址空间且有助于共享和保护。\n\n## 8.设备管理\n\n### 8.1 磁盘结构\n\n如下所示是磁盘结构图：\n\n![](/images/react/2021122101.png)\n\n**盘面**：一个磁盘有多个盘面；\n\n**磁道**：盘面上的圆形带状区域，一个盘面可以有多个磁道；\n\n**扇区**：磁道上的一个弧段，一个磁道可以有多个扇区，<u>它是最小的物理储存单位</u>，目前主要有 512 bytes 与 4 K 两种大小；\n\n**磁头**：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；\n\n**制动手臂**：用于在磁道之间移动磁头；\n\n**主轴**：使整个盘面转动。\n\n## 9.连接\n\n### 9.1 编译系统。\n\n一个.c文件被解析执行的具体过程图如下所示：\n\n![](/images/react/2021122102.png)\n\n`.c`文件先后要经过预处理阶段转为`.i`文件，再经过编译阶段转为`.s`程序，经过汇编器转为可重定位的`.o`程序，最后经过连接器转为可执行的目标程序。\n\n### 9.2 静态链接和动态链接\n\n**静态链接**：以一组可重定位文件为输入，通过完成<u>符号解析</u>和<u>重定位</u>生产一个完全可执行的输出文件。\n\n**动态连接**：为了解决静态库存在的更新时需要重新链接以及如`printf`这种标准函数库，如果每个程序都有代码会极大浪费资源的问题而出现了<u>共享库</u>。\n\n## 10.死锁\n\n死锁是指两个及以上进程执行过程中，由于竞争资源或彼此通信造成的阻塞现象，若无外力作用无法继续推进下去，而造成永久等待的情况。\n\n### 10.1 产生的原因条件\n\n**互斥**：资源以分配给其他进程，而某资源若需要使用资源只能等待。\n\n**请求和保持**：进程已经保持一个资源，但又提出新的资源请求，而此资源被其他进程占用，会造成一直占用已有资源并且一直等待的情况。\n\n**不可抢占**：已经分配给一个进程的资源不能强制性抢占，只能等待占有资源的进程显式释放。\n\n**环路等待**：两个及以上进程组成一条环路，该环路的每个进程都在等待下一个进程释放占有资源。\n\n### 10.2 处理方法\n\n**鸵鸟策略**：假装什么事都没发生，忽略死锁问题。\n\n**死锁检测与死锁恢复**：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。\n\n**死锁预防**：在程序运行前预防发生死锁。\n\n**死锁避免**：在程序运行时避免发生死锁。\n\n","source":"_posts/操作系统复习.md","raw":"---\ntitle: 操作系统原理基础知识点\ndate: 2021-12-21 08:35:25\ntags: [学习,前端面试，操作系统原理]\ncategories:\n- 计算机基础复习\n---\n\n------\n\n*本文来源于https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过*。\n\n------\n\n\n\n## 1.基本特质\n\n操作系统的基本特征为并发、共享、虚拟、异步。\n\n**并发**：同一时间段运行多个程序，区分<u>并行</u>，并行指同一时刻运行多个指令，需要硬件支持。\n\n**共享**：指系统的资源可以被多个并发进程同时共享。共享方式分为<u>互斥共享</u>（同一时刻只允许一个进程访问，其共享资源被称为临界资源，比如打印机）和<u>同时共享</u>。\n\n**虚拟**：把一个物理实体转换为多个逻辑实体，虚拟技术有<u>时分复用技术</u>（比如多个进程并发执行）和<u>空分复用技术</u>（比如虚拟内存）。\n\n**异步**：进程不是一次性执行完毕。\n\n## 2.基本功能\n\n包括<u>进程管理</u>、<u>内存管理</u>、<u>文件管理</u>和<u>设备管理</u>。\n\n## 3.系统调用\n\n如果一个进程在用户态需要使用内核态功能，则进行系统调度，Linux的系统调度有<u>进程控制、进程通信、文件操作、设备操作、信息维护、安全</u>。\n\n## 4.大内核和微内核\n\n**大内核**：将操作系统功能作为一个紧密结合的整体放在内核中，各模块共享信息，具有高性能。\n\n**微内核**：将部分操作系统功能移除内核，只有微内核这部分模块处在内核态，可降低系统的复杂性。\n\n## 5.中断分类\n\n**外中断**：由CPU执行指令以外的事件引起的中断，如I/O完成中断等。\n\n**异常**：由CPU执行指令内部事件引起的中断，如地址越界等。\n\n**陷入**：在用户程序中使用系统调用引起。\n\n## 6.进程管理\n\n### 6.1 进程和线程\n\n**进程**：资源分配的基本单位，PCB（进程控制块）描述进程的基本信息和运行状态。\n\n**线程**：独立调度的基本单位，一个进程有多个线程，它们共享进程资源。\n\n**进程和线程的区别（面试题）：**\n\n进程是<u>资源分配</u>的基本单位，线程不拥有资源，但是线程可以访问所属进程的资源。\n\n进程<u>开销</u>大，在创建、撤销和切换进程时，系统都要为之分配或回收资源，而线程切换只需要保存和设置少量寄存器内容，开销小。\n\n进程<u>通信</u>需要借助IPC，线程间通过直接读写同一进程数据可进行通信。\n\n### 6.2 进程状态转换\n\n进程的状态转换如图所示：\n\n![](/images/react/2021122006.png)\n\n其中，<u>处于就绪状态和运行状态的进程可以相互转换</u>，其他状态进程只能单向转换。处于阻塞状态的进程是缺少资源（不包括时间资源）的进程。\n\n### 6.3 批处理系统\n\n该系统没有太多用户操作，调度算法包括<u>FCFS</u>（先来先服务，有利于长作业）、<u>SJF</u>（短作业优先，不利于长作业）、<u>SRTN</u>（最短剩余时间优先）。该系统的调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。\n\n### 6.4 交互式系统\n\n该系统有大量用户交互操作，调度算法包括<u>时间片轮转</u>、<u>优先级调度</u>、<u>多级反馈列表</u>。该系统的调度算法目标是快速进行响应。\n\n### 6.5 实时系统\n\n实时系统要求一个请求在一个确定时间内得到响应。分为<u>硬实时和软实时</u>，前者必须满足绝对的截止时间，后者可以容忍一定的超时。\n\n### 6.6 进程同步\n\n**临界区**：对临界资源进行访问的那段代码\n\n**同步**：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系\n\n**互斥**：多个进程在同一时刻只有一个进程能进入临界区。\n\n**信号量**：是一个整型变量，可以对其执行P/V操作，即-1/+1操作。\n\n## 7.内存管理\n\n**虚拟内存**：其目的是为了让物理内存扩充成更大的<u>逻辑内存</u>，让程序获得更多可用内存。\n\n**存储方式**：<u>分页存储</u>和<u>分段存储</u>。分页存储更加透明，分段存储需要程序员显示划分每个段。分页存储的地址空间是一维的，分段是二维的。页的大小不可改变，段的大小可以动态改变。分页主要用于实现虚拟内存，从而获得更大的地址空间，分段主要是为了使程序和数据可以被划分为逻辑独立的地址空间且有助于共享和保护。\n\n## 8.设备管理\n\n### 8.1 磁盘结构\n\n如下所示是磁盘结构图：\n\n![](/images/react/2021122101.png)\n\n**盘面**：一个磁盘有多个盘面；\n\n**磁道**：盘面上的圆形带状区域，一个盘面可以有多个磁道；\n\n**扇区**：磁道上的一个弧段，一个磁道可以有多个扇区，<u>它是最小的物理储存单位</u>，目前主要有 512 bytes 与 4 K 两种大小；\n\n**磁头**：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；\n\n**制动手臂**：用于在磁道之间移动磁头；\n\n**主轴**：使整个盘面转动。\n\n## 9.连接\n\n### 9.1 编译系统。\n\n一个.c文件被解析执行的具体过程图如下所示：\n\n![](/images/react/2021122102.png)\n\n`.c`文件先后要经过预处理阶段转为`.i`文件，再经过编译阶段转为`.s`程序，经过汇编器转为可重定位的`.o`程序，最后经过连接器转为可执行的目标程序。\n\n### 9.2 静态链接和动态链接\n\n**静态链接**：以一组可重定位文件为输入，通过完成<u>符号解析</u>和<u>重定位</u>生产一个完全可执行的输出文件。\n\n**动态连接**：为了解决静态库存在的更新时需要重新链接以及如`printf`这种标准函数库，如果每个程序都有代码会极大浪费资源的问题而出现了<u>共享库</u>。\n\n## 10.死锁\n\n死锁是指两个及以上进程执行过程中，由于竞争资源或彼此通信造成的阻塞现象，若无外力作用无法继续推进下去，而造成永久等待的情况。\n\n### 10.1 产生的原因条件\n\n**互斥**：资源以分配给其他进程，而某资源若需要使用资源只能等待。\n\n**请求和保持**：进程已经保持一个资源，但又提出新的资源请求，而此资源被其他进程占用，会造成一直占用已有资源并且一直等待的情况。\n\n**不可抢占**：已经分配给一个进程的资源不能强制性抢占，只能等待占有资源的进程显式释放。\n\n**环路等待**：两个及以上进程组成一条环路，该环路的每个进程都在等待下一个进程释放占有资源。\n\n### 10.2 处理方法\n\n**鸵鸟策略**：假装什么事都没发生，忽略死锁问题。\n\n**死锁检测与死锁恢复**：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。\n\n**死锁预防**：在程序运行前预防发生死锁。\n\n**死锁避免**：在程序运行时避免发生死锁。\n\n","slug":"操作系统复习","published":1,"updated":"2021-12-21T12:24:14.910Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh1y001f6wtvh70ean62","content":"<hr>\n<p><em>本文来源于<a href=\"https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82%E5%B9%B6%E4%B8%94%E5%9B%A0%E4%B8%BA%E6%9C%AC%E6%AC%A1%E5%A4%8D%E4%B9%A0%E6%98%AF%E4%BA%89%E5%AF%B9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E4%BC%9A%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%88%BB%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%AA%E4%BC%9A%E7%B2%97%E7%95%A5%E6%89%AB%E8%BF%87\">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过</a></em>。</p>\n<hr>\n<h2 id=\"1-基本特质\"><a href=\"#1-基本特质\" class=\"headerlink\" title=\"1.基本特质\"></a>1.基本特质</h2><p>操作系统的基本特征为并发、共享、虚拟、异步。</p>\n<p><strong>并发</strong>：同一时间段运行多个程序，区分<u>并行</u>，并行指同一时刻运行多个指令，需要硬件支持。</p>\n<p><strong>共享</strong>：指系统的资源可以被多个并发进程同时共享。共享方式分为<u>互斥共享</u>（同一时刻只允许一个进程访问，其共享资源被称为临界资源，比如打印机）和<u>同时共享</u>。</p>\n<p><strong>虚拟</strong>：把一个物理实体转换为多个逻辑实体，虚拟技术有<u>时分复用技术</u>（比如多个进程并发执行）和<u>空分复用技术</u>（比如虚拟内存）。</p>\n<p><strong>异步</strong>：进程不是一次性执行完毕。</p>\n<h2 id=\"2-基本功能\"><a href=\"#2-基本功能\" class=\"headerlink\" title=\"2.基本功能\"></a>2.基本功能</h2><p>包括<u>进程管理</u>、<u>内存管理</u>、<u>文件管理</u>和<u>设备管理</u>。</p>\n<h2 id=\"3-系统调用\"><a href=\"#3-系统调用\" class=\"headerlink\" title=\"3.系统调用\"></a>3.系统调用</h2><p>如果一个进程在用户态需要使用内核态功能，则进行系统调度，Linux的系统调度有<u>进程控制、进程通信、文件操作、设备操作、信息维护、安全</u>。</p>\n<h2 id=\"4-大内核和微内核\"><a href=\"#4-大内核和微内核\" class=\"headerlink\" title=\"4.大内核和微内核\"></a>4.大内核和微内核</h2><p><strong>大内核</strong>：将操作系统功能作为一个紧密结合的整体放在内核中，各模块共享信息，具有高性能。</p>\n<p><strong>微内核</strong>：将部分操作系统功能移除内核，只有微内核这部分模块处在内核态，可降低系统的复杂性。</p>\n<h2 id=\"5-中断分类\"><a href=\"#5-中断分类\" class=\"headerlink\" title=\"5.中断分类\"></a>5.中断分类</h2><p><strong>外中断</strong>：由CPU执行指令以外的事件引起的中断，如I/O完成中断等。</p>\n<p><strong>异常</strong>：由CPU执行指令内部事件引起的中断，如地址越界等。</p>\n<p><strong>陷入</strong>：在用户程序中使用系统调用引起。</p>\n<h2 id=\"6-进程管理\"><a href=\"#6-进程管理\" class=\"headerlink\" title=\"6.进程管理\"></a>6.进程管理</h2><h3 id=\"6-1-进程和线程\"><a href=\"#6-1-进程和线程\" class=\"headerlink\" title=\"6.1 进程和线程\"></a>6.1 进程和线程</h3><p><strong>进程</strong>：资源分配的基本单位，PCB（进程控制块）描述进程的基本信息和运行状态。</p>\n<p><strong>线程</strong>：独立调度的基本单位，一个进程有多个线程，它们共享进程资源。</p>\n<p><strong>进程和线程的区别（面试题）：</strong></p>\n<p>进程是<u>资源分配</u>的基本单位，线程不拥有资源，但是线程可以访问所属进程的资源。</p>\n<p>进程<u>开销</u>大，在创建、撤销和切换进程时，系统都要为之分配或回收资源，而线程切换只需要保存和设置少量寄存器内容，开销小。</p>\n<p>进程<u>通信</u>需要借助IPC，线程间通过直接读写同一进程数据可进行通信。</p>\n<h3 id=\"6-2-进程状态转换\"><a href=\"#6-2-进程状态转换\" class=\"headerlink\" title=\"6.2 进程状态转换\"></a>6.2 进程状态转换</h3><p>进程的状态转换如图所示：</p>\n<p><img src=\"/images/react/2021122006.png\"></p>\n<p>其中，<u>处于就绪状态和运行状态的进程可以相互转换</u>，其他状态进程只能单向转换。处于阻塞状态的进程是缺少资源（不包括时间资源）的进程。</p>\n<h3 id=\"6-3-批处理系统\"><a href=\"#6-3-批处理系统\" class=\"headerlink\" title=\"6.3 批处理系统\"></a>6.3 批处理系统</h3><p>该系统没有太多用户操作，调度算法包括<u>FCFS</u>（先来先服务，有利于长作业）、<u>SJF</u>（短作业优先，不利于长作业）、<u>SRTN</u>（最短剩余时间优先）。该系统的调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>\n<h3 id=\"6-4-交互式系统\"><a href=\"#6-4-交互式系统\" class=\"headerlink\" title=\"6.4 交互式系统\"></a>6.4 交互式系统</h3><p>该系统有大量用户交互操作，调度算法包括<u>时间片轮转</u>、<u>优先级调度</u>、<u>多级反馈列表</u>。该系统的调度算法目标是快速进行响应。</p>\n<h3 id=\"6-5-实时系统\"><a href=\"#6-5-实时系统\" class=\"headerlink\" title=\"6.5 实时系统\"></a>6.5 实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。分为<u>硬实时和软实时</u>，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>\n<h3 id=\"6-6-进程同步\"><a href=\"#6-6-进程同步\" class=\"headerlink\" title=\"6.6 进程同步\"></a>6.6 进程同步</h3><p><strong>临界区</strong>：对临界资源进行访问的那段代码</p>\n<p><strong>同步</strong>：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系</p>\n<p><strong>互斥</strong>：多个进程在同一时刻只有一个进程能进入临界区。</p>\n<p><strong>信号量</strong>：是一个整型变量，可以对其执行P/V操作，即-1/+1操作。</p>\n<h2 id=\"7-内存管理\"><a href=\"#7-内存管理\" class=\"headerlink\" title=\"7.内存管理\"></a>7.内存管理</h2><p><strong>虚拟内存</strong>：其目的是为了让物理内存扩充成更大的<u>逻辑内存</u>，让程序获得更多可用内存。</p>\n<p><strong>存储方式</strong>：<u>分页存储</u>和<u>分段存储</u>。分页存储更加透明，分段存储需要程序员显示划分每个段。分页存储的地址空间是一维的，分段是二维的。页的大小不可改变，段的大小可以动态改变。分页主要用于实现虚拟内存，从而获得更大的地址空间，分段主要是为了使程序和数据可以被划分为逻辑独立的地址空间且有助于共享和保护。</p>\n<h2 id=\"8-设备管理\"><a href=\"#8-设备管理\" class=\"headerlink\" title=\"8.设备管理\"></a>8.设备管理</h2><h3 id=\"8-1-磁盘结构\"><a href=\"#8-1-磁盘结构\" class=\"headerlink\" title=\"8.1 磁盘结构\"></a>8.1 磁盘结构</h3><p>如下所示是磁盘结构图：</p>\n<p><img src=\"/images/react/2021122101.png\"></p>\n<p><strong>盘面</strong>：一个磁盘有多个盘面；</p>\n<p><strong>磁道</strong>：盘面上的圆形带状区域，一个盘面可以有多个磁道；</p>\n<p><strong>扇区</strong>：磁道上的一个弧段，一个磁道可以有多个扇区，<u>它是最小的物理储存单位</u>，目前主要有 512 bytes 与 4 K 两种大小；</p>\n<p><strong>磁头</strong>：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</p>\n<p><strong>制动手臂</strong>：用于在磁道之间移动磁头；</p>\n<p><strong>主轴</strong>：使整个盘面转动。</p>\n<h2 id=\"9-连接\"><a href=\"#9-连接\" class=\"headerlink\" title=\"9.连接\"></a>9.连接</h2><h3 id=\"9-1-编译系统。\"><a href=\"#9-1-编译系统。\" class=\"headerlink\" title=\"9.1 编译系统。\"></a>9.1 编译系统。</h3><p>一个.c文件被解析执行的具体过程图如下所示：</p>\n<p><img src=\"/images/react/2021122102.png\"></p>\n<p><code>.c</code>文件先后要经过预处理阶段转为<code>.i</code>文件，再经过编译阶段转为<code>.s</code>程序，经过汇编器转为可重定位的<code>.o</code>程序，最后经过连接器转为可执行的目标程序。</p>\n<h3 id=\"9-2-静态链接和动态链接\"><a href=\"#9-2-静态链接和动态链接\" class=\"headerlink\" title=\"9.2 静态链接和动态链接\"></a>9.2 静态链接和动态链接</h3><p><strong>静态链接</strong>：以一组可重定位文件为输入，通过完成<u>符号解析</u>和<u>重定位</u>生产一个完全可执行的输出文件。</p>\n<p><strong>动态连接</strong>：为了解决静态库存在的更新时需要重新链接以及如<code>printf</code>这种标准函数库，如果每个程序都有代码会极大浪费资源的问题而出现了<u>共享库</u>。</p>\n<h2 id=\"10-死锁\"><a href=\"#10-死锁\" class=\"headerlink\" title=\"10.死锁\"></a>10.死锁</h2><p>死锁是指两个及以上进程执行过程中，由于竞争资源或彼此通信造成的阻塞现象，若无外力作用无法继续推进下去，而造成永久等待的情况。</p>\n<h3 id=\"10-1-产生的原因条件\"><a href=\"#10-1-产生的原因条件\" class=\"headerlink\" title=\"10.1 产生的原因条件\"></a>10.1 产生的原因条件</h3><p><strong>互斥</strong>：资源以分配给其他进程，而某资源若需要使用资源只能等待。</p>\n<p><strong>请求和保持</strong>：进程已经保持一个资源，但又提出新的资源请求，而此资源被其他进程占用，会造成一直占用已有资源并且一直等待的情况。</p>\n<p><strong>不可抢占</strong>：已经分配给一个进程的资源不能强制性抢占，只能等待占有资源的进程显式释放。</p>\n<p><strong>环路等待</strong>：两个及以上进程组成一条环路，该环路的每个进程都在等待下一个进程释放占有资源。</p>\n<h3 id=\"10-2-处理方法\"><a href=\"#10-2-处理方法\" class=\"headerlink\" title=\"10.2 处理方法\"></a>10.2 处理方法</h3><p><strong>鸵鸟策略</strong>：假装什么事都没发生，忽略死锁问题。</p>\n<p><strong>死锁检测与死锁恢复</strong>：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>\n<p><strong>死锁预防</strong>：在程序运行前预防发生死锁。</p>\n<p><strong>死锁避免</strong>：在程序运行时避免发生死锁。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>本文来源于<a href=\"https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82%E5%B9%B6%E4%B8%94%E5%9B%A0%E4%B8%BA%E6%9C%AC%E6%AC%A1%E5%A4%8D%E4%B9%A0%E6%98%AF%E4%BA%89%E5%AF%B9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E4%BC%9A%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%88%BB%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%AA%E4%BC%9A%E7%B2%97%E7%95%A5%E6%89%AB%E8%BF%87\">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过</a></em>。</p>\n<hr>\n<h2 id=\"1-基本特质\"><a href=\"#1-基本特质\" class=\"headerlink\" title=\"1.基本特质\"></a>1.基本特质</h2><p>操作系统的基本特征为并发、共享、虚拟、异步。</p>\n<p><strong>并发</strong>：同一时间段运行多个程序，区分<u>并行</u>，并行指同一时刻运行多个指令，需要硬件支持。</p>\n<p><strong>共享</strong>：指系统的资源可以被多个并发进程同时共享。共享方式分为<u>互斥共享</u>（同一时刻只允许一个进程访问，其共享资源被称为临界资源，比如打印机）和<u>同时共享</u>。</p>\n<p><strong>虚拟</strong>：把一个物理实体转换为多个逻辑实体，虚拟技术有<u>时分复用技术</u>（比如多个进程并发执行）和<u>空分复用技术</u>（比如虚拟内存）。</p>\n<p><strong>异步</strong>：进程不是一次性执行完毕。</p>\n<h2 id=\"2-基本功能\"><a href=\"#2-基本功能\" class=\"headerlink\" title=\"2.基本功能\"></a>2.基本功能</h2><p>包括<u>进程管理</u>、<u>内存管理</u>、<u>文件管理</u>和<u>设备管理</u>。</p>\n<h2 id=\"3-系统调用\"><a href=\"#3-系统调用\" class=\"headerlink\" title=\"3.系统调用\"></a>3.系统调用</h2><p>如果一个进程在用户态需要使用内核态功能，则进行系统调度，Linux的系统调度有<u>进程控制、进程通信、文件操作、设备操作、信息维护、安全</u>。</p>\n<h2 id=\"4-大内核和微内核\"><a href=\"#4-大内核和微内核\" class=\"headerlink\" title=\"4.大内核和微内核\"></a>4.大内核和微内核</h2><p><strong>大内核</strong>：将操作系统功能作为一个紧密结合的整体放在内核中，各模块共享信息，具有高性能。</p>\n<p><strong>微内核</strong>：将部分操作系统功能移除内核，只有微内核这部分模块处在内核态，可降低系统的复杂性。</p>\n<h2 id=\"5-中断分类\"><a href=\"#5-中断分类\" class=\"headerlink\" title=\"5.中断分类\"></a>5.中断分类</h2><p><strong>外中断</strong>：由CPU执行指令以外的事件引起的中断，如I/O完成中断等。</p>\n<p><strong>异常</strong>：由CPU执行指令内部事件引起的中断，如地址越界等。</p>\n<p><strong>陷入</strong>：在用户程序中使用系统调用引起。</p>\n<h2 id=\"6-进程管理\"><a href=\"#6-进程管理\" class=\"headerlink\" title=\"6.进程管理\"></a>6.进程管理</h2><h3 id=\"6-1-进程和线程\"><a href=\"#6-1-进程和线程\" class=\"headerlink\" title=\"6.1 进程和线程\"></a>6.1 进程和线程</h3><p><strong>进程</strong>：资源分配的基本单位，PCB（进程控制块）描述进程的基本信息和运行状态。</p>\n<p><strong>线程</strong>：独立调度的基本单位，一个进程有多个线程，它们共享进程资源。</p>\n<p><strong>进程和线程的区别（面试题）：</strong></p>\n<p>进程是<u>资源分配</u>的基本单位，线程不拥有资源，但是线程可以访问所属进程的资源。</p>\n<p>进程<u>开销</u>大，在创建、撤销和切换进程时，系统都要为之分配或回收资源，而线程切换只需要保存和设置少量寄存器内容，开销小。</p>\n<p>进程<u>通信</u>需要借助IPC，线程间通过直接读写同一进程数据可进行通信。</p>\n<h3 id=\"6-2-进程状态转换\"><a href=\"#6-2-进程状态转换\" class=\"headerlink\" title=\"6.2 进程状态转换\"></a>6.2 进程状态转换</h3><p>进程的状态转换如图所示：</p>\n<p><img src=\"/images/react/2021122006.png\"></p>\n<p>其中，<u>处于就绪状态和运行状态的进程可以相互转换</u>，其他状态进程只能单向转换。处于阻塞状态的进程是缺少资源（不包括时间资源）的进程。</p>\n<h3 id=\"6-3-批处理系统\"><a href=\"#6-3-批处理系统\" class=\"headerlink\" title=\"6.3 批处理系统\"></a>6.3 批处理系统</h3><p>该系统没有太多用户操作，调度算法包括<u>FCFS</u>（先来先服务，有利于长作业）、<u>SJF</u>（短作业优先，不利于长作业）、<u>SRTN</u>（最短剩余时间优先）。该系统的调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>\n<h3 id=\"6-4-交互式系统\"><a href=\"#6-4-交互式系统\" class=\"headerlink\" title=\"6.4 交互式系统\"></a>6.4 交互式系统</h3><p>该系统有大量用户交互操作，调度算法包括<u>时间片轮转</u>、<u>优先级调度</u>、<u>多级反馈列表</u>。该系统的调度算法目标是快速进行响应。</p>\n<h3 id=\"6-5-实时系统\"><a href=\"#6-5-实时系统\" class=\"headerlink\" title=\"6.5 实时系统\"></a>6.5 实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。分为<u>硬实时和软实时</u>，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>\n<h3 id=\"6-6-进程同步\"><a href=\"#6-6-进程同步\" class=\"headerlink\" title=\"6.6 进程同步\"></a>6.6 进程同步</h3><p><strong>临界区</strong>：对临界资源进行访问的那段代码</p>\n<p><strong>同步</strong>：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系</p>\n<p><strong>互斥</strong>：多个进程在同一时刻只有一个进程能进入临界区。</p>\n<p><strong>信号量</strong>：是一个整型变量，可以对其执行P/V操作，即-1/+1操作。</p>\n<h2 id=\"7-内存管理\"><a href=\"#7-内存管理\" class=\"headerlink\" title=\"7.内存管理\"></a>7.内存管理</h2><p><strong>虚拟内存</strong>：其目的是为了让物理内存扩充成更大的<u>逻辑内存</u>，让程序获得更多可用内存。</p>\n<p><strong>存储方式</strong>：<u>分页存储</u>和<u>分段存储</u>。分页存储更加透明，分段存储需要程序员显示划分每个段。分页存储的地址空间是一维的，分段是二维的。页的大小不可改变，段的大小可以动态改变。分页主要用于实现虚拟内存，从而获得更大的地址空间，分段主要是为了使程序和数据可以被划分为逻辑独立的地址空间且有助于共享和保护。</p>\n<h2 id=\"8-设备管理\"><a href=\"#8-设备管理\" class=\"headerlink\" title=\"8.设备管理\"></a>8.设备管理</h2><h3 id=\"8-1-磁盘结构\"><a href=\"#8-1-磁盘结构\" class=\"headerlink\" title=\"8.1 磁盘结构\"></a>8.1 磁盘结构</h3><p>如下所示是磁盘结构图：</p>\n<p><img src=\"/images/react/2021122101.png\"></p>\n<p><strong>盘面</strong>：一个磁盘有多个盘面；</p>\n<p><strong>磁道</strong>：盘面上的圆形带状区域，一个盘面可以有多个磁道；</p>\n<p><strong>扇区</strong>：磁道上的一个弧段，一个磁道可以有多个扇区，<u>它是最小的物理储存单位</u>，目前主要有 512 bytes 与 4 K 两种大小；</p>\n<p><strong>磁头</strong>：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</p>\n<p><strong>制动手臂</strong>：用于在磁道之间移动磁头；</p>\n<p><strong>主轴</strong>：使整个盘面转动。</p>\n<h2 id=\"9-连接\"><a href=\"#9-连接\" class=\"headerlink\" title=\"9.连接\"></a>9.连接</h2><h3 id=\"9-1-编译系统。\"><a href=\"#9-1-编译系统。\" class=\"headerlink\" title=\"9.1 编译系统。\"></a>9.1 编译系统。</h3><p>一个.c文件被解析执行的具体过程图如下所示：</p>\n<p><img src=\"/images/react/2021122102.png\"></p>\n<p><code>.c</code>文件先后要经过预处理阶段转为<code>.i</code>文件，再经过编译阶段转为<code>.s</code>程序，经过汇编器转为可重定位的<code>.o</code>程序，最后经过连接器转为可执行的目标程序。</p>\n<h3 id=\"9-2-静态链接和动态链接\"><a href=\"#9-2-静态链接和动态链接\" class=\"headerlink\" title=\"9.2 静态链接和动态链接\"></a>9.2 静态链接和动态链接</h3><p><strong>静态链接</strong>：以一组可重定位文件为输入，通过完成<u>符号解析</u>和<u>重定位</u>生产一个完全可执行的输出文件。</p>\n<p><strong>动态连接</strong>：为了解决静态库存在的更新时需要重新链接以及如<code>printf</code>这种标准函数库，如果每个程序都有代码会极大浪费资源的问题而出现了<u>共享库</u>。</p>\n<h2 id=\"10-死锁\"><a href=\"#10-死锁\" class=\"headerlink\" title=\"10.死锁\"></a>10.死锁</h2><p>死锁是指两个及以上进程执行过程中，由于竞争资源或彼此通信造成的阻塞现象，若无外力作用无法继续推进下去，而造成永久等待的情况。</p>\n<h3 id=\"10-1-产生的原因条件\"><a href=\"#10-1-产生的原因条件\" class=\"headerlink\" title=\"10.1 产生的原因条件\"></a>10.1 产生的原因条件</h3><p><strong>互斥</strong>：资源以分配给其他进程，而某资源若需要使用资源只能等待。</p>\n<p><strong>请求和保持</strong>：进程已经保持一个资源，但又提出新的资源请求，而此资源被其他进程占用，会造成一直占用已有资源并且一直等待的情况。</p>\n<p><strong>不可抢占</strong>：已经分配给一个进程的资源不能强制性抢占，只能等待占有资源的进程显式释放。</p>\n<p><strong>环路等待</strong>：两个及以上进程组成一条环路，该环路的每个进程都在等待下一个进程释放占有资源。</p>\n<h3 id=\"10-2-处理方法\"><a href=\"#10-2-处理方法\" class=\"headerlink\" title=\"10.2 处理方法\"></a>10.2 处理方法</h3><p><strong>鸵鸟策略</strong>：假装什么事都没发生，忽略死锁问题。</p>\n<p><strong>死锁检测与死锁恢复</strong>：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>\n<p><strong>死锁预防</strong>：在程序运行前预防发生死锁。</p>\n<p><strong>死锁避免</strong>：在程序运行时避免发生死锁。</p>\n"},{"title":"正则表达式","date":"2021-12-21T08:11:05.000Z","_content":"\n------\n\n*本文来源于https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过*。\n\n------\n\n## 1.概述\n\n正则表达式用于文本内容的查找和替换，本身不是一种语言或软件。\n\n## 2.匹配单个字符\n\n`.`用来匹配单个任意字符，是元字符。如果想要匹配字符`.`，则要在前面加`\\`，即`\\.`，在`[]`里的`.`不是元字符。\n\n## 3.匹配一组字符\n\n`[]`定义一个 字符集合，`0-9`、`a-z`在`[]`中表示一个字符区间，用ASCII码确定。`^`在`[]`中是取非操作。 `abc[^0-9]`表示以'abc'开头，并且第四个字符不为数字的字符串。\n\n## 4.使用元字符\n\n`[\\b]`是删除一个字符的意思；`\\f`匹配换页符，`\\n`匹配换行符，`\\r`匹配回车符，`\\t`匹配制表符，`\\v`匹配垂直制表符。\n\n`\\d`等价于`[0-9]`，`\\D`等价于`[^0-9]`，`\\w`等价于`[a-zA-Z0-9_]`大小写字母、下划线和数字。`\\W`等价于`[^a-zA-Z0-9_]`。`\\s`表示任何一个空白字符，等价于`[\\f\\n\\r\\t\\v]`，`\\S`表示对`\\s`取非，等价于`[^\\f\\n\\r\\t\\v]`。\n\n`\\x`匹配十六进制字符,`\\0`匹配八进制字符，比如`\\xA`对应值为10的ASCII字符，即`\\n`。\n\n## 5.重复匹配\n\n`+`匹配1个或多个字符，`*`匹配0个或多个字符，`?`匹配0个或1个字符。\n\n`{n}`匹配n个字符，`{m,n}`匹配m~n个字符，`{m,}`匹配至少m个字符。\n\n`[\\w]+`表示匹配字母数字或下划线很多次，a+c表示1个或多个连续的a加上一个c。\n\n![](/images/react/2021122114.png)\n\n![](/images/react/2021122115.png)\n\n`*`和`+`都是贪婪的，会匹配尽可能多的内容。在后面加?可以转换为懒惰型元字符。\n\n`a.+c`的匹配结果可以是`abcabcabc`，即明明前三个字符已经满足匹配结果，但因为`+`是贪婪的所以会匹配尽可能多的字符。\n\n## 6.位置匹配\n\n`\\b`可以匹配一个单词的边界，边界是指位于`\\w`和`\\W`之间的位置，`\\B`匹配一个不是单词边界的位置。这两种匹配的都是位置，而不是字符串，比如`\\babc\\b`匹配的结果是3个字符串。\n\n`^`在字符集合外用作匹配整个字符串的开头，`$`匹配整个字符串的结尾。\n\n`^\\s*\\/\\/.*$`的意思是匹配一个开头是0到多个空白字符加上`//`结尾是1个到多个任意字符的一行字符串，如下图所示：\n\n![](/images/react/2021122118.png)\n\n## 7.子表达式\n\n`(ab){2,}`表示至少两个`ab`组合元素的字符。可以匹配abab或更多有ab的字符串。\n\n![](/images/react/2021122113.png)\n\n`|`是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。比如`(19|20)\\d{2}`的意思是匹配’19‘或'20'开头并且后面有两个任意数字的字符串，如下图所示：\n\n![](/images/react/2021122116.png)\n\n## 8.回溯引用\n\n回溯引用使用 **\\n** 来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和第n个子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。\n\n`<(h[1-6])>(\\w*?)<\\/\\1\\2>`里使用了两个回溯引用，分别引用了第一个表达式和第二个表达式，如下图所示：\n\n![](/images/react/2021122117.png)\n\n## 9.替换\n\n正则表达式也可以应用在文本替换上，这需要两个正则表达式，第一个用来查找，第二个用来替换。例如修改电话号码`313-555-1234`的格式为`(313) 555-1234`，则需要1.查找电话，正则表达式为`(\\d{3})(-)(\\d{3})(-)(\\d{4})`，利用子表达式将电话号码的格式划分。2.替换，正则表达式为`($1) $3-$5`，表示为在第一个子表达式查找的结果加上 () ，然后加一个空格，在第三个和第五个字表达式查找的结果中间加上 - 进行分隔。\n\n`\\l`表示把下一个字符转为小写，`\\u`表示把下一个字符转为大写，`\\L`表示把`\\L`和`\\E`之间的字符全部转为小写，`\\U`表示把`\\U`和`\\E`之间的字符全部转为大写，`\\E`表示结束`\\L`或`\\U`。\n\n## 10.前后查找\n\n前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。\n\n向前查找使用 `?=` 定义，它规定了尾部匹配的内容，这个匹配的内容在` ?= `之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 `?<= `定义（注: JavaScript 不支持向后匹配，Java 对其支持也不完善）。\n\n如`\\w+(?=@)`表示查找@字符前面的部分，如图所示：\n\n![](/images/react/2021122119.png)\n\n## 11.嵌入条件\n\n条件为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。\n\n比如`(\\()?abc(?(1)\\))`的意思是，先看第一个表达式即第一个`()`里的内容为`\\(`，表达式后面有一个`?`，目前为止的意思是匹配0或1个`(`，然后匹配字符串`abc`，然后遇到第二个子表达式，这个表达式为条件表达式，`?(1)`为条件，表示第一个表达式内容若成立，则需要执行`)`匹配，如下图所示：\n\n![](/images/react/2021122120.png)\n\n`?(?=-) `为前向查找条件，只有在以 - 为前向查找的结尾能匹配` \\d{5} `，才继续匹配 `-\\d{4}` ，如下图所示：\n\n![](/images/react/2021122121.png)","source":"_posts/正则表达式.md","raw":"---\ntitle: 正则表达式\ndate: 2021-12-21 16:11:05\ntags: [学习,前端面试，正则表达式]\ncategories:\n- 计算机基础复习\n---\n\n------\n\n*本文来源于https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过*。\n\n------\n\n## 1.概述\n\n正则表达式用于文本内容的查找和替换，本身不是一种语言或软件。\n\n## 2.匹配单个字符\n\n`.`用来匹配单个任意字符，是元字符。如果想要匹配字符`.`，则要在前面加`\\`，即`\\.`，在`[]`里的`.`不是元字符。\n\n## 3.匹配一组字符\n\n`[]`定义一个 字符集合，`0-9`、`a-z`在`[]`中表示一个字符区间，用ASCII码确定。`^`在`[]`中是取非操作。 `abc[^0-9]`表示以'abc'开头，并且第四个字符不为数字的字符串。\n\n## 4.使用元字符\n\n`[\\b]`是删除一个字符的意思；`\\f`匹配换页符，`\\n`匹配换行符，`\\r`匹配回车符，`\\t`匹配制表符，`\\v`匹配垂直制表符。\n\n`\\d`等价于`[0-9]`，`\\D`等价于`[^0-9]`，`\\w`等价于`[a-zA-Z0-9_]`大小写字母、下划线和数字。`\\W`等价于`[^a-zA-Z0-9_]`。`\\s`表示任何一个空白字符，等价于`[\\f\\n\\r\\t\\v]`，`\\S`表示对`\\s`取非，等价于`[^\\f\\n\\r\\t\\v]`。\n\n`\\x`匹配十六进制字符,`\\0`匹配八进制字符，比如`\\xA`对应值为10的ASCII字符，即`\\n`。\n\n## 5.重复匹配\n\n`+`匹配1个或多个字符，`*`匹配0个或多个字符，`?`匹配0个或1个字符。\n\n`{n}`匹配n个字符，`{m,n}`匹配m~n个字符，`{m,}`匹配至少m个字符。\n\n`[\\w]+`表示匹配字母数字或下划线很多次，a+c表示1个或多个连续的a加上一个c。\n\n![](/images/react/2021122114.png)\n\n![](/images/react/2021122115.png)\n\n`*`和`+`都是贪婪的，会匹配尽可能多的内容。在后面加?可以转换为懒惰型元字符。\n\n`a.+c`的匹配结果可以是`abcabcabc`，即明明前三个字符已经满足匹配结果，但因为`+`是贪婪的所以会匹配尽可能多的字符。\n\n## 6.位置匹配\n\n`\\b`可以匹配一个单词的边界，边界是指位于`\\w`和`\\W`之间的位置，`\\B`匹配一个不是单词边界的位置。这两种匹配的都是位置，而不是字符串，比如`\\babc\\b`匹配的结果是3个字符串。\n\n`^`在字符集合外用作匹配整个字符串的开头，`$`匹配整个字符串的结尾。\n\n`^\\s*\\/\\/.*$`的意思是匹配一个开头是0到多个空白字符加上`//`结尾是1个到多个任意字符的一行字符串，如下图所示：\n\n![](/images/react/2021122118.png)\n\n## 7.子表达式\n\n`(ab){2,}`表示至少两个`ab`组合元素的字符。可以匹配abab或更多有ab的字符串。\n\n![](/images/react/2021122113.png)\n\n`|`是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。比如`(19|20)\\d{2}`的意思是匹配’19‘或'20'开头并且后面有两个任意数字的字符串，如下图所示：\n\n![](/images/react/2021122116.png)\n\n## 8.回溯引用\n\n回溯引用使用 **\\n** 来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和第n个子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。\n\n`<(h[1-6])>(\\w*?)<\\/\\1\\2>`里使用了两个回溯引用，分别引用了第一个表达式和第二个表达式，如下图所示：\n\n![](/images/react/2021122117.png)\n\n## 9.替换\n\n正则表达式也可以应用在文本替换上，这需要两个正则表达式，第一个用来查找，第二个用来替换。例如修改电话号码`313-555-1234`的格式为`(313) 555-1234`，则需要1.查找电话，正则表达式为`(\\d{3})(-)(\\d{3})(-)(\\d{4})`，利用子表达式将电话号码的格式划分。2.替换，正则表达式为`($1) $3-$5`，表示为在第一个子表达式查找的结果加上 () ，然后加一个空格，在第三个和第五个字表达式查找的结果中间加上 - 进行分隔。\n\n`\\l`表示把下一个字符转为小写，`\\u`表示把下一个字符转为大写，`\\L`表示把`\\L`和`\\E`之间的字符全部转为小写，`\\U`表示把`\\U`和`\\E`之间的字符全部转为大写，`\\E`表示结束`\\L`或`\\U`。\n\n## 10.前后查找\n\n前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。\n\n向前查找使用 `?=` 定义，它规定了尾部匹配的内容，这个匹配的内容在` ?= `之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 `?<= `定义（注: JavaScript 不支持向后匹配，Java 对其支持也不完善）。\n\n如`\\w+(?=@)`表示查找@字符前面的部分，如图所示：\n\n![](/images/react/2021122119.png)\n\n## 11.嵌入条件\n\n条件为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。\n\n比如`(\\()?abc(?(1)\\))`的意思是，先看第一个表达式即第一个`()`里的内容为`\\(`，表达式后面有一个`?`，目前为止的意思是匹配0或1个`(`，然后匹配字符串`abc`，然后遇到第二个子表达式，这个表达式为条件表达式，`?(1)`为条件，表示第一个表达式内容若成立，则需要执行`)`匹配，如下图所示：\n\n![](/images/react/2021122120.png)\n\n`?(?=-) `为前向查找条件，只有在以 - 为前向查找的结尾能匹配` \\d{5} `，才继续匹配 `-\\d{4}` ，如下图所示：\n\n![](/images/react/2021122121.png)","slug":"正则表达式","published":1,"updated":"2021-12-21T12:24:38.372Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh26001k6wtvcrwu9vfc","content":"<hr>\n<p><em>本文来源于<a href=\"https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82%E5%B9%B6%E4%B8%94%E5%9B%A0%E4%B8%BA%E6%9C%AC%E6%AC%A1%E5%A4%8D%E4%B9%A0%E6%98%AF%E4%BA%89%E5%AF%B9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E4%BC%9A%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%88%BB%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%AA%E4%BC%9A%E7%B2%97%E7%95%A5%E6%89%AB%E8%BF%87\">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过</a></em>。</p>\n<hr>\n<h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1.概述\"></a>1.概述</h2><p>正则表达式用于文本内容的查找和替换，本身不是一种语言或软件。</p>\n<h2 id=\"2-匹配单个字符\"><a href=\"#2-匹配单个字符\" class=\"headerlink\" title=\"2.匹配单个字符\"></a>2.匹配单个字符</h2><p><code>.</code>用来匹配单个任意字符，是元字符。如果想要匹配字符<code>.</code>，则要在前面加<code>\\</code>，即<code>\\.</code>，在<code>[]</code>里的<code>.</code>不是元字符。</p>\n<h2 id=\"3-匹配一组字符\"><a href=\"#3-匹配一组字符\" class=\"headerlink\" title=\"3.匹配一组字符\"></a>3.匹配一组字符</h2><p><code>[]</code>定义一个 字符集合，<code>0-9</code>、<code>a-z</code>在<code>[]</code>中表示一个字符区间，用ASCII码确定。<code>^</code>在<code>[]</code>中是取非操作。 <code>abc[^0-9]</code>表示以’abc’开头，并且第四个字符不为数字的字符串。</p>\n<h2 id=\"4-使用元字符\"><a href=\"#4-使用元字符\" class=\"headerlink\" title=\"4.使用元字符\"></a>4.使用元字符</h2><p><code>[\\b]</code>是删除一个字符的意思；<code>\\f</code>匹配换页符，<code>\\n</code>匹配换行符，<code>\\r</code>匹配回车符，<code>\\t</code>匹配制表符，<code>\\v</code>匹配垂直制表符。</p>\n<p><code>\\d</code>等价于<code>[0-9]</code>，<code>\\D</code>等价于<code>[^0-9]</code>，<code>\\w</code>等价于<code>[a-zA-Z0-9_]</code>大小写字母、下划线和数字。<code>\\W</code>等价于<code>[^a-zA-Z0-9_]</code>。<code>\\s</code>表示任何一个空白字符，等价于<code>[\\f\\n\\r\\t\\v]</code>，<code>\\S</code>表示对<code>\\s</code>取非，等价于<code>[^\\f\\n\\r\\t\\v]</code>。</p>\n<p><code>\\x</code>匹配十六进制字符,<code>\\0</code>匹配八进制字符，比如<code>\\xA</code>对应值为10的ASCII字符，即<code>\\n</code>。</p>\n<h2 id=\"5-重复匹配\"><a href=\"#5-重复匹配\" class=\"headerlink\" title=\"5.重复匹配\"></a>5.重复匹配</h2><p><code>+</code>匹配1个或多个字符，<code>*</code>匹配0个或多个字符，<code>?</code>匹配0个或1个字符。</p>\n<p><code>&#123;n&#125;</code>匹配n个字符，<code>&#123;m,n&#125;</code>匹配m~n个字符，<code>&#123;m,&#125;</code>匹配至少m个字符。</p>\n<p><code>[\\w]+</code>表示匹配字母数字或下划线很多次，a+c表示1个或多个连续的a加上一个c。</p>\n<p><img src=\"/images/react/2021122114.png\"></p>\n<p><img src=\"/images/react/2021122115.png\"></p>\n<p><code>*</code>和<code>+</code>都是贪婪的，会匹配尽可能多的内容。在后面加?可以转换为懒惰型元字符。</p>\n<p><code>a.+c</code>的匹配结果可以是<code>abcabcabc</code>，即明明前三个字符已经满足匹配结果，但因为<code>+</code>是贪婪的所以会匹配尽可能多的字符。</p>\n<h2 id=\"6-位置匹配\"><a href=\"#6-位置匹配\" class=\"headerlink\" title=\"6.位置匹配\"></a>6.位置匹配</h2><p><code>\\b</code>可以匹配一个单词的边界，边界是指位于<code>\\w</code>和<code>\\W</code>之间的位置，<code>\\B</code>匹配一个不是单词边界的位置。这两种匹配的都是位置，而不是字符串，比如<code>\\babc\\b</code>匹配的结果是3个字符串。</p>\n<p><code>^</code>在字符集合外用作匹配整个字符串的开头，<code>$</code>匹配整个字符串的结尾。</p>\n<p><code>^\\s*\\/\\/.*$</code>的意思是匹配一个开头是0到多个空白字符加上<code>//</code>结尾是1个到多个任意字符的一行字符串，如下图所示：</p>\n<p><img src=\"/images/react/2021122118.png\"></p>\n<h2 id=\"7-子表达式\"><a href=\"#7-子表达式\" class=\"headerlink\" title=\"7.子表达式\"></a>7.子表达式</h2><p><code>(ab)&#123;2,&#125;</code>表示至少两个<code>ab</code>组合元素的字符。可以匹配abab或更多有ab的字符串。</p>\n<p><img src=\"/images/react/2021122113.png\"></p>\n<p><code>|</code>是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。比如<code>(19|20)\\d&#123;2&#125;</code>的意思是匹配’19‘或’20’开头并且后面有两个任意数字的字符串，如下图所示：</p>\n<p><img src=\"/images/react/2021122116.png\"></p>\n<h2 id=\"8-回溯引用\"><a href=\"#8-回溯引用\" class=\"headerlink\" title=\"8.回溯引用\"></a>8.回溯引用</h2><p>回溯引用使用 <strong>\\n</strong> 来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和第n个子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。</p>\n<p><code>&lt;(h[1-6])&gt;(\\w*?)&lt;\\/\\1\\2&gt;</code>里使用了两个回溯引用，分别引用了第一个表达式和第二个表达式，如下图所示：</p>\n<p><img src=\"/images/react/2021122117.png\"></p>\n<h2 id=\"9-替换\"><a href=\"#9-替换\" class=\"headerlink\" title=\"9.替换\"></a>9.替换</h2><p>正则表达式也可以应用在文本替换上，这需要两个正则表达式，第一个用来查找，第二个用来替换。例如修改电话号码<code>313-555-1234</code>的格式为<code>(313) 555-1234</code>，则需要1.查找电话，正则表达式为<code>(\\d&#123;3&#125;)(-)(\\d&#123;3&#125;)(-)(\\d&#123;4&#125;)</code>，利用子表达式将电话号码的格式划分。2.替换，正则表达式为<code>($1) $3-$5</code>，表示为在第一个子表达式查找的结果加上 () ，然后加一个空格，在第三个和第五个字表达式查找的结果中间加上 - 进行分隔。</p>\n<p><code>\\l</code>表示把下一个字符转为小写，<code>\\u</code>表示把下一个字符转为大写，<code>\\L</code>表示把<code>\\L</code>和<code>\\E</code>之间的字符全部转为小写，<code>\\U</code>表示把<code>\\U</code>和<code>\\E</code>之间的字符全部转为大写，<code>\\E</code>表示结束<code>\\L</code>或<code>\\U</code>。</p>\n<h2 id=\"10-前后查找\"><a href=\"#10-前后查找\" class=\"headerlink\" title=\"10.前后查找\"></a>10.前后查找</h2><p>前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。</p>\n<p>向前查找使用 <code>?=</code> 定义，它规定了尾部匹配的内容，这个匹配的内容在<code>?=</code>之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 <code>?&lt;= </code>定义（注: JavaScript 不支持向后匹配，Java 对其支持也不完善）。</p>\n<p>如<code>\\w+(?=@)</code>表示查找@字符前面的部分，如图所示：</p>\n<p><img src=\"/images/react/2021122119.png\"></p>\n<h2 id=\"11-嵌入条件\"><a href=\"#11-嵌入条件\" class=\"headerlink\" title=\"11.嵌入条件\"></a>11.嵌入条件</h2><p>条件为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。</p>\n<p>比如<code>(\\()?abc(?(1)\\))</code>的意思是，先看第一个表达式即第一个<code>()</code>里的内容为<code>\\(</code>，表达式后面有一个<code>?</code>，目前为止的意思是匹配0或1个<code>(</code>，然后匹配字符串<code>abc</code>，然后遇到第二个子表达式，这个表达式为条件表达式，<code>?(1)</code>为条件，表示第一个表达式内容若成立，则需要执行<code>)</code>匹配，如下图所示：</p>\n<p><img src=\"/images/react/2021122120.png\"></p>\n<p><code>?(?=-) </code>为前向查找条件，只有在以 - 为前向查找的结尾能匹配<code>\\d&#123;5&#125;</code>，才继续匹配 <code>-\\d&#123;4&#125;</code> ，如下图所示：</p>\n<p><img src=\"/images/react/2021122121.png\"></p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>本文来源于<a href=\"https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82%E5%B9%B6%E4%B8%94%E5%9B%A0%E4%B8%BA%E6%9C%AC%E6%AC%A1%E5%A4%8D%E4%B9%A0%E6%98%AF%E4%BA%89%E5%AF%B9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E4%BC%9A%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%88%BB%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%AA%E4%BC%9A%E7%B2%97%E7%95%A5%E6%89%AB%E8%BF%87\">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过</a></em>。</p>\n<hr>\n<h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1.概述\"></a>1.概述</h2><p>正则表达式用于文本内容的查找和替换，本身不是一种语言或软件。</p>\n<h2 id=\"2-匹配单个字符\"><a href=\"#2-匹配单个字符\" class=\"headerlink\" title=\"2.匹配单个字符\"></a>2.匹配单个字符</h2><p><code>.</code>用来匹配单个任意字符，是元字符。如果想要匹配字符<code>.</code>，则要在前面加<code>\\</code>，即<code>\\.</code>，在<code>[]</code>里的<code>.</code>不是元字符。</p>\n<h2 id=\"3-匹配一组字符\"><a href=\"#3-匹配一组字符\" class=\"headerlink\" title=\"3.匹配一组字符\"></a>3.匹配一组字符</h2><p><code>[]</code>定义一个 字符集合，<code>0-9</code>、<code>a-z</code>在<code>[]</code>中表示一个字符区间，用ASCII码确定。<code>^</code>在<code>[]</code>中是取非操作。 <code>abc[^0-9]</code>表示以’abc’开头，并且第四个字符不为数字的字符串。</p>\n<h2 id=\"4-使用元字符\"><a href=\"#4-使用元字符\" class=\"headerlink\" title=\"4.使用元字符\"></a>4.使用元字符</h2><p><code>[\\b]</code>是删除一个字符的意思；<code>\\f</code>匹配换页符，<code>\\n</code>匹配换行符，<code>\\r</code>匹配回车符，<code>\\t</code>匹配制表符，<code>\\v</code>匹配垂直制表符。</p>\n<p><code>\\d</code>等价于<code>[0-9]</code>，<code>\\D</code>等价于<code>[^0-9]</code>，<code>\\w</code>等价于<code>[a-zA-Z0-9_]</code>大小写字母、下划线和数字。<code>\\W</code>等价于<code>[^a-zA-Z0-9_]</code>。<code>\\s</code>表示任何一个空白字符，等价于<code>[\\f\\n\\r\\t\\v]</code>，<code>\\S</code>表示对<code>\\s</code>取非，等价于<code>[^\\f\\n\\r\\t\\v]</code>。</p>\n<p><code>\\x</code>匹配十六进制字符,<code>\\0</code>匹配八进制字符，比如<code>\\xA</code>对应值为10的ASCII字符，即<code>\\n</code>。</p>\n<h2 id=\"5-重复匹配\"><a href=\"#5-重复匹配\" class=\"headerlink\" title=\"5.重复匹配\"></a>5.重复匹配</h2><p><code>+</code>匹配1个或多个字符，<code>*</code>匹配0个或多个字符，<code>?</code>匹配0个或1个字符。</p>\n<p><code>&#123;n&#125;</code>匹配n个字符，<code>&#123;m,n&#125;</code>匹配m~n个字符，<code>&#123;m,&#125;</code>匹配至少m个字符。</p>\n<p><code>[\\w]+</code>表示匹配字母数字或下划线很多次，a+c表示1个或多个连续的a加上一个c。</p>\n<p><img src=\"/images/react/2021122114.png\"></p>\n<p><img src=\"/images/react/2021122115.png\"></p>\n<p><code>*</code>和<code>+</code>都是贪婪的，会匹配尽可能多的内容。在后面加?可以转换为懒惰型元字符。</p>\n<p><code>a.+c</code>的匹配结果可以是<code>abcabcabc</code>，即明明前三个字符已经满足匹配结果，但因为<code>+</code>是贪婪的所以会匹配尽可能多的字符。</p>\n<h2 id=\"6-位置匹配\"><a href=\"#6-位置匹配\" class=\"headerlink\" title=\"6.位置匹配\"></a>6.位置匹配</h2><p><code>\\b</code>可以匹配一个单词的边界，边界是指位于<code>\\w</code>和<code>\\W</code>之间的位置，<code>\\B</code>匹配一个不是单词边界的位置。这两种匹配的都是位置，而不是字符串，比如<code>\\babc\\b</code>匹配的结果是3个字符串。</p>\n<p><code>^</code>在字符集合外用作匹配整个字符串的开头，<code>$</code>匹配整个字符串的结尾。</p>\n<p><code>^\\s*\\/\\/.*$</code>的意思是匹配一个开头是0到多个空白字符加上<code>//</code>结尾是1个到多个任意字符的一行字符串，如下图所示：</p>\n<p><img src=\"/images/react/2021122118.png\"></p>\n<h2 id=\"7-子表达式\"><a href=\"#7-子表达式\" class=\"headerlink\" title=\"7.子表达式\"></a>7.子表达式</h2><p><code>(ab)&#123;2,&#125;</code>表示至少两个<code>ab</code>组合元素的字符。可以匹配abab或更多有ab的字符串。</p>\n<p><img src=\"/images/react/2021122113.png\"></p>\n<p><code>|</code>是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。比如<code>(19|20)\\d&#123;2&#125;</code>的意思是匹配’19‘或’20’开头并且后面有两个任意数字的字符串，如下图所示：</p>\n<p><img src=\"/images/react/2021122116.png\"></p>\n<h2 id=\"8-回溯引用\"><a href=\"#8-回溯引用\" class=\"headerlink\" title=\"8.回溯引用\"></a>8.回溯引用</h2><p>回溯引用使用 <strong>\\n</strong> 来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和第n个子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。</p>\n<p><code>&lt;(h[1-6])&gt;(\\w*?)&lt;\\/\\1\\2&gt;</code>里使用了两个回溯引用，分别引用了第一个表达式和第二个表达式，如下图所示：</p>\n<p><img src=\"/images/react/2021122117.png\"></p>\n<h2 id=\"9-替换\"><a href=\"#9-替换\" class=\"headerlink\" title=\"9.替换\"></a>9.替换</h2><p>正则表达式也可以应用在文本替换上，这需要两个正则表达式，第一个用来查找，第二个用来替换。例如修改电话号码<code>313-555-1234</code>的格式为<code>(313) 555-1234</code>，则需要1.查找电话，正则表达式为<code>(\\d&#123;3&#125;)(-)(\\d&#123;3&#125;)(-)(\\d&#123;4&#125;)</code>，利用子表达式将电话号码的格式划分。2.替换，正则表达式为<code>($1) $3-$5</code>，表示为在第一个子表达式查找的结果加上 () ，然后加一个空格，在第三个和第五个字表达式查找的结果中间加上 - 进行分隔。</p>\n<p><code>\\l</code>表示把下一个字符转为小写，<code>\\u</code>表示把下一个字符转为大写，<code>\\L</code>表示把<code>\\L</code>和<code>\\E</code>之间的字符全部转为小写，<code>\\U</code>表示把<code>\\U</code>和<code>\\E</code>之间的字符全部转为大写，<code>\\E</code>表示结束<code>\\L</code>或<code>\\U</code>。</p>\n<h2 id=\"10-前后查找\"><a href=\"#10-前后查找\" class=\"headerlink\" title=\"10.前后查找\"></a>10.前后查找</h2><p>前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。</p>\n<p>向前查找使用 <code>?=</code> 定义，它规定了尾部匹配的内容，这个匹配的内容在<code>?=</code>之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 <code>?&lt;= </code>定义（注: JavaScript 不支持向后匹配，Java 对其支持也不完善）。</p>\n<p>如<code>\\w+(?=@)</code>表示查找@字符前面的部分，如图所示：</p>\n<p><img src=\"/images/react/2021122119.png\"></p>\n<h2 id=\"11-嵌入条件\"><a href=\"#11-嵌入条件\" class=\"headerlink\" title=\"11.嵌入条件\"></a>11.嵌入条件</h2><p>条件为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。</p>\n<p>比如<code>(\\()?abc(?(1)\\))</code>的意思是，先看第一个表达式即第一个<code>()</code>里的内容为<code>\\(</code>，表达式后面有一个<code>?</code>，目前为止的意思是匹配0或1个<code>(</code>，然后匹配字符串<code>abc</code>，然后遇到第二个子表达式，这个表达式为条件表达式，<code>?(1)</code>为条件，表示第一个表达式内容若成立，则需要执行<code>)</code>匹配，如下图所示：</p>\n<p><img src=\"/images/react/2021122120.png\"></p>\n<p><code>?(?=-) </code>为前向查找条件，只有在以 - 为前向查找的结尾能匹配<code>\\d&#123;5&#125;</code>，才继续匹配 <code>-\\d&#123;4&#125;</code> ，如下图所示：</p>\n<p><img src=\"/images/react/2021122121.png\"></p>\n"},{"title":"日本女性简简简史笔记","date":"2022-01-24T08:25:48.000Z","_content":"\n*”元始，女性是太阳，一个真正的人。 如今，女性是月亮，仰赖他人而存在， 依靠他人的亮光而发光， 是宛若病人的苍白月亮。“——《青鞜》*\n\n# 原始社会中日本女性地位\n\n原始日本社会为母系社会，据记载伊邪那岐命生下三子，其中以女性的天照大神奉为权力至高的神明，象征和代表着太阳。直到弥生时代（公元前300年-公元后300年），这个时段社会逐渐由母权社会慢慢转向父权社会，但依旧有很多女性领袖人物，女性领主（还有一个小故事：一个女皇去世了她的儿子继位但是造成了动乱，后她的女儿继位才平息了动乱）。这个时代的婚姻制度也比较开发，虽然社会已经逐步转向父系社会，但在家庭和婚姻的层面上依旧保留着浓烈的母权色彩，女性依旧占据主导地位，婚姻多为群婚制度，男女双方的自由度很高，可以说是多妻多夫。\n\n# 古代社会中日本女性地位变化\n\n- 飞鸟时代（公元592-公元710）这个时间段一共出现了5位女天皇，男皇执政时间只有14年。奈良时代（公元711-公元794）这个阶段7位天皇中也有4位是女皇。这个时段依旧在社会上是父系社会，出现这么多女皇的原因之一是大多数女皇都是男天皇的皇后，而皇后都是从男皇同父异母的姐妹中选出来的，日本古代向来认为血缘连接是母方血液的连接，而只禁止母系通婚不禁止父系通婚。所以会认为本就是同一氏族的女儿也有继承权，而且这一阶段皇后的权力和皇太子权力同等，天皇逝世权力则优先传于皇后。\n\n- 平安时代（公元794-公元1192），女性文学大量涌现，如《源氏物语》《枕草子》都为平安时代女性文学，并且由于贵族女性写作习惯出现了“女手”，就是现今日本的公用文字平假名。弥生时代到平安时代，日本流行的婚姻制度为访妻制，访妻制为男女双方互通情愫后，男方就可以在晚上去女方家，第二天早上就得离开的形式，社会层面上是以父系氏族为主的父权社会，但是家庭层面上却是母系连接，社会层面上是一夫多妻制，但是女方其实为婚姻的主体，女方自由度高，女性亦可在有婚姻关系时与其他男性接触相处，若男方不再访问女方也就很自然解除婚姻关系，这个时段婚姻的主导权多在女方母亲手里。夫妻双方实际为疏离关系，即使结婚也不是一家人，女方生下的孩子虽然和男方姓，但是由女方抚养和教育，属于女方家庭成员而不属于男方家庭成员，也不会认为同父异母的姐妹兄弟和自己有亲属关系，只有母方亲属才被认为有血液的亲属关系。在这样强烈母权色彩的婚姻制度下，女性在家庭的地位极高，女性有完整的继承权，家庭财产也是优先传给女性。（感觉这个时段男人只是生育工具）\n\n- 平安时代中后期逐渐出现了招婿制，这是家庭层面上逐渐从母系转向父系的过度时期，这个时期婚姻前后很长一段时间男方需要居住在女方家中，直到女方认为时机成熟再搬到男方家中居住，招婿制度的婚姻主导权逐渐转向女方父亲。平安时期以后婚姻制度就变为现在的嫁娶制，婚姻主导权转为男方父亲，女性逐渐转为客体的地位。\n\n- 平安时代之后也就是镰仓时代，随着幕府建立，武士阶层的固化，以及中国朱子儒学中女子三从四德思想在武士阶层的影响，女性开始被严重规训和束缚。“家庭制”的巩固，社会上的男权到家庭上的父权，无论是婚姻上还是身体思想上女性都被束缚，女性文学也淹没了很长一段时间，但即使是这个时候，女性在日本的地位依旧比其他儒学影响社会要高出很多，由于传统崇拜女性习俗的影响，在非武士阶层女性依旧有着相对多和大的权力，许多村落女性依旧有参政权，女性也有家庭财产继承权，若家庭无长子其财产则会顺位继承给长女。\n\n# 明治时代日本女性地位变化\n\n明治时代（1868-1911），受到西方民主思想的影响，日本社会进行了很大的变革（明治维新），逐步走向近代化民主国家，但是日本的变革是“先天不足”的——因为天皇制的保留让很多变革趋于形式，出现很多矛盾，其中女性问题特别尖锐。\n\n- 明治初期一些近代思想家受到西方思想影响猛烈抨击了传统的性别价值观，提出男女平权言论。女性开始获得”身体“上的自由，开始从”家庭制度“的束缚中解放出来。\n\n- 明治中期，受到西方“天赋人权”影响出现了自由民权运动——日本最大规模的国民政治运动，女性解放运动也由此进入发轫期。该阶段多为妇女运动家积极开展抗议和组织运动，1880年成功获得女户主参政权、她们有人积极开展女性教育、女性参政等运动，拉开了日本妇女解放运动的序幕。\n\n- 明治后期，由于民权运动直接威胁到明治政府的统治，政府开始放弃文明开化的道路转而强调日本传统意识形态。其中做出了三种政策来限制妇女的权力：1890年推出法律废除妇女参政权；1898年《民法》强调宗法家庭制，强调男户主和嫡长子的权利，对女性的权利做出极大打压，她们甚至无权处理家庭财产；一方面为了富国强兵不断加强女性教育，另一方面又极力给女性灌输“贤妻良母”的教育，企图将女性打造为优质的没有主体意识的生育工具。该年《民法》中还明确规定妻随夫姓的条规，近代以前并没有这样的传统，进一步让女性堕入社会边缘。\n\n- 面对政府强力打压女性运动，妇女只能将运动的中心转向文学，此时出现了许多文学作品来宣传自由民主以及权利解放意识，这个阶段的代表人物谢野晶子受到西方民主和浪漫主义思想影响发表的《乱发》讽刺了官僚和政府震惊整个日本文坛，促进了日本知识女性的自我觉醒。\n\n在明治时期出现了三个杰出的女权运动代表家，她们的开始是热烈和高涨的，结局确实低迷的妥协的。她们前期积极争取女性选举权、教育权等权益，后来却被打压到社会边缘。一个转身家庭只能靠纸笔论述女性问题，一个饱受牢狱之灾却转身反思自己和转变观念，而另一个也是迫于婚姻家庭只能克制自己的表达欲望。\n\n明治维新时期，虽然政府大力提倡女子受教育，也大力提高了女子入学率，但是那时想要培养的是“贤妻良母”的女子，明治维新初期的教育起初是模仿西方女性教育课程的，极大的和女子教育课程相似，家政课只占极少内容，直到自由民权运动极大威胁到了政府，政府放弃了西化的模仿，选择加强传统意识形态，又意识到女子必须受教育才能富强国家，所以极力灌输女子的教育是有非常强烈传统意识、家庭意识、民族意识的教育。\n\n# 明治时代之后到今天\n\n- 青鞜社的建立。1911年6月建立了日本第一个全部由女性组成的社团组织，发表杂志《青鞜》，在日本史上第一次出现了“新女性”，前后聚拢了许多日本女性革命家，发表的《女性原本是太阳》就像是一份“女性解放宣言”深深影响了整个文坛，是千百年来日本女性发出的第一声有份量的呐喊，她们吸取了西方女权运动的经验而转以文学实践形式出金女性觉醒，青鞜社的成立正式揭开女性解放运动的序幕。（1916年就被解散）\n\n- 进入大正时代的日本加速进入军国主义阶段，为了配合侵略运动，日本政府在原来的“贤妻良母”形式女性教育下添加了更多的民族主义色彩，他们打造“军国之母”的形象来宣言和赞扬那些有民族主义精神，积极送自己的丈夫和儿子进入战场，并且能够积极生育来增长国家人口的女性形象。在此期间，也有少部分女性积极开展女性解放运动，都被政府无情打压。\n\n- 二战日本战败后受到联合国的管制，美方向日本提出的五大改革之一的第一条就是解放妇女。从此妇女拥有了选举权、参政权、婚姻家庭上也和男方拥有一样的权力，在法律上实现了初步男女平等。\n\n- 联合国的七年管制后日本政府重新掌握国家主权，战后资本主义国家经济高速发展，无论是西方还是日本都出现了“主妇回归潮\"——战后第一产业高速发展需要更多的体力劳动，女性开始回归家庭。这个阶段东西方资本主义国家的妇女就业都成M型趋势——婚育前女性参加工作，婚育后暂时回归家庭，待孩子长大到一定岁数后再次回归职场。但是由于西方意识形态逐渐改进，有意识在制度上支持女性工作，所以西方社会女性就业曲线逐渐转化为“倒U型”——即婚育后也不会脱离职场。而日本由于本土意识形态以及高速压缩资本主义国家现代化历程在社会性别分工方面与欧美出现很大偏差。\n\n- 战后日本经济高速发展，也有越来越多的年轻劳动力涌入市场。前期女性劳动者也迅速增长，但是女性劳动者多为临时工或短期工，政策上没有推进女性持续就业导致大部分女性都回归到了家庭。为了使得充分有效利用劳动人员，日本在政策上支持男性全身心投入工作，而支持妇女回归家庭。196X年颁布法律鼓励妇女回归家庭，在经济层面上回归家庭的妇女会给家庭带来很大的经济补贴（免额度税务，添加年度工资补贴等使得女性回归家庭后能为家庭带来每年70万日元左右的金额），让西方社会的“去妇女回归家庭化”现象并没有出现，反而加重或者是固化了妇女回归家庭的现状。另外男女同工不同酬的情况持续到了1986年，即使在该年之后依旧在占据人们经济来源很大一部分的奖金层面上女性普遍也只有男性的1/2-2/3。日本女性M型就业曲线直到2009年都没有实质性的改变，直到现在依旧是M型曲线形式。\n\n- 在教育层面上，日本保留并支持大量女子学校的开办，大部分女子学校依旧以明治维新时期“贤妻良母”的思想为教育女性的方针，比如有名的双叶学校（出过很多名人以及名人的妻子，出过两代皇后）的校训依旧是百年前的“天真无邪，行事踏实”。鼓励性别差异教育，从婴儿阶段就对男女性别准备不同色彩的服饰和生活用品。这样的教育方针导致日本的性别分工意识形态发展比较缓慢，直到2002年的统计数据才第一次出现人们反对“男主外，女主内”思想人数高于赞成的人（但是后面2012年的统计数据出现回返现象），而最近（2019年）的统计数据显示日本赞成该思想的人数依旧还有1/3。\n\n- 日本的女性地位其实和日本的女性主义进展没有直接的关系。由于战后支持的民主自由的主调思想让学术上的研究得以支持和发展。所以日本有许多开设女性主义相关的课程。但是在社会女性地位上却不容乐观。日本女性研究专家将1970年-1975年视为女性解放阶段，将1976-1985年称为女性主义阶段。其中因为1975年国际妇人年对日本的影响-到1985年国际妇人年结束，加上上世纪八十年代日本经历泡沫经济时代，日本被迫进行改革，传统的夫妻分工形式受到了动摇。越来越多人在性别问题上有了更加先进的意识形态。但是日本一直都面临着意识形态和社会现状错位的问题，即使在2002年多数人反对“男主外，女主内”思想，社会情况却不容乐观且难以改变。\n\n- 2010年安倍内阁提出“女性经济学”，想要支持女性在市场职场上的发展，最后政策实行结构也没有太大的改变。因为其根本问题是社会层面，意识形态的问题，但是安倍提出的却是经济方针，女性就业困难问题依旧没有得到乐观的改善。\n\n日本女性史是一个需要深入探索和研究的学科，而我只用了一周零零散散的时间寻找国内论文进行了整理，既没有找过日本学者的相关论文也没有系统阅读过哪本相关研究的书籍。而且这一个姑且能够用时间线串联起来的简简简史也是阅读了一堆杂乱的无序的论文后拼凑起来的“别人的言论”。但是在阅读和整理过程中还是有很大收货的，也对这个和我们有很大渊源的邻国有了更深的了解。以前就很喜欢日本，喜欢日本动画，日本电影，日本文学，即使去年读了《菊与刀》对日本很下头了一阵子后还是重新拾回对日本的好感。这一次的研究到没有下头，是更了解日本了，比起读《菊与刀》产生的因陌生导致的误解有了更多的理解和同理心。现在觉得，日本真是一个复杂的国家，但是哪个国家不是呢？\n","source":"_posts/日本女性简简简史笔记.md","raw":"---\ntitle: 日本女性简简简史笔记\ndate: 2022-01-24 16:25:48\ntags: \n---\n\n*”元始，女性是太阳，一个真正的人。 如今，女性是月亮，仰赖他人而存在， 依靠他人的亮光而发光， 是宛若病人的苍白月亮。“——《青鞜》*\n\n# 原始社会中日本女性地位\n\n原始日本社会为母系社会，据记载伊邪那岐命生下三子，其中以女性的天照大神奉为权力至高的神明，象征和代表着太阳。直到弥生时代（公元前300年-公元后300年），这个时段社会逐渐由母权社会慢慢转向父权社会，但依旧有很多女性领袖人物，女性领主（还有一个小故事：一个女皇去世了她的儿子继位但是造成了动乱，后她的女儿继位才平息了动乱）。这个时代的婚姻制度也比较开发，虽然社会已经逐步转向父系社会，但在家庭和婚姻的层面上依旧保留着浓烈的母权色彩，女性依旧占据主导地位，婚姻多为群婚制度，男女双方的自由度很高，可以说是多妻多夫。\n\n# 古代社会中日本女性地位变化\n\n- 飞鸟时代（公元592-公元710）这个时间段一共出现了5位女天皇，男皇执政时间只有14年。奈良时代（公元711-公元794）这个阶段7位天皇中也有4位是女皇。这个时段依旧在社会上是父系社会，出现这么多女皇的原因之一是大多数女皇都是男天皇的皇后，而皇后都是从男皇同父异母的姐妹中选出来的，日本古代向来认为血缘连接是母方血液的连接，而只禁止母系通婚不禁止父系通婚。所以会认为本就是同一氏族的女儿也有继承权，而且这一阶段皇后的权力和皇太子权力同等，天皇逝世权力则优先传于皇后。\n\n- 平安时代（公元794-公元1192），女性文学大量涌现，如《源氏物语》《枕草子》都为平安时代女性文学，并且由于贵族女性写作习惯出现了“女手”，就是现今日本的公用文字平假名。弥生时代到平安时代，日本流行的婚姻制度为访妻制，访妻制为男女双方互通情愫后，男方就可以在晚上去女方家，第二天早上就得离开的形式，社会层面上是以父系氏族为主的父权社会，但是家庭层面上却是母系连接，社会层面上是一夫多妻制，但是女方其实为婚姻的主体，女方自由度高，女性亦可在有婚姻关系时与其他男性接触相处，若男方不再访问女方也就很自然解除婚姻关系，这个时段婚姻的主导权多在女方母亲手里。夫妻双方实际为疏离关系，即使结婚也不是一家人，女方生下的孩子虽然和男方姓，但是由女方抚养和教育，属于女方家庭成员而不属于男方家庭成员，也不会认为同父异母的姐妹兄弟和自己有亲属关系，只有母方亲属才被认为有血液的亲属关系。在这样强烈母权色彩的婚姻制度下，女性在家庭的地位极高，女性有完整的继承权，家庭财产也是优先传给女性。（感觉这个时段男人只是生育工具）\n\n- 平安时代中后期逐渐出现了招婿制，这是家庭层面上逐渐从母系转向父系的过度时期，这个时期婚姻前后很长一段时间男方需要居住在女方家中，直到女方认为时机成熟再搬到男方家中居住，招婿制度的婚姻主导权逐渐转向女方父亲。平安时期以后婚姻制度就变为现在的嫁娶制，婚姻主导权转为男方父亲，女性逐渐转为客体的地位。\n\n- 平安时代之后也就是镰仓时代，随着幕府建立，武士阶层的固化，以及中国朱子儒学中女子三从四德思想在武士阶层的影响，女性开始被严重规训和束缚。“家庭制”的巩固，社会上的男权到家庭上的父权，无论是婚姻上还是身体思想上女性都被束缚，女性文学也淹没了很长一段时间，但即使是这个时候，女性在日本的地位依旧比其他儒学影响社会要高出很多，由于传统崇拜女性习俗的影响，在非武士阶层女性依旧有着相对多和大的权力，许多村落女性依旧有参政权，女性也有家庭财产继承权，若家庭无长子其财产则会顺位继承给长女。\n\n# 明治时代日本女性地位变化\n\n明治时代（1868-1911），受到西方民主思想的影响，日本社会进行了很大的变革（明治维新），逐步走向近代化民主国家，但是日本的变革是“先天不足”的——因为天皇制的保留让很多变革趋于形式，出现很多矛盾，其中女性问题特别尖锐。\n\n- 明治初期一些近代思想家受到西方思想影响猛烈抨击了传统的性别价值观，提出男女平权言论。女性开始获得”身体“上的自由，开始从”家庭制度“的束缚中解放出来。\n\n- 明治中期，受到西方“天赋人权”影响出现了自由民权运动——日本最大规模的国民政治运动，女性解放运动也由此进入发轫期。该阶段多为妇女运动家积极开展抗议和组织运动，1880年成功获得女户主参政权、她们有人积极开展女性教育、女性参政等运动，拉开了日本妇女解放运动的序幕。\n\n- 明治后期，由于民权运动直接威胁到明治政府的统治，政府开始放弃文明开化的道路转而强调日本传统意识形态。其中做出了三种政策来限制妇女的权力：1890年推出法律废除妇女参政权；1898年《民法》强调宗法家庭制，强调男户主和嫡长子的权利，对女性的权利做出极大打压，她们甚至无权处理家庭财产；一方面为了富国强兵不断加强女性教育，另一方面又极力给女性灌输“贤妻良母”的教育，企图将女性打造为优质的没有主体意识的生育工具。该年《民法》中还明确规定妻随夫姓的条规，近代以前并没有这样的传统，进一步让女性堕入社会边缘。\n\n- 面对政府强力打压女性运动，妇女只能将运动的中心转向文学，此时出现了许多文学作品来宣传自由民主以及权利解放意识，这个阶段的代表人物谢野晶子受到西方民主和浪漫主义思想影响发表的《乱发》讽刺了官僚和政府震惊整个日本文坛，促进了日本知识女性的自我觉醒。\n\n在明治时期出现了三个杰出的女权运动代表家，她们的开始是热烈和高涨的，结局确实低迷的妥协的。她们前期积极争取女性选举权、教育权等权益，后来却被打压到社会边缘。一个转身家庭只能靠纸笔论述女性问题，一个饱受牢狱之灾却转身反思自己和转变观念，而另一个也是迫于婚姻家庭只能克制自己的表达欲望。\n\n明治维新时期，虽然政府大力提倡女子受教育，也大力提高了女子入学率，但是那时想要培养的是“贤妻良母”的女子，明治维新初期的教育起初是模仿西方女性教育课程的，极大的和女子教育课程相似，家政课只占极少内容，直到自由民权运动极大威胁到了政府，政府放弃了西化的模仿，选择加强传统意识形态，又意识到女子必须受教育才能富强国家，所以极力灌输女子的教育是有非常强烈传统意识、家庭意识、民族意识的教育。\n\n# 明治时代之后到今天\n\n- 青鞜社的建立。1911年6月建立了日本第一个全部由女性组成的社团组织，发表杂志《青鞜》，在日本史上第一次出现了“新女性”，前后聚拢了许多日本女性革命家，发表的《女性原本是太阳》就像是一份“女性解放宣言”深深影响了整个文坛，是千百年来日本女性发出的第一声有份量的呐喊，她们吸取了西方女权运动的经验而转以文学实践形式出金女性觉醒，青鞜社的成立正式揭开女性解放运动的序幕。（1916年就被解散）\n\n- 进入大正时代的日本加速进入军国主义阶段，为了配合侵略运动，日本政府在原来的“贤妻良母”形式女性教育下添加了更多的民族主义色彩，他们打造“军国之母”的形象来宣言和赞扬那些有民族主义精神，积极送自己的丈夫和儿子进入战场，并且能够积极生育来增长国家人口的女性形象。在此期间，也有少部分女性积极开展女性解放运动，都被政府无情打压。\n\n- 二战日本战败后受到联合国的管制，美方向日本提出的五大改革之一的第一条就是解放妇女。从此妇女拥有了选举权、参政权、婚姻家庭上也和男方拥有一样的权力，在法律上实现了初步男女平等。\n\n- 联合国的七年管制后日本政府重新掌握国家主权，战后资本主义国家经济高速发展，无论是西方还是日本都出现了“主妇回归潮\"——战后第一产业高速发展需要更多的体力劳动，女性开始回归家庭。这个阶段东西方资本主义国家的妇女就业都成M型趋势——婚育前女性参加工作，婚育后暂时回归家庭，待孩子长大到一定岁数后再次回归职场。但是由于西方意识形态逐渐改进，有意识在制度上支持女性工作，所以西方社会女性就业曲线逐渐转化为“倒U型”——即婚育后也不会脱离职场。而日本由于本土意识形态以及高速压缩资本主义国家现代化历程在社会性别分工方面与欧美出现很大偏差。\n\n- 战后日本经济高速发展，也有越来越多的年轻劳动力涌入市场。前期女性劳动者也迅速增长，但是女性劳动者多为临时工或短期工，政策上没有推进女性持续就业导致大部分女性都回归到了家庭。为了使得充分有效利用劳动人员，日本在政策上支持男性全身心投入工作，而支持妇女回归家庭。196X年颁布法律鼓励妇女回归家庭，在经济层面上回归家庭的妇女会给家庭带来很大的经济补贴（免额度税务，添加年度工资补贴等使得女性回归家庭后能为家庭带来每年70万日元左右的金额），让西方社会的“去妇女回归家庭化”现象并没有出现，反而加重或者是固化了妇女回归家庭的现状。另外男女同工不同酬的情况持续到了1986年，即使在该年之后依旧在占据人们经济来源很大一部分的奖金层面上女性普遍也只有男性的1/2-2/3。日本女性M型就业曲线直到2009年都没有实质性的改变，直到现在依旧是M型曲线形式。\n\n- 在教育层面上，日本保留并支持大量女子学校的开办，大部分女子学校依旧以明治维新时期“贤妻良母”的思想为教育女性的方针，比如有名的双叶学校（出过很多名人以及名人的妻子，出过两代皇后）的校训依旧是百年前的“天真无邪，行事踏实”。鼓励性别差异教育，从婴儿阶段就对男女性别准备不同色彩的服饰和生活用品。这样的教育方针导致日本的性别分工意识形态发展比较缓慢，直到2002年的统计数据才第一次出现人们反对“男主外，女主内”思想人数高于赞成的人（但是后面2012年的统计数据出现回返现象），而最近（2019年）的统计数据显示日本赞成该思想的人数依旧还有1/3。\n\n- 日本的女性地位其实和日本的女性主义进展没有直接的关系。由于战后支持的民主自由的主调思想让学术上的研究得以支持和发展。所以日本有许多开设女性主义相关的课程。但是在社会女性地位上却不容乐观。日本女性研究专家将1970年-1975年视为女性解放阶段，将1976-1985年称为女性主义阶段。其中因为1975年国际妇人年对日本的影响-到1985年国际妇人年结束，加上上世纪八十年代日本经历泡沫经济时代，日本被迫进行改革，传统的夫妻分工形式受到了动摇。越来越多人在性别问题上有了更加先进的意识形态。但是日本一直都面临着意识形态和社会现状错位的问题，即使在2002年多数人反对“男主外，女主内”思想，社会情况却不容乐观且难以改变。\n\n- 2010年安倍内阁提出“女性经济学”，想要支持女性在市场职场上的发展，最后政策实行结构也没有太大的改变。因为其根本问题是社会层面，意识形态的问题，但是安倍提出的却是经济方针，女性就业困难问题依旧没有得到乐观的改善。\n\n日本女性史是一个需要深入探索和研究的学科，而我只用了一周零零散散的时间寻找国内论文进行了整理，既没有找过日本学者的相关论文也没有系统阅读过哪本相关研究的书籍。而且这一个姑且能够用时间线串联起来的简简简史也是阅读了一堆杂乱的无序的论文后拼凑起来的“别人的言论”。但是在阅读和整理过程中还是有很大收货的，也对这个和我们有很大渊源的邻国有了更深的了解。以前就很喜欢日本，喜欢日本动画，日本电影，日本文学，即使去年读了《菊与刀》对日本很下头了一阵子后还是重新拾回对日本的好感。这一次的研究到没有下头，是更了解日本了，比起读《菊与刀》产生的因陌生导致的误解有了更多的理解和同理心。现在觉得，日本真是一个复杂的国家，但是哪个国家不是呢？\n","slug":"日本女性简简简史笔记","published":1,"updated":"2022-01-24T08:27:51.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh2a001n6wtv3bel5u8j","content":"<p><em>”元始，女性是太阳，一个真正的人。 如今，女性是月亮，仰赖他人而存在， 依靠他人的亮光而发光， 是宛若病人的苍白月亮。“——《青鞜》</em></p>\n<h1 id=\"原始社会中日本女性地位\"><a href=\"#原始社会中日本女性地位\" class=\"headerlink\" title=\"原始社会中日本女性地位\"></a>原始社会中日本女性地位</h1><p>原始日本社会为母系社会，据记载伊邪那岐命生下三子，其中以女性的天照大神奉为权力至高的神明，象征和代表着太阳。直到弥生时代（公元前300年-公元后300年），这个时段社会逐渐由母权社会慢慢转向父权社会，但依旧有很多女性领袖人物，女性领主（还有一个小故事：一个女皇去世了她的儿子继位但是造成了动乱，后她的女儿继位才平息了动乱）。这个时代的婚姻制度也比较开发，虽然社会已经逐步转向父系社会，但在家庭和婚姻的层面上依旧保留着浓烈的母权色彩，女性依旧占据主导地位，婚姻多为群婚制度，男女双方的自由度很高，可以说是多妻多夫。</p>\n<h1 id=\"古代社会中日本女性地位变化\"><a href=\"#古代社会中日本女性地位变化\" class=\"headerlink\" title=\"古代社会中日本女性地位变化\"></a>古代社会中日本女性地位变化</h1><ul>\n<li><p>飞鸟时代（公元592-公元710）这个时间段一共出现了5位女天皇，男皇执政时间只有14年。奈良时代（公元711-公元794）这个阶段7位天皇中也有4位是女皇。这个时段依旧在社会上是父系社会，出现这么多女皇的原因之一是大多数女皇都是男天皇的皇后，而皇后都是从男皇同父异母的姐妹中选出来的，日本古代向来认为血缘连接是母方血液的连接，而只禁止母系通婚不禁止父系通婚。所以会认为本就是同一氏族的女儿也有继承权，而且这一阶段皇后的权力和皇太子权力同等，天皇逝世权力则优先传于皇后。</p>\n</li>\n<li><p>平安时代（公元794-公元1192），女性文学大量涌现，如《源氏物语》《枕草子》都为平安时代女性文学，并且由于贵族女性写作习惯出现了“女手”，就是现今日本的公用文字平假名。弥生时代到平安时代，日本流行的婚姻制度为访妻制，访妻制为男女双方互通情愫后，男方就可以在晚上去女方家，第二天早上就得离开的形式，社会层面上是以父系氏族为主的父权社会，但是家庭层面上却是母系连接，社会层面上是一夫多妻制，但是女方其实为婚姻的主体，女方自由度高，女性亦可在有婚姻关系时与其他男性接触相处，若男方不再访问女方也就很自然解除婚姻关系，这个时段婚姻的主导权多在女方母亲手里。夫妻双方实际为疏离关系，即使结婚也不是一家人，女方生下的孩子虽然和男方姓，但是由女方抚养和教育，属于女方家庭成员而不属于男方家庭成员，也不会认为同父异母的姐妹兄弟和自己有亲属关系，只有母方亲属才被认为有血液的亲属关系。在这样强烈母权色彩的婚姻制度下，女性在家庭的地位极高，女性有完整的继承权，家庭财产也是优先传给女性。（感觉这个时段男人只是生育工具）</p>\n</li>\n<li><p>平安时代中后期逐渐出现了招婿制，这是家庭层面上逐渐从母系转向父系的过度时期，这个时期婚姻前后很长一段时间男方需要居住在女方家中，直到女方认为时机成熟再搬到男方家中居住，招婿制度的婚姻主导权逐渐转向女方父亲。平安时期以后婚姻制度就变为现在的嫁娶制，婚姻主导权转为男方父亲，女性逐渐转为客体的地位。</p>\n</li>\n<li><p>平安时代之后也就是镰仓时代，随着幕府建立，武士阶层的固化，以及中国朱子儒学中女子三从四德思想在武士阶层的影响，女性开始被严重规训和束缚。“家庭制”的巩固，社会上的男权到家庭上的父权，无论是婚姻上还是身体思想上女性都被束缚，女性文学也淹没了很长一段时间，但即使是这个时候，女性在日本的地位依旧比其他儒学影响社会要高出很多，由于传统崇拜女性习俗的影响，在非武士阶层女性依旧有着相对多和大的权力，许多村落女性依旧有参政权，女性也有家庭财产继承权，若家庭无长子其财产则会顺位继承给长女。</p>\n</li>\n</ul>\n<h1 id=\"明治时代日本女性地位变化\"><a href=\"#明治时代日本女性地位变化\" class=\"headerlink\" title=\"明治时代日本女性地位变化\"></a>明治时代日本女性地位变化</h1><p>明治时代（1868-1911），受到西方民主思想的影响，日本社会进行了很大的变革（明治维新），逐步走向近代化民主国家，但是日本的变革是“先天不足”的——因为天皇制的保留让很多变革趋于形式，出现很多矛盾，其中女性问题特别尖锐。</p>\n<ul>\n<li><p>明治初期一些近代思想家受到西方思想影响猛烈抨击了传统的性别价值观，提出男女平权言论。女性开始获得”身体“上的自由，开始从”家庭制度“的束缚中解放出来。</p>\n</li>\n<li><p>明治中期，受到西方“天赋人权”影响出现了自由民权运动——日本最大规模的国民政治运动，女性解放运动也由此进入发轫期。该阶段多为妇女运动家积极开展抗议和组织运动，1880年成功获得女户主参政权、她们有人积极开展女性教育、女性参政等运动，拉开了日本妇女解放运动的序幕。</p>\n</li>\n<li><p>明治后期，由于民权运动直接威胁到明治政府的统治，政府开始放弃文明开化的道路转而强调日本传统意识形态。其中做出了三种政策来限制妇女的权力：1890年推出法律废除妇女参政权；1898年《民法》强调宗法家庭制，强调男户主和嫡长子的权利，对女性的权利做出极大打压，她们甚至无权处理家庭财产；一方面为了富国强兵不断加强女性教育，另一方面又极力给女性灌输“贤妻良母”的教育，企图将女性打造为优质的没有主体意识的生育工具。该年《民法》中还明确规定妻随夫姓的条规，近代以前并没有这样的传统，进一步让女性堕入社会边缘。</p>\n</li>\n<li><p>面对政府强力打压女性运动，妇女只能将运动的中心转向文学，此时出现了许多文学作品来宣传自由民主以及权利解放意识，这个阶段的代表人物谢野晶子受到西方民主和浪漫主义思想影响发表的《乱发》讽刺了官僚和政府震惊整个日本文坛，促进了日本知识女性的自我觉醒。</p>\n</li>\n</ul>\n<p>在明治时期出现了三个杰出的女权运动代表家，她们的开始是热烈和高涨的，结局确实低迷的妥协的。她们前期积极争取女性选举权、教育权等权益，后来却被打压到社会边缘。一个转身家庭只能靠纸笔论述女性问题，一个饱受牢狱之灾却转身反思自己和转变观念，而另一个也是迫于婚姻家庭只能克制自己的表达欲望。</p>\n<p>明治维新时期，虽然政府大力提倡女子受教育，也大力提高了女子入学率，但是那时想要培养的是“贤妻良母”的女子，明治维新初期的教育起初是模仿西方女性教育课程的，极大的和女子教育课程相似，家政课只占极少内容，直到自由民权运动极大威胁到了政府，政府放弃了西化的模仿，选择加强传统意识形态，又意识到女子必须受教育才能富强国家，所以极力灌输女子的教育是有非常强烈传统意识、家庭意识、民族意识的教育。</p>\n<h1 id=\"明治时代之后到今天\"><a href=\"#明治时代之后到今天\" class=\"headerlink\" title=\"明治时代之后到今天\"></a>明治时代之后到今天</h1><ul>\n<li><p>青鞜社的建立。1911年6月建立了日本第一个全部由女性组成的社团组织，发表杂志《青鞜》，在日本史上第一次出现了“新女性”，前后聚拢了许多日本女性革命家，发表的《女性原本是太阳》就像是一份“女性解放宣言”深深影响了整个文坛，是千百年来日本女性发出的第一声有份量的呐喊，她们吸取了西方女权运动的经验而转以文学实践形式出金女性觉醒，青鞜社的成立正式揭开女性解放运动的序幕。（1916年就被解散）</p>\n</li>\n<li><p>进入大正时代的日本加速进入军国主义阶段，为了配合侵略运动，日本政府在原来的“贤妻良母”形式女性教育下添加了更多的民族主义色彩，他们打造“军国之母”的形象来宣言和赞扬那些有民族主义精神，积极送自己的丈夫和儿子进入战场，并且能够积极生育来增长国家人口的女性形象。在此期间，也有少部分女性积极开展女性解放运动，都被政府无情打压。</p>\n</li>\n<li><p>二战日本战败后受到联合国的管制，美方向日本提出的五大改革之一的第一条就是解放妇女。从此妇女拥有了选举权、参政权、婚姻家庭上也和男方拥有一样的权力，在法律上实现了初步男女平等。</p>\n</li>\n<li><p>联合国的七年管制后日本政府重新掌握国家主权，战后资本主义国家经济高速发展，无论是西方还是日本都出现了“主妇回归潮”——战后第一产业高速发展需要更多的体力劳动，女性开始回归家庭。这个阶段东西方资本主义国家的妇女就业都成M型趋势——婚育前女性参加工作，婚育后暂时回归家庭，待孩子长大到一定岁数后再次回归职场。但是由于西方意识形态逐渐改进，有意识在制度上支持女性工作，所以西方社会女性就业曲线逐渐转化为“倒U型”——即婚育后也不会脱离职场。而日本由于本土意识形态以及高速压缩资本主义国家现代化历程在社会性别分工方面与欧美出现很大偏差。</p>\n</li>\n<li><p>战后日本经济高速发展，也有越来越多的年轻劳动力涌入市场。前期女性劳动者也迅速增长，但是女性劳动者多为临时工或短期工，政策上没有推进女性持续就业导致大部分女性都回归到了家庭。为了使得充分有效利用劳动人员，日本在政策上支持男性全身心投入工作，而支持妇女回归家庭。196X年颁布法律鼓励妇女回归家庭，在经济层面上回归家庭的妇女会给家庭带来很大的经济补贴（免额度税务，添加年度工资补贴等使得女性回归家庭后能为家庭带来每年70万日元左右的金额），让西方社会的“去妇女回归家庭化”现象并没有出现，反而加重或者是固化了妇女回归家庭的现状。另外男女同工不同酬的情况持续到了1986年，即使在该年之后依旧在占据人们经济来源很大一部分的奖金层面上女性普遍也只有男性的1/2-2/3。日本女性M型就业曲线直到2009年都没有实质性的改变，直到现在依旧是M型曲线形式。</p>\n</li>\n<li><p>在教育层面上，日本保留并支持大量女子学校的开办，大部分女子学校依旧以明治维新时期“贤妻良母”的思想为教育女性的方针，比如有名的双叶学校（出过很多名人以及名人的妻子，出过两代皇后）的校训依旧是百年前的“天真无邪，行事踏实”。鼓励性别差异教育，从婴儿阶段就对男女性别准备不同色彩的服饰和生活用品。这样的教育方针导致日本的性别分工意识形态发展比较缓慢，直到2002年的统计数据才第一次出现人们反对“男主外，女主内”思想人数高于赞成的人（但是后面2012年的统计数据出现回返现象），而最近（2019年）的统计数据显示日本赞成该思想的人数依旧还有1/3。</p>\n</li>\n<li><p>日本的女性地位其实和日本的女性主义进展没有直接的关系。由于战后支持的民主自由的主调思想让学术上的研究得以支持和发展。所以日本有许多开设女性主义相关的课程。但是在社会女性地位上却不容乐观。日本女性研究专家将1970年-1975年视为女性解放阶段，将1976-1985年称为女性主义阶段。其中因为1975年国际妇人年对日本的影响-到1985年国际妇人年结束，加上上世纪八十年代日本经历泡沫经济时代，日本被迫进行改革，传统的夫妻分工形式受到了动摇。越来越多人在性别问题上有了更加先进的意识形态。但是日本一直都面临着意识形态和社会现状错位的问题，即使在2002年多数人反对“男主外，女主内”思想，社会情况却不容乐观且难以改变。</p>\n</li>\n<li><p>2010年安倍内阁提出“女性经济学”，想要支持女性在市场职场上的发展，最后政策实行结构也没有太大的改变。因为其根本问题是社会层面，意识形态的问题，但是安倍提出的却是经济方针，女性就业困难问题依旧没有得到乐观的改善。</p>\n</li>\n</ul>\n<p>日本女性史是一个需要深入探索和研究的学科，而我只用了一周零零散散的时间寻找国内论文进行了整理，既没有找过日本学者的相关论文也没有系统阅读过哪本相关研究的书籍。而且这一个姑且能够用时间线串联起来的简简简史也是阅读了一堆杂乱的无序的论文后拼凑起来的“别人的言论”。但是在阅读和整理过程中还是有很大收货的，也对这个和我们有很大渊源的邻国有了更深的了解。以前就很喜欢日本，喜欢日本动画，日本电影，日本文学，即使去年读了《菊与刀》对日本很下头了一阵子后还是重新拾回对日本的好感。这一次的研究到没有下头，是更了解日本了，比起读《菊与刀》产生的因陌生导致的误解有了更多的理解和同理心。现在觉得，日本真是一个复杂的国家，但是哪个国家不是呢？</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<p><em>”元始，女性是太阳，一个真正的人。 如今，女性是月亮，仰赖他人而存在， 依靠他人的亮光而发光， 是宛若病人的苍白月亮。“——《青鞜》</em></p>\n<h1 id=\"原始社会中日本女性地位\"><a href=\"#原始社会中日本女性地位\" class=\"headerlink\" title=\"原始社会中日本女性地位\"></a>原始社会中日本女性地位</h1><p>原始日本社会为母系社会，据记载伊邪那岐命生下三子，其中以女性的天照大神奉为权力至高的神明，象征和代表着太阳。直到弥生时代（公元前300年-公元后300年），这个时段社会逐渐由母权社会慢慢转向父权社会，但依旧有很多女性领袖人物，女性领主（还有一个小故事：一个女皇去世了她的儿子继位但是造成了动乱，后她的女儿继位才平息了动乱）。这个时代的婚姻制度也比较开发，虽然社会已经逐步转向父系社会，但在家庭和婚姻的层面上依旧保留着浓烈的母权色彩，女性依旧占据主导地位，婚姻多为群婚制度，男女双方的自由度很高，可以说是多妻多夫。</p>\n<h1 id=\"古代社会中日本女性地位变化\"><a href=\"#古代社会中日本女性地位变化\" class=\"headerlink\" title=\"古代社会中日本女性地位变化\"></a>古代社会中日本女性地位变化</h1><ul>\n<li><p>飞鸟时代（公元592-公元710）这个时间段一共出现了5位女天皇，男皇执政时间只有14年。奈良时代（公元711-公元794）这个阶段7位天皇中也有4位是女皇。这个时段依旧在社会上是父系社会，出现这么多女皇的原因之一是大多数女皇都是男天皇的皇后，而皇后都是从男皇同父异母的姐妹中选出来的，日本古代向来认为血缘连接是母方血液的连接，而只禁止母系通婚不禁止父系通婚。所以会认为本就是同一氏族的女儿也有继承权，而且这一阶段皇后的权力和皇太子权力同等，天皇逝世权力则优先传于皇后。</p>\n</li>\n<li><p>平安时代（公元794-公元1192），女性文学大量涌现，如《源氏物语》《枕草子》都为平安时代女性文学，并且由于贵族女性写作习惯出现了“女手”，就是现今日本的公用文字平假名。弥生时代到平安时代，日本流行的婚姻制度为访妻制，访妻制为男女双方互通情愫后，男方就可以在晚上去女方家，第二天早上就得离开的形式，社会层面上是以父系氏族为主的父权社会，但是家庭层面上却是母系连接，社会层面上是一夫多妻制，但是女方其实为婚姻的主体，女方自由度高，女性亦可在有婚姻关系时与其他男性接触相处，若男方不再访问女方也就很自然解除婚姻关系，这个时段婚姻的主导权多在女方母亲手里。夫妻双方实际为疏离关系，即使结婚也不是一家人，女方生下的孩子虽然和男方姓，但是由女方抚养和教育，属于女方家庭成员而不属于男方家庭成员，也不会认为同父异母的姐妹兄弟和自己有亲属关系，只有母方亲属才被认为有血液的亲属关系。在这样强烈母权色彩的婚姻制度下，女性在家庭的地位极高，女性有完整的继承权，家庭财产也是优先传给女性。（感觉这个时段男人只是生育工具）</p>\n</li>\n<li><p>平安时代中后期逐渐出现了招婿制，这是家庭层面上逐渐从母系转向父系的过度时期，这个时期婚姻前后很长一段时间男方需要居住在女方家中，直到女方认为时机成熟再搬到男方家中居住，招婿制度的婚姻主导权逐渐转向女方父亲。平安时期以后婚姻制度就变为现在的嫁娶制，婚姻主导权转为男方父亲，女性逐渐转为客体的地位。</p>\n</li>\n<li><p>平安时代之后也就是镰仓时代，随着幕府建立，武士阶层的固化，以及中国朱子儒学中女子三从四德思想在武士阶层的影响，女性开始被严重规训和束缚。“家庭制”的巩固，社会上的男权到家庭上的父权，无论是婚姻上还是身体思想上女性都被束缚，女性文学也淹没了很长一段时间，但即使是这个时候，女性在日本的地位依旧比其他儒学影响社会要高出很多，由于传统崇拜女性习俗的影响，在非武士阶层女性依旧有着相对多和大的权力，许多村落女性依旧有参政权，女性也有家庭财产继承权，若家庭无长子其财产则会顺位继承给长女。</p>\n</li>\n</ul>\n<h1 id=\"明治时代日本女性地位变化\"><a href=\"#明治时代日本女性地位变化\" class=\"headerlink\" title=\"明治时代日本女性地位变化\"></a>明治时代日本女性地位变化</h1><p>明治时代（1868-1911），受到西方民主思想的影响，日本社会进行了很大的变革（明治维新），逐步走向近代化民主国家，但是日本的变革是“先天不足”的——因为天皇制的保留让很多变革趋于形式，出现很多矛盾，其中女性问题特别尖锐。</p>\n<ul>\n<li><p>明治初期一些近代思想家受到西方思想影响猛烈抨击了传统的性别价值观，提出男女平权言论。女性开始获得”身体“上的自由，开始从”家庭制度“的束缚中解放出来。</p>\n</li>\n<li><p>明治中期，受到西方“天赋人权”影响出现了自由民权运动——日本最大规模的国民政治运动，女性解放运动也由此进入发轫期。该阶段多为妇女运动家积极开展抗议和组织运动，1880年成功获得女户主参政权、她们有人积极开展女性教育、女性参政等运动，拉开了日本妇女解放运动的序幕。</p>\n</li>\n<li><p>明治后期，由于民权运动直接威胁到明治政府的统治，政府开始放弃文明开化的道路转而强调日本传统意识形态。其中做出了三种政策来限制妇女的权力：1890年推出法律废除妇女参政权；1898年《民法》强调宗法家庭制，强调男户主和嫡长子的权利，对女性的权利做出极大打压，她们甚至无权处理家庭财产；一方面为了富国强兵不断加强女性教育，另一方面又极力给女性灌输“贤妻良母”的教育，企图将女性打造为优质的没有主体意识的生育工具。该年《民法》中还明确规定妻随夫姓的条规，近代以前并没有这样的传统，进一步让女性堕入社会边缘。</p>\n</li>\n<li><p>面对政府强力打压女性运动，妇女只能将运动的中心转向文学，此时出现了许多文学作品来宣传自由民主以及权利解放意识，这个阶段的代表人物谢野晶子受到西方民主和浪漫主义思想影响发表的《乱发》讽刺了官僚和政府震惊整个日本文坛，促进了日本知识女性的自我觉醒。</p>\n</li>\n</ul>\n<p>在明治时期出现了三个杰出的女权运动代表家，她们的开始是热烈和高涨的，结局确实低迷的妥协的。她们前期积极争取女性选举权、教育权等权益，后来却被打压到社会边缘。一个转身家庭只能靠纸笔论述女性问题，一个饱受牢狱之灾却转身反思自己和转变观念，而另一个也是迫于婚姻家庭只能克制自己的表达欲望。</p>\n<p>明治维新时期，虽然政府大力提倡女子受教育，也大力提高了女子入学率，但是那时想要培养的是“贤妻良母”的女子，明治维新初期的教育起初是模仿西方女性教育课程的，极大的和女子教育课程相似，家政课只占极少内容，直到自由民权运动极大威胁到了政府，政府放弃了西化的模仿，选择加强传统意识形态，又意识到女子必须受教育才能富强国家，所以极力灌输女子的教育是有非常强烈传统意识、家庭意识、民族意识的教育。</p>\n<h1 id=\"明治时代之后到今天\"><a href=\"#明治时代之后到今天\" class=\"headerlink\" title=\"明治时代之后到今天\"></a>明治时代之后到今天</h1><ul>\n<li><p>青鞜社的建立。1911年6月建立了日本第一个全部由女性组成的社团组织，发表杂志《青鞜》，在日本史上第一次出现了“新女性”，前后聚拢了许多日本女性革命家，发表的《女性原本是太阳》就像是一份“女性解放宣言”深深影响了整个文坛，是千百年来日本女性发出的第一声有份量的呐喊，她们吸取了西方女权运动的经验而转以文学实践形式出金女性觉醒，青鞜社的成立正式揭开女性解放运动的序幕。（1916年就被解散）</p>\n</li>\n<li><p>进入大正时代的日本加速进入军国主义阶段，为了配合侵略运动，日本政府在原来的“贤妻良母”形式女性教育下添加了更多的民族主义色彩，他们打造“军国之母”的形象来宣言和赞扬那些有民族主义精神，积极送自己的丈夫和儿子进入战场，并且能够积极生育来增长国家人口的女性形象。在此期间，也有少部分女性积极开展女性解放运动，都被政府无情打压。</p>\n</li>\n<li><p>二战日本战败后受到联合国的管制，美方向日本提出的五大改革之一的第一条就是解放妇女。从此妇女拥有了选举权、参政权、婚姻家庭上也和男方拥有一样的权力，在法律上实现了初步男女平等。</p>\n</li>\n<li><p>联合国的七年管制后日本政府重新掌握国家主权，战后资本主义国家经济高速发展，无论是西方还是日本都出现了“主妇回归潮”——战后第一产业高速发展需要更多的体力劳动，女性开始回归家庭。这个阶段东西方资本主义国家的妇女就业都成M型趋势——婚育前女性参加工作，婚育后暂时回归家庭，待孩子长大到一定岁数后再次回归职场。但是由于西方意识形态逐渐改进，有意识在制度上支持女性工作，所以西方社会女性就业曲线逐渐转化为“倒U型”——即婚育后也不会脱离职场。而日本由于本土意识形态以及高速压缩资本主义国家现代化历程在社会性别分工方面与欧美出现很大偏差。</p>\n</li>\n<li><p>战后日本经济高速发展，也有越来越多的年轻劳动力涌入市场。前期女性劳动者也迅速增长，但是女性劳动者多为临时工或短期工，政策上没有推进女性持续就业导致大部分女性都回归到了家庭。为了使得充分有效利用劳动人员，日本在政策上支持男性全身心投入工作，而支持妇女回归家庭。196X年颁布法律鼓励妇女回归家庭，在经济层面上回归家庭的妇女会给家庭带来很大的经济补贴（免额度税务，添加年度工资补贴等使得女性回归家庭后能为家庭带来每年70万日元左右的金额），让西方社会的“去妇女回归家庭化”现象并没有出现，反而加重或者是固化了妇女回归家庭的现状。另外男女同工不同酬的情况持续到了1986年，即使在该年之后依旧在占据人们经济来源很大一部分的奖金层面上女性普遍也只有男性的1/2-2/3。日本女性M型就业曲线直到2009年都没有实质性的改变，直到现在依旧是M型曲线形式。</p>\n</li>\n<li><p>在教育层面上，日本保留并支持大量女子学校的开办，大部分女子学校依旧以明治维新时期“贤妻良母”的思想为教育女性的方针，比如有名的双叶学校（出过很多名人以及名人的妻子，出过两代皇后）的校训依旧是百年前的“天真无邪，行事踏实”。鼓励性别差异教育，从婴儿阶段就对男女性别准备不同色彩的服饰和生活用品。这样的教育方针导致日本的性别分工意识形态发展比较缓慢，直到2002年的统计数据才第一次出现人们反对“男主外，女主内”思想人数高于赞成的人（但是后面2012年的统计数据出现回返现象），而最近（2019年）的统计数据显示日本赞成该思想的人数依旧还有1/3。</p>\n</li>\n<li><p>日本的女性地位其实和日本的女性主义进展没有直接的关系。由于战后支持的民主自由的主调思想让学术上的研究得以支持和发展。所以日本有许多开设女性主义相关的课程。但是在社会女性地位上却不容乐观。日本女性研究专家将1970年-1975年视为女性解放阶段，将1976-1985年称为女性主义阶段。其中因为1975年国际妇人年对日本的影响-到1985年国际妇人年结束，加上上世纪八十年代日本经历泡沫经济时代，日本被迫进行改革，传统的夫妻分工形式受到了动摇。越来越多人在性别问题上有了更加先进的意识形态。但是日本一直都面临着意识形态和社会现状错位的问题，即使在2002年多数人反对“男主外，女主内”思想，社会情况却不容乐观且难以改变。</p>\n</li>\n<li><p>2010年安倍内阁提出“女性经济学”，想要支持女性在市场职场上的发展，最后政策实行结构也没有太大的改变。因为其根本问题是社会层面，意识形态的问题，但是安倍提出的却是经济方针，女性就业困难问题依旧没有得到乐观的改善。</p>\n</li>\n</ul>\n<p>日本女性史是一个需要深入探索和研究的学科，而我只用了一周零零散散的时间寻找国内论文进行了整理，既没有找过日本学者的相关论文也没有系统阅读过哪本相关研究的书籍。而且这一个姑且能够用时间线串联起来的简简简史也是阅读了一堆杂乱的无序的论文后拼凑起来的“别人的言论”。但是在阅读和整理过程中还是有很大收货的，也对这个和我们有很大渊源的邻国有了更深的了解。以前就很喜欢日本，喜欢日本动画，日本电影，日本文学，即使去年读了《菊与刀》对日本很下头了一阵子后还是重新拾回对日本的好感。这一次的研究到没有下头，是更了解日本了，比起读《菊与刀》产生的因陌生导致的误解有了更多的理解和同理心。现在觉得，日本真是一个复杂的国家，但是哪个国家不是呢？</p>\n"},{"title":"浏览器中的页面循环系统","date":"2022-01-24T06:57:20.000Z","_content":"\n---\n\n*本文来源于[http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程](http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82)[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。*\n\n---\n\n我们已经知道每个渲染进程都有一个主进程，它需要处理DOM、计算样式、处理布局以及处理JavaScript的各种任务，工作特别繁忙，那么这些任务是如何有条不紊地被主进程处理的呢？这就涉及到了浏览器的休息队列和事件循环系统。\n\n## 1.消息队列和事件循环\n\n### 1.1 单线程处理任务结构\n\n主线程会有一个事件处理的<u>消息队列</u>，那些需要执行的任务会逐个加入消息队列当中，按照先进先出的顺序被主线程去执行。\n\n但是主线程在运行过程中如何接收新的任务呢？这就涉及到了<u>事件循环机制</u>，在主线程中添加一个循环语句实时监听新任务的产生。\n\n不过在这样的结构下主线程处理的所有任务都是内部任务，而有一些IO任务比如接收键盘消息等外部任务又如何添加到渲染进程的主线程当中呢？IO任务是由<u>IO线程</u>来管理的，当IO线程接收到这些处理事件时会将其添加到主线程的消息队列中，这样渲染主线程就能接收这些外部任务了。\n\n在此基础上渲染进程还会经常接收其他进程的交互处理信息例如网络进程、浏览器进程的相关信息，这些进程产生的事件又是如何添加到渲染进程的消息队列中进行处理的呢？如下图所示，这些跨进程任务和渲染进程的IO线程进行沟通交互来进行任务的传送。\n\n![](/images/react/2022012401.png)\n\n当需要退出页面时，则会考虑到安全退出渲染进程主线程的问题，chrome会在主线程中设置一个<u>退出标志变量</u>，主线程每次执行完一个任务时都会判断退出标志是否有变化。如果有则会安全推出线程。\n\n### 1.2 该结构的缺点\n\n单线程以及先入先出的结构会产生两个问题。\n\n第一：<u>如何处理高优先级任务</u>。比方说DOM节点变化渲染就是个需要优先处理的任务，针对这个情况，<u>微任务</u>就诞生了。我们将消息队列中的任务称为宏任务，每个宏任务都有一个微任务队列。在主线程执行某个宏任务的过程中如果监听接收到哪些需要优先处理的任务，就会把这些任务添加到当前的微任务队列中，当当前的宏任务执行结束后就执行微任务队列中的所有微任务，再继续执行下一个宏任务。\n\n第二：<u>如何解决单个任务执行时长过久的情况</u>。因为是单线程执行，一次只能执行一个任务，当一个任务执行过久就会让人视觉上感受到页面卡顿的效果，针对这种情况，JavaScript采用<u>回调功能</u>来规避问题。\n\n### 1.3 浏览器中的页面\n\n可以再chrome的开发者工具中，点击“Performance\"标签来查看页面加载的事件执行情况，如下图所示。\n\n![](/images/react/2022012402.png)\n\n## 2.Webapi：setTimeout\n\nsetTimeout是一个<u>定时器</u>，用来指定某个函数在多少毫秒之后执行，它会返回一个整数来表示定时器的编号，利用该编号可以取消定时器。以下为使用代码。\n\n```\nfunction showName(){\n  console.log(\" 极客时间 \")\n}\nvar timerID = setTimeout(showName,200);\n```\n\n### 2.1 setTimeout的实现\n\n定时器的作用就是为了在指定时间内执行某任务，如果将定时器放在普通的消息队列中，有可能在执行该定时器时就已经超过了任务时长。为了解决该问题，JavaScript又引入了<u>延迟队列机制</u>。\n\n当JavaScript创建一个定时器时，渲染经常会将该定时器的回调任务添加到延迟队列当中，其中包括回调任务函数名称、发起时间、延迟执行时间。在主线程中每当处理完一个宏任务就会去执行延迟队列当中那些已经到期的任务。\n\n### 2.2 使用setTimeout的注意事项\n\n<u>如果当前任务执行时间过久，会影响延迟到期任务执行。</u>因为每次执行延迟队列中的任务都是在执行完一个宏任务之后的事情，如果该宏任务占用太多时间也有可能超过延迟队列中的任务定时时间。\n\n<u>如果setTimeout存在嵌套调用，那么系统会设置最短时间为4ms 。</u>当setTimeout的嵌套函数调用超过5次以上，后面每次调用的最小时间间隔为4ms 。所以一些实时性较高的需求不太适合使用setTime。比如JavaScript动画。\n\n<u>延迟执行时间有最大值。</u>定时器的执行延迟时间的最大值一般都为2147483647ms (大约24.8天，根据浏览器而异)，如果超出该值则会溢出，所以延迟时间的取值不能超过该值。\n\n使用setTimeout设置的回调函数中的this不符合直觉。\n\n比如以下这段代码的this就是指向全局，输出为1 。\n\n```\nvar name= 1;\nvar MyObj = {\n  name: 2,\n  showName: function(){\n    console.log(this.name);\n  }\n}\nsetTimeout(MyObj.showName,1000)\n```\n\n## 3.Webapi : XMLHttpRequest\n\nXMLHttpRequest这个api的引入使得更新网络数据时无需刷新整张页面而直接操作DOM来更新页面内容。在深入理解XMLHttpRequest之前先理解<u>同步回调</u>和<u>异步回调</u>两个概念。\n\n### 3.1 回调函数VS系统调用栈\n\n将一个函数作为参数传递给另一个函数，那么作为参数的这个函数就是回调函数（其他情况也可以是回调函数，不一定必须是参数）。回调函数分为同步回调和异步回调，同步回调函数是指在主函数返回之前执行的函数，异步回调则是在主函数外部执行的回调函数，如下代码所示。\n\n```\n//同步回调\nlet callback = function(){\n    console.log('i am do homework')\n}\nfunction doWork(cb) {\n    console.log('start do work')\n    cb()\n    console.log('end do work')\n}\ndoWork(callback)\n\n//异步回调\nlet callback = function(){\n    console.log('i am do homework')\n}\nfunction doWork(cb) {\n    console.log('start do work')\n    setTimeout(cb,1000)   \n    console.log('end do work')\n}\ndoWork(callback)\n//异步回调\n```\n\n在页面的事件循环系统中，每一个消息队列中的任务都有一个系统调用栈，这个类似于JavaScript的调用栈，在当前任务被执行的过程中，同步回调就是在当前主函数的上下文中执行回调函数。异步回调会有两种处理方式：第一种是将异步函数做成一个任务添加到信息队列尾部；2.第二种是异步函数添加到维任务队列中，就可以在当前任务的末尾执行微任务。\n\n### 3.2 XMLHttpRequest运行机制\n\n首先通过以下图片可以了解XMLHttpRequest的实行机制。\n\n![](/images/react/2022012403.png)\n\n先从 XMLHttpRequest 的用法开始，首先看下面这样一段请求代码：\n\n```\n function GetWebData(URL){\n    /**\n     * 1: 新建 XMLHttpRequest 请求对象\n     */\n    let xhr = new XMLHttpRequest()\n\n    /**\n     * 2: 注册相关事件回调处理函数 \n     */\n    xhr.onreadystatechange = function () {\n        switch(xhr.readyState){\n          case 0: // 请求未初始化\n            console.log(\" 请求未初始化 \")\n            break;\n          case 1://OPENED\n            console.log(\"OPENED\")\n            break;\n          case 2://HEADERS_RECEIVED\n            console.log(\"HEADERS_RECEIVED\")\n            break;\n          case 3://LOADING  \n            console.log(\"LOADING\")\n            break;\n          case 4://DONE\n            if(this.status == 200||this.status == 304){\n                console.log(this.responseText);\n                }\n            console.log(\"DONE\")\n            break;\n        }\n    }\n\n    xhr.ontimeout = function(e) { console.log('ontimeout') }\n    xhr.onerror = function(e) { console.log('onerror') }\n\n    /**\n     * 3: 打开请求\n     */\n    xhr.open('Get', URL, true);// 创建一个 Get 请求, 采用异步\n\n\n    /**\n     * 4: 配置参数\n     */\n    xhr.timeout = 3000 // 设置 xhr 请求的超时时间\n    xhr.responseType = \"text\" // 设置响应返回的数据格式\n    xhr.setRequestHeader(\"X_TEST\",\"time.geekbang\")\n\n    /**\n     * 5: 发送请求\n     */\n    xhr.send();\n}\n```\n\n在封装请求时的第一步，创建XMLHttpRequest对象，第二步为xhr对象注册回调函数，第三步配置基础的请求信息，第四步发起请求。\n\n### 3.3 XMLHttpRequest使用过程中的”坑“\n\n**跨域问题**：默认情况下，跨域请求是不被允许的。\n\n**HTTPS混合内容问题**：HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。通常，如果 HTTPS 请求页面中使用混合内容，浏览器会针对 HTTPS 混合内容显示警告，用来向用户表明此 HTTPS 页面包含不安全的资源。\n\n## 4.宏任务与微任务\n\n### 4.1 宏任务\n\n页面中大部分任务都是在渲染进程的主线程上执行的，包括渲染事件（解析DOM、计算布局、绘制），用户交互事件、JavaScript脚本执行事件，网络请求完成，文件读写完成事件等。为了让这些任务有条不紊在主线程上执行而引入了消息队列和事件循环机制，在消息队列中的任务就是宏任务。\n\n### 4.2 微任务\n\n微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前。有两种方式可以创造微任务，分别是使用<u>MutationObserver</u>以及使用<u>Promise</u>。从V8引擎上分析，在执行一段JavaScript任务时JavaScript引擎会创建一个全局执行上下文，这个执行上下文中就包括微任务队列，在该JavaScript脚本执行结束前即即将销毁其执行上下文时会先检测其为任务队列，直到为任务队列彻底没有内容后才会销毁。\n\n### 4.3 监听DOM变化方法演变\n\n监听DOM变化是前端工程师一项非常核心的需求。一开始监听DOM的变化是设置<u>setTimeout或者setInterval</u>来定时检测DOM是否有变化，这个问题会有事件间隔长短以及资源消耗等问题，2000年的时候引入了<u>Mutation Event</u>，这个方法采用观察者设计模式，当DOM有变动时就会立刻触发相应的事件，采用的方法是同步回调。但是Mutation Event让每一次DOM发送变化要立刻调用JavaScript接口，这种实时性造成严重的性能问题，为了解决其同步回调产生的性能问题而引入了<u>MutionObserver</u>。它采用”异步+微任务“的策列来解决这些问题。\n\n## 5.Promise和async await\n\n### 5.1 异步编码问题\n\nPromise解决了异步编码风格的问题。看普通的异步回调情况，如下代码所示。\n\n```\n// 执行状态\nfunction onResolve(response){console.log(response) }\nfunction onReject(error){console.log(error) }\n\nlet xhr = new XMLHttpRequest()\nxhr.ontimeout = function(e) { onReject(e)}\nxhr.onerror = function(e) { onReject(e) }\nxhr.onreadystatechange = function () { onResolve(xhr.response) }\n\n// 设置请求类型，请求 URL，是否同步信息\nlet URL = 'https://time.geekbang.com'\nxhr.open('Get', URL, true);\n\n// 设置参数\nxhr.timeout = 3000 // 设置 xhr 请求的超时时间\nxhr.responseType = \"text\" // 设置响应返回的数据格式\nxhr.setRequestHeader(\"X_TEST\",\"time.geekbang\")\n\n// 发出请求\nxhr.send();\n```\n\n这一个网络请求多次使用了异步回调，使得代码逻辑显得不连贯和不线性。所以可以封装该请求使得符合我们的观看直觉。但即使封装之后也会出现低于回调的问题，这使得代码陷入一个非常混乱的局面，引入promise就可以很好解决低于回调的问题。（其实promise我也研究不是很透彻，包括后面的async await ，以后有时间仔细学习，这里就不细讲了）\n\n### 5.2 async await\n\n即使promise能够解决异步回调编码风格问题使其看起来更能理解，但是过多的<u>then方法</u>依旧似乎有着语义化不明显的问题，所以<u>ES7</u>引入了<u>async await</u>很好解决了这个问题。async await使得异步回掉函数的写法和同步回调几乎一样，视觉上一目了然非常简介。\n\nasync await其实背后的技术就是promise和生成器的应用。如下代码所示就是一个生成器的应用。\n\n```\nfunction* genDemo() {\n    console.log(\" 开始执行第一段 \")\n    yield 'generator 2'\n\n    console.log(\" 开始执行第二段 \")\n    yield 'generator 2'\n\n    console.log(\" 开始执行第三段 \")\n    yield 'generator 2'\n\n    console.log(\" 执行结束 \")\n    return 'generator 2'\n}\n\nconsole.log('main 0')\nlet gen = genDemo()\nconsole.log(gen.next().value)\nconsole.log('main 1')\nconsole.log(gen.next().value)\nconsole.log('main 2')\nconsole.log(gen.next().value)\nconsole.log('main 3')\nconsole.log(gen.next().value)\nconsole.log('main 4')\n```\n\n执行这个函数观察输出结果可以发现genDemo并不是一次执行完成的，全局代码和genDemo代码交易执行，这就是<u>生成器函</u>数的特性。\n\n这里就涉及到了<u>协程</u>的概念，我们已经知道进程和线程的概念，一个进程里有多个线程，相类似的一个线程里也有多个协程，并且同一时间只能执行一个协程。如果从A协程启动了B协程，那么我们就将A协程称为B协程的<u>父协程</u>。如上代码就是执行在一个线程内的程序，但是它有两个协程，全局的父协程以及genDemo所对应的子协程。他们的连接和应用关系如下图所示。\n\n![](/images/react/2022012404.png)\n\n我们可以知道：第一、在生成器函数内部执行一段代码，如果遇到<u> yield </u>关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。外部函数可以通过<u> next</u> 方法恢复函数的执行。\n\n我们必须知道一个线程中的协程是<u>交互执行</u>而不是并发执行的，它们的切换是通过yield和gen.next来配合完成的。另外，当gen协程中调用了yied方法时，JavaScript引擎就会保留gen协程当前的<u>调用栈</u>信息，并恢复父协程的调用栈信息；同样当父协程中执行gen.next时也会保留父协程的调用栈信息而恢复gen协程的调用栈信息，可以参考下图所示。\n\n![](/images/react/2022012405.png)\n","source":"_posts/浏览器中的页面循环系统.md","raw":"---\ntitle: 浏览器中的页面循环系统\ndate: 2022-01-24 14:57:20\ntags: [前端面试,浏览器]\ncategories:\n- 浏览器\n---\n\n---\n\n*本文来源于[http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程](http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82)[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。*\n\n---\n\n我们已经知道每个渲染进程都有一个主进程，它需要处理DOM、计算样式、处理布局以及处理JavaScript的各种任务，工作特别繁忙，那么这些任务是如何有条不紊地被主进程处理的呢？这就涉及到了浏览器的休息队列和事件循环系统。\n\n## 1.消息队列和事件循环\n\n### 1.1 单线程处理任务结构\n\n主线程会有一个事件处理的<u>消息队列</u>，那些需要执行的任务会逐个加入消息队列当中，按照先进先出的顺序被主线程去执行。\n\n但是主线程在运行过程中如何接收新的任务呢？这就涉及到了<u>事件循环机制</u>，在主线程中添加一个循环语句实时监听新任务的产生。\n\n不过在这样的结构下主线程处理的所有任务都是内部任务，而有一些IO任务比如接收键盘消息等外部任务又如何添加到渲染进程的主线程当中呢？IO任务是由<u>IO线程</u>来管理的，当IO线程接收到这些处理事件时会将其添加到主线程的消息队列中，这样渲染主线程就能接收这些外部任务了。\n\n在此基础上渲染进程还会经常接收其他进程的交互处理信息例如网络进程、浏览器进程的相关信息，这些进程产生的事件又是如何添加到渲染进程的消息队列中进行处理的呢？如下图所示，这些跨进程任务和渲染进程的IO线程进行沟通交互来进行任务的传送。\n\n![](/images/react/2022012401.png)\n\n当需要退出页面时，则会考虑到安全退出渲染进程主线程的问题，chrome会在主线程中设置一个<u>退出标志变量</u>，主线程每次执行完一个任务时都会判断退出标志是否有变化。如果有则会安全推出线程。\n\n### 1.2 该结构的缺点\n\n单线程以及先入先出的结构会产生两个问题。\n\n第一：<u>如何处理高优先级任务</u>。比方说DOM节点变化渲染就是个需要优先处理的任务，针对这个情况，<u>微任务</u>就诞生了。我们将消息队列中的任务称为宏任务，每个宏任务都有一个微任务队列。在主线程执行某个宏任务的过程中如果监听接收到哪些需要优先处理的任务，就会把这些任务添加到当前的微任务队列中，当当前的宏任务执行结束后就执行微任务队列中的所有微任务，再继续执行下一个宏任务。\n\n第二：<u>如何解决单个任务执行时长过久的情况</u>。因为是单线程执行，一次只能执行一个任务，当一个任务执行过久就会让人视觉上感受到页面卡顿的效果，针对这种情况，JavaScript采用<u>回调功能</u>来规避问题。\n\n### 1.3 浏览器中的页面\n\n可以再chrome的开发者工具中，点击“Performance\"标签来查看页面加载的事件执行情况，如下图所示。\n\n![](/images/react/2022012402.png)\n\n## 2.Webapi：setTimeout\n\nsetTimeout是一个<u>定时器</u>，用来指定某个函数在多少毫秒之后执行，它会返回一个整数来表示定时器的编号，利用该编号可以取消定时器。以下为使用代码。\n\n```\nfunction showName(){\n  console.log(\" 极客时间 \")\n}\nvar timerID = setTimeout(showName,200);\n```\n\n### 2.1 setTimeout的实现\n\n定时器的作用就是为了在指定时间内执行某任务，如果将定时器放在普通的消息队列中，有可能在执行该定时器时就已经超过了任务时长。为了解决该问题，JavaScript又引入了<u>延迟队列机制</u>。\n\n当JavaScript创建一个定时器时，渲染经常会将该定时器的回调任务添加到延迟队列当中，其中包括回调任务函数名称、发起时间、延迟执行时间。在主线程中每当处理完一个宏任务就会去执行延迟队列当中那些已经到期的任务。\n\n### 2.2 使用setTimeout的注意事项\n\n<u>如果当前任务执行时间过久，会影响延迟到期任务执行。</u>因为每次执行延迟队列中的任务都是在执行完一个宏任务之后的事情，如果该宏任务占用太多时间也有可能超过延迟队列中的任务定时时间。\n\n<u>如果setTimeout存在嵌套调用，那么系统会设置最短时间为4ms 。</u>当setTimeout的嵌套函数调用超过5次以上，后面每次调用的最小时间间隔为4ms 。所以一些实时性较高的需求不太适合使用setTime。比如JavaScript动画。\n\n<u>延迟执行时间有最大值。</u>定时器的执行延迟时间的最大值一般都为2147483647ms (大约24.8天，根据浏览器而异)，如果超出该值则会溢出，所以延迟时间的取值不能超过该值。\n\n使用setTimeout设置的回调函数中的this不符合直觉。\n\n比如以下这段代码的this就是指向全局，输出为1 。\n\n```\nvar name= 1;\nvar MyObj = {\n  name: 2,\n  showName: function(){\n    console.log(this.name);\n  }\n}\nsetTimeout(MyObj.showName,1000)\n```\n\n## 3.Webapi : XMLHttpRequest\n\nXMLHttpRequest这个api的引入使得更新网络数据时无需刷新整张页面而直接操作DOM来更新页面内容。在深入理解XMLHttpRequest之前先理解<u>同步回调</u>和<u>异步回调</u>两个概念。\n\n### 3.1 回调函数VS系统调用栈\n\n将一个函数作为参数传递给另一个函数，那么作为参数的这个函数就是回调函数（其他情况也可以是回调函数，不一定必须是参数）。回调函数分为同步回调和异步回调，同步回调函数是指在主函数返回之前执行的函数，异步回调则是在主函数外部执行的回调函数，如下代码所示。\n\n```\n//同步回调\nlet callback = function(){\n    console.log('i am do homework')\n}\nfunction doWork(cb) {\n    console.log('start do work')\n    cb()\n    console.log('end do work')\n}\ndoWork(callback)\n\n//异步回调\nlet callback = function(){\n    console.log('i am do homework')\n}\nfunction doWork(cb) {\n    console.log('start do work')\n    setTimeout(cb,1000)   \n    console.log('end do work')\n}\ndoWork(callback)\n//异步回调\n```\n\n在页面的事件循环系统中，每一个消息队列中的任务都有一个系统调用栈，这个类似于JavaScript的调用栈，在当前任务被执行的过程中，同步回调就是在当前主函数的上下文中执行回调函数。异步回调会有两种处理方式：第一种是将异步函数做成一个任务添加到信息队列尾部；2.第二种是异步函数添加到维任务队列中，就可以在当前任务的末尾执行微任务。\n\n### 3.2 XMLHttpRequest运行机制\n\n首先通过以下图片可以了解XMLHttpRequest的实行机制。\n\n![](/images/react/2022012403.png)\n\n先从 XMLHttpRequest 的用法开始，首先看下面这样一段请求代码：\n\n```\n function GetWebData(URL){\n    /**\n     * 1: 新建 XMLHttpRequest 请求对象\n     */\n    let xhr = new XMLHttpRequest()\n\n    /**\n     * 2: 注册相关事件回调处理函数 \n     */\n    xhr.onreadystatechange = function () {\n        switch(xhr.readyState){\n          case 0: // 请求未初始化\n            console.log(\" 请求未初始化 \")\n            break;\n          case 1://OPENED\n            console.log(\"OPENED\")\n            break;\n          case 2://HEADERS_RECEIVED\n            console.log(\"HEADERS_RECEIVED\")\n            break;\n          case 3://LOADING  \n            console.log(\"LOADING\")\n            break;\n          case 4://DONE\n            if(this.status == 200||this.status == 304){\n                console.log(this.responseText);\n                }\n            console.log(\"DONE\")\n            break;\n        }\n    }\n\n    xhr.ontimeout = function(e) { console.log('ontimeout') }\n    xhr.onerror = function(e) { console.log('onerror') }\n\n    /**\n     * 3: 打开请求\n     */\n    xhr.open('Get', URL, true);// 创建一个 Get 请求, 采用异步\n\n\n    /**\n     * 4: 配置参数\n     */\n    xhr.timeout = 3000 // 设置 xhr 请求的超时时间\n    xhr.responseType = \"text\" // 设置响应返回的数据格式\n    xhr.setRequestHeader(\"X_TEST\",\"time.geekbang\")\n\n    /**\n     * 5: 发送请求\n     */\n    xhr.send();\n}\n```\n\n在封装请求时的第一步，创建XMLHttpRequest对象，第二步为xhr对象注册回调函数，第三步配置基础的请求信息，第四步发起请求。\n\n### 3.3 XMLHttpRequest使用过程中的”坑“\n\n**跨域问题**：默认情况下，跨域请求是不被允许的。\n\n**HTTPS混合内容问题**：HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。通常，如果 HTTPS 请求页面中使用混合内容，浏览器会针对 HTTPS 混合内容显示警告，用来向用户表明此 HTTPS 页面包含不安全的资源。\n\n## 4.宏任务与微任务\n\n### 4.1 宏任务\n\n页面中大部分任务都是在渲染进程的主线程上执行的，包括渲染事件（解析DOM、计算布局、绘制），用户交互事件、JavaScript脚本执行事件，网络请求完成，文件读写完成事件等。为了让这些任务有条不紊在主线程上执行而引入了消息队列和事件循环机制，在消息队列中的任务就是宏任务。\n\n### 4.2 微任务\n\n微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前。有两种方式可以创造微任务，分别是使用<u>MutationObserver</u>以及使用<u>Promise</u>。从V8引擎上分析，在执行一段JavaScript任务时JavaScript引擎会创建一个全局执行上下文，这个执行上下文中就包括微任务队列，在该JavaScript脚本执行结束前即即将销毁其执行上下文时会先检测其为任务队列，直到为任务队列彻底没有内容后才会销毁。\n\n### 4.3 监听DOM变化方法演变\n\n监听DOM变化是前端工程师一项非常核心的需求。一开始监听DOM的变化是设置<u>setTimeout或者setInterval</u>来定时检测DOM是否有变化，这个问题会有事件间隔长短以及资源消耗等问题，2000年的时候引入了<u>Mutation Event</u>，这个方法采用观察者设计模式，当DOM有变动时就会立刻触发相应的事件，采用的方法是同步回调。但是Mutation Event让每一次DOM发送变化要立刻调用JavaScript接口，这种实时性造成严重的性能问题，为了解决其同步回调产生的性能问题而引入了<u>MutionObserver</u>。它采用”异步+微任务“的策列来解决这些问题。\n\n## 5.Promise和async await\n\n### 5.1 异步编码问题\n\nPromise解决了异步编码风格的问题。看普通的异步回调情况，如下代码所示。\n\n```\n// 执行状态\nfunction onResolve(response){console.log(response) }\nfunction onReject(error){console.log(error) }\n\nlet xhr = new XMLHttpRequest()\nxhr.ontimeout = function(e) { onReject(e)}\nxhr.onerror = function(e) { onReject(e) }\nxhr.onreadystatechange = function () { onResolve(xhr.response) }\n\n// 设置请求类型，请求 URL，是否同步信息\nlet URL = 'https://time.geekbang.com'\nxhr.open('Get', URL, true);\n\n// 设置参数\nxhr.timeout = 3000 // 设置 xhr 请求的超时时间\nxhr.responseType = \"text\" // 设置响应返回的数据格式\nxhr.setRequestHeader(\"X_TEST\",\"time.geekbang\")\n\n// 发出请求\nxhr.send();\n```\n\n这一个网络请求多次使用了异步回调，使得代码逻辑显得不连贯和不线性。所以可以封装该请求使得符合我们的观看直觉。但即使封装之后也会出现低于回调的问题，这使得代码陷入一个非常混乱的局面，引入promise就可以很好解决低于回调的问题。（其实promise我也研究不是很透彻，包括后面的async await ，以后有时间仔细学习，这里就不细讲了）\n\n### 5.2 async await\n\n即使promise能够解决异步回调编码风格问题使其看起来更能理解，但是过多的<u>then方法</u>依旧似乎有着语义化不明显的问题，所以<u>ES7</u>引入了<u>async await</u>很好解决了这个问题。async await使得异步回掉函数的写法和同步回调几乎一样，视觉上一目了然非常简介。\n\nasync await其实背后的技术就是promise和生成器的应用。如下代码所示就是一个生成器的应用。\n\n```\nfunction* genDemo() {\n    console.log(\" 开始执行第一段 \")\n    yield 'generator 2'\n\n    console.log(\" 开始执行第二段 \")\n    yield 'generator 2'\n\n    console.log(\" 开始执行第三段 \")\n    yield 'generator 2'\n\n    console.log(\" 执行结束 \")\n    return 'generator 2'\n}\n\nconsole.log('main 0')\nlet gen = genDemo()\nconsole.log(gen.next().value)\nconsole.log('main 1')\nconsole.log(gen.next().value)\nconsole.log('main 2')\nconsole.log(gen.next().value)\nconsole.log('main 3')\nconsole.log(gen.next().value)\nconsole.log('main 4')\n```\n\n执行这个函数观察输出结果可以发现genDemo并不是一次执行完成的，全局代码和genDemo代码交易执行，这就是<u>生成器函</u>数的特性。\n\n这里就涉及到了<u>协程</u>的概念，我们已经知道进程和线程的概念，一个进程里有多个线程，相类似的一个线程里也有多个协程，并且同一时间只能执行一个协程。如果从A协程启动了B协程，那么我们就将A协程称为B协程的<u>父协程</u>。如上代码就是执行在一个线程内的程序，但是它有两个协程，全局的父协程以及genDemo所对应的子协程。他们的连接和应用关系如下图所示。\n\n![](/images/react/2022012404.png)\n\n我们可以知道：第一、在生成器函数内部执行一段代码，如果遇到<u> yield </u>关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。外部函数可以通过<u> next</u> 方法恢复函数的执行。\n\n我们必须知道一个线程中的协程是<u>交互执行</u>而不是并发执行的，它们的切换是通过yield和gen.next来配合完成的。另外，当gen协程中调用了yied方法时，JavaScript引擎就会保留gen协程当前的<u>调用栈</u>信息，并恢复父协程的调用栈信息；同样当父协程中执行gen.next时也会保留父协程的调用栈信息而恢复gen协程的调用栈信息，可以参考下图所示。\n\n![](/images/react/2022012405.png)\n","slug":"浏览器中的页面循环系统","published":1,"updated":"2022-01-24T08:22:25.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh2e001s6wtv2et17vjz","content":"<hr>\n<p><em>本文来源于<a href=\"http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82\">http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程</a><a href=\"https://time.geekbang.org/column/intro/216\">《浏览器工作原理与实践》_-极客时间</a>。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。</em></p>\n<hr>\n<p>我们已经知道每个渲染进程都有一个主进程，它需要处理DOM、计算样式、处理布局以及处理JavaScript的各种任务，工作特别繁忙，那么这些任务是如何有条不紊地被主进程处理的呢？这就涉及到了浏览器的休息队列和事件循环系统。</p>\n<h2 id=\"1-消息队列和事件循环\"><a href=\"#1-消息队列和事件循环\" class=\"headerlink\" title=\"1.消息队列和事件循环\"></a>1.消息队列和事件循环</h2><h3 id=\"1-1-单线程处理任务结构\"><a href=\"#1-1-单线程处理任务结构\" class=\"headerlink\" title=\"1.1 单线程处理任务结构\"></a>1.1 单线程处理任务结构</h3><p>主线程会有一个事件处理的<u>消息队列</u>，那些需要执行的任务会逐个加入消息队列当中，按照先进先出的顺序被主线程去执行。</p>\n<p>但是主线程在运行过程中如何接收新的任务呢？这就涉及到了<u>事件循环机制</u>，在主线程中添加一个循环语句实时监听新任务的产生。</p>\n<p>不过在这样的结构下主线程处理的所有任务都是内部任务，而有一些IO任务比如接收键盘消息等外部任务又如何添加到渲染进程的主线程当中呢？IO任务是由<u>IO线程</u>来管理的，当IO线程接收到这些处理事件时会将其添加到主线程的消息队列中，这样渲染主线程就能接收这些外部任务了。</p>\n<p>在此基础上渲染进程还会经常接收其他进程的交互处理信息例如网络进程、浏览器进程的相关信息，这些进程产生的事件又是如何添加到渲染进程的消息队列中进行处理的呢？如下图所示，这些跨进程任务和渲染进程的IO线程进行沟通交互来进行任务的传送。</p>\n<p><img src=\"/images/react/2022012401.png\"></p>\n<p>当需要退出页面时，则会考虑到安全退出渲染进程主线程的问题，chrome会在主线程中设置一个<u>退出标志变量</u>，主线程每次执行完一个任务时都会判断退出标志是否有变化。如果有则会安全推出线程。</p>\n<h3 id=\"1-2-该结构的缺点\"><a href=\"#1-2-该结构的缺点\" class=\"headerlink\" title=\"1.2 该结构的缺点\"></a>1.2 该结构的缺点</h3><p>单线程以及先入先出的结构会产生两个问题。</p>\n<p>第一：<u>如何处理高优先级任务</u>。比方说DOM节点变化渲染就是个需要优先处理的任务，针对这个情况，<u>微任务</u>就诞生了。我们将消息队列中的任务称为宏任务，每个宏任务都有一个微任务队列。在主线程执行某个宏任务的过程中如果监听接收到哪些需要优先处理的任务，就会把这些任务添加到当前的微任务队列中，当当前的宏任务执行结束后就执行微任务队列中的所有微任务，再继续执行下一个宏任务。</p>\n<p>第二：<u>如何解决单个任务执行时长过久的情况</u>。因为是单线程执行，一次只能执行一个任务，当一个任务执行过久就会让人视觉上感受到页面卡顿的效果，针对这种情况，JavaScript采用<u>回调功能</u>来规避问题。</p>\n<h3 id=\"1-3-浏览器中的页面\"><a href=\"#1-3-浏览器中的页面\" class=\"headerlink\" title=\"1.3 浏览器中的页面\"></a>1.3 浏览器中的页面</h3><p>可以再chrome的开发者工具中，点击“Performance”标签来查看页面加载的事件执行情况，如下图所示。</p>\n<p><img src=\"/images/react/2022012402.png\"></p>\n<h2 id=\"2-Webapi：setTimeout\"><a href=\"#2-Webapi：setTimeout\" class=\"headerlink\" title=\"2.Webapi：setTimeout\"></a>2.Webapi：setTimeout</h2><p>setTimeout是一个<u>定时器</u>，用来指定某个函数在多少毫秒之后执行，它会返回一个整数来表示定时器的编号，利用该编号可以取消定时器。以下为使用代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showName</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot; 极客时间 &quot;</span>)<br>&#125;<br><span class=\"hljs-keyword\">var</span> timerID = <span class=\"hljs-built_in\">setTimeout</span>(showName,<span class=\"hljs-number\">200</span>);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-setTimeout的实现\"><a href=\"#2-1-setTimeout的实现\" class=\"headerlink\" title=\"2.1 setTimeout的实现\"></a>2.1 setTimeout的实现</h3><p>定时器的作用就是为了在指定时间内执行某任务，如果将定时器放在普通的消息队列中，有可能在执行该定时器时就已经超过了任务时长。为了解决该问题，JavaScript又引入了<u>延迟队列机制</u>。</p>\n<p>当JavaScript创建一个定时器时，渲染经常会将该定时器的回调任务添加到延迟队列当中，其中包括回调任务函数名称、发起时间、延迟执行时间。在主线程中每当处理完一个宏任务就会去执行延迟队列当中那些已经到期的任务。</p>\n<h3 id=\"2-2-使用setTimeout的注意事项\"><a href=\"#2-2-使用setTimeout的注意事项\" class=\"headerlink\" title=\"2.2 使用setTimeout的注意事项\"></a>2.2 使用setTimeout的注意事项</h3><p><u>如果当前任务执行时间过久，会影响延迟到期任务执行。</u>因为每次执行延迟队列中的任务都是在执行完一个宏任务之后的事情，如果该宏任务占用太多时间也有可能超过延迟队列中的任务定时时间。</p>\n<p><u>如果setTimeout存在嵌套调用，那么系统会设置最短时间为4ms 。</u>当setTimeout的嵌套函数调用超过5次以上，后面每次调用的最小时间间隔为4ms 。所以一些实时性较高的需求不太适合使用setTime。比如JavaScript动画。</p>\n<p><u>延迟执行时间有最大值。</u>定时器的执行延迟时间的最大值一般都为2147483647ms (大约24.8天，根据浏览器而异)，如果超出该值则会溢出，所以延迟时间的取值不能超过该值。</p>\n<p>使用setTimeout设置的回调函数中的this不符合直觉。</p>\n<p>比如以下这段代码的this就是指向全局，输出为1 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> name= <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">var</span> MyObj = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-number\">2</span>,<br>  <span class=\"hljs-attr\">showName</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.name);<br>  &#125;<br>&#125;<br><span class=\"hljs-built_in\">setTimeout</span>(MyObj.showName,<span class=\"hljs-number\">1000</span>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"3-Webapi-XMLHttpRequest\"><a href=\"#3-Webapi-XMLHttpRequest\" class=\"headerlink\" title=\"3.Webapi : XMLHttpRequest\"></a>3.Webapi : XMLHttpRequest</h2><p>XMLHttpRequest这个api的引入使得更新网络数据时无需刷新整张页面而直接操作DOM来更新页面内容。在深入理解XMLHttpRequest之前先理解<u>同步回调</u>和<u>异步回调</u>两个概念。</p>\n<h3 id=\"3-1-回调函数VS系统调用栈\"><a href=\"#3-1-回调函数VS系统调用栈\" class=\"headerlink\" title=\"3.1 回调函数VS系统调用栈\"></a>3.1 回调函数VS系统调用栈</h3><p>将一个函数作为参数传递给另一个函数，那么作为参数的这个函数就是回调函数（其他情况也可以是回调函数，不一定必须是参数）。回调函数分为同步回调和异步回调，同步回调函数是指在主函数返回之前执行的函数，异步回调则是在主函数外部执行的回调函数，如下代码所示。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">//同步回调</span><br><span class=\"hljs-keyword\">let</span> callback = <span class=\"hljs-keyword\">function</span><span class=\"hljs-literal\">()</span>&#123;<br>    console.log(&#x27;i am <span class=\"hljs-keyword\">do</span> homework&#x27;)<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-keyword\">do</span><span class=\"hljs-constructor\">Work(<span class=\"hljs-params\">cb</span>)</span> &#123;<br>    console.log(&#x27;start <span class=\"hljs-keyword\">do</span> work&#x27;)<br>    cb<span class=\"hljs-literal\">()</span><br>    console.log(&#x27;<span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span> work&#x27;)<br>&#125;<br><span class=\"hljs-keyword\">do</span><span class=\"hljs-constructor\">Work(<span class=\"hljs-params\">callback</span>)</span><br><br><span class=\"hljs-comment\">//异步回调</span><br><span class=\"hljs-keyword\">let</span> callback = <span class=\"hljs-keyword\">function</span><span class=\"hljs-literal\">()</span>&#123;<br>    console.log(&#x27;i am <span class=\"hljs-keyword\">do</span> homework&#x27;)<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-keyword\">do</span><span class=\"hljs-constructor\">Work(<span class=\"hljs-params\">cb</span>)</span> &#123;<br>    console.log(&#x27;start <span class=\"hljs-keyword\">do</span> work&#x27;)<br>    set<span class=\"hljs-constructor\">Timeout(<span class=\"hljs-params\">cb</span>,1000)</span>   <br>    console.log(&#x27;<span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span> work&#x27;)<br>&#125;<br><span class=\"hljs-keyword\">do</span><span class=\"hljs-constructor\">Work(<span class=\"hljs-params\">callback</span>)</span><br><span class=\"hljs-comment\">//异步回调</span><br></code></pre></td></tr></table></figure>\n\n<p>在页面的事件循环系统中，每一个消息队列中的任务都有一个系统调用栈，这个类似于JavaScript的调用栈，在当前任务被执行的过程中，同步回调就是在当前主函数的上下文中执行回调函数。异步回调会有两种处理方式：第一种是将异步函数做成一个任务添加到信息队列尾部；2.第二种是异步函数添加到维任务队列中，就可以在当前任务的末尾执行微任务。</p>\n<h3 id=\"3-2-XMLHttpRequest运行机制\"><a href=\"#3-2-XMLHttpRequest运行机制\" class=\"headerlink\" title=\"3.2 XMLHttpRequest运行机制\"></a>3.2 XMLHttpRequest运行机制</h3><p>首先通过以下图片可以了解XMLHttpRequest的实行机制。</p>\n<p><img src=\"/images/react/2022012403.png\"></p>\n<p>先从 XMLHttpRequest 的用法开始，首先看下面这样一段请求代码：</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs qml\"> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">GetWebData</span>(<span class=\"hljs-params\">URL</span>)</span>&#123;<br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 1: 新建 XMLHttpRequest 请求对象</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">let</span> xhr = <span class=\"hljs-keyword\">new</span> XMLHttpRequest()<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 2: 注册相关事件回调处理函数 </span><br><span class=\"hljs-comment\">     */</span><br>    xhr.onreadystatechange = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>        <span class=\"hljs-keyword\">switch</span>(xhr.readyState)&#123;<br>          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span>: <span class=\"hljs-comment\">// 请求未初始化</span><br>            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot; 请求未初始化 &quot;</span>)<br>            <span class=\"hljs-keyword\">break</span>;<br>          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:<span class=\"hljs-comment\">//OPENED</span><br>            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;OPENED&quot;</span>)<br>            <span class=\"hljs-keyword\">break</span>;<br>          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:<span class=\"hljs-comment\">//HEADERS_RECEIVED</span><br>            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;HEADERS_RECEIVED&quot;</span>)<br>            <span class=\"hljs-keyword\">break</span>;<br>          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">3</span>:<span class=\"hljs-comment\">//LOADING  </span><br>            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;LOADING&quot;</span>)<br>            <span class=\"hljs-keyword\">break</span>;<br>          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">4</span>:<span class=\"hljs-comment\">//DONE</span><br>            <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.status == <span class=\"hljs-number\">200</span>||<span class=\"hljs-keyword\">this</span>.status == <span class=\"hljs-number\">304</span>)&#123;<br>                <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.responseText);<br>                &#125;<br>            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;DONE&quot;</span>)<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>    &#125;<br><br>    xhr.ontimeout = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;ontimeout&#x27;</span>) &#125;<br>    xhr.onerror = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;onerror&#x27;</span>) &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 3: 打开请求</span><br><span class=\"hljs-comment\">     */</span><br>    xhr.open(<span class=\"hljs-string\">&#x27;Get&#x27;</span>, URL, <span class=\"hljs-literal\">true</span>);<span class=\"hljs-comment\">// 创建一个 Get 请求, 采用异步</span><br><br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 4: 配置参数</span><br><span class=\"hljs-comment\">     */</span><br>    xhr.timeout = <span class=\"hljs-number\">3000</span> <span class=\"hljs-comment\">// 设置 xhr 请求的超时时间</span><br>    xhr.responseType = <span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-comment\">// 设置响应返回的数据格式</span><br>    xhr.setRequestHeader(<span class=\"hljs-string\">&quot;X_TEST&quot;</span>,<span class=\"hljs-string\">&quot;time.geekbang&quot;</span>)<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 5: 发送请求</span><br><span class=\"hljs-comment\">     */</span><br>    xhr.send();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在封装请求时的第一步，创建XMLHttpRequest对象，第二步为xhr对象注册回调函数，第三步配置基础的请求信息，第四步发起请求。</p>\n<h3 id=\"3-3-XMLHttpRequest使用过程中的”坑“\"><a href=\"#3-3-XMLHttpRequest使用过程中的”坑“\" class=\"headerlink\" title=\"3.3 XMLHttpRequest使用过程中的”坑“\"></a>3.3 XMLHttpRequest使用过程中的”坑“</h3><p><strong>跨域问题</strong>：默认情况下，跨域请求是不被允许的。</p>\n<p><strong>HTTPS混合内容问题</strong>：HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。通常，如果 HTTPS 请求页面中使用混合内容，浏览器会针对 HTTPS 混合内容显示警告，用来向用户表明此 HTTPS 页面包含不安全的资源。</p>\n<h2 id=\"4-宏任务与微任务\"><a href=\"#4-宏任务与微任务\" class=\"headerlink\" title=\"4.宏任务与微任务\"></a>4.宏任务与微任务</h2><h3 id=\"4-1-宏任务\"><a href=\"#4-1-宏任务\" class=\"headerlink\" title=\"4.1 宏任务\"></a>4.1 宏任务</h3><p>页面中大部分任务都是在渲染进程的主线程上执行的，包括渲染事件（解析DOM、计算布局、绘制），用户交互事件、JavaScript脚本执行事件，网络请求完成，文件读写完成事件等。为了让这些任务有条不紊在主线程上执行而引入了消息队列和事件循环机制，在消息队列中的任务就是宏任务。</p>\n<h3 id=\"4-2-微任务\"><a href=\"#4-2-微任务\" class=\"headerlink\" title=\"4.2 微任务\"></a>4.2 微任务</h3><p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前。有两种方式可以创造微任务，分别是使用<u>MutationObserver</u>以及使用<u>Promise</u>。从V8引擎上分析，在执行一段JavaScript任务时JavaScript引擎会创建一个全局执行上下文，这个执行上下文中就包括微任务队列，在该JavaScript脚本执行结束前即即将销毁其执行上下文时会先检测其为任务队列，直到为任务队列彻底没有内容后才会销毁。</p>\n<h3 id=\"4-3-监听DOM变化方法演变\"><a href=\"#4-3-监听DOM变化方法演变\" class=\"headerlink\" title=\"4.3 监听DOM变化方法演变\"></a>4.3 监听DOM变化方法演变</h3><p>监听DOM变化是前端工程师一项非常核心的需求。一开始监听DOM的变化是设置<u>setTimeout或者setInterval</u>来定时检测DOM是否有变化，这个问题会有事件间隔长短以及资源消耗等问题，2000年的时候引入了<u>Mutation Event</u>，这个方法采用观察者设计模式，当DOM有变动时就会立刻触发相应的事件，采用的方法是同步回调。但是Mutation Event让每一次DOM发送变化要立刻调用JavaScript接口，这种实时性造成严重的性能问题，为了解决其同步回调产生的性能问题而引入了<u>MutionObserver</u>。它采用”异步+微任务“的策列来解决这些问题。</p>\n<h2 id=\"5-Promise和async-await\"><a href=\"#5-Promise和async-await\" class=\"headerlink\" title=\"5.Promise和async await\"></a>5.Promise和async await</h2><h3 id=\"5-1-异步编码问题\"><a href=\"#5-1-异步编码问题\" class=\"headerlink\" title=\"5.1 异步编码问题\"></a>5.1 异步编码问题</h3><p>Promise解决了异步编码风格的问题。看普通的异步回调情况，如下代码所示。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">// 执行状态</span><br><span class=\"hljs-keyword\">function</span> on<span class=\"hljs-constructor\">Resolve(<span class=\"hljs-params\">response</span>)</span>&#123;console.log(response) &#125;<br><span class=\"hljs-keyword\">function</span> on<span class=\"hljs-constructor\">Reject(<span class=\"hljs-params\">error</span>)</span>&#123;console.log(error) &#125;<br><br><span class=\"hljs-keyword\">let</span> xhr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">XMLHttpRequest()</span><br>xhr.ontimeout = <span class=\"hljs-keyword\">function</span>(e) &#123; on<span class=\"hljs-constructor\">Reject(<span class=\"hljs-params\">e</span>)</span>&#125;<br>xhr.onerror = <span class=\"hljs-keyword\">function</span>(e) &#123; on<span class=\"hljs-constructor\">Reject(<span class=\"hljs-params\">e</span>)</span> &#125;<br>xhr.onreadystatechange = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-literal\">()</span> &#123; on<span class=\"hljs-constructor\">Resolve(<span class=\"hljs-params\">xhr</span>.<span class=\"hljs-params\">response</span>)</span> &#125;<br><br><span class=\"hljs-comment\">// 设置请求类型，请求 URL，是否同步信息</span><br><span class=\"hljs-keyword\">let</span> URL = &#x27;https:<span class=\"hljs-comment\">//time.geekbang.com&#x27;</span><br>xhr.<span class=\"hljs-keyword\">open</span>(&#x27;Get&#x27;, URL, <span class=\"hljs-literal\">true</span>);<br><br><span class=\"hljs-comment\">// 设置参数</span><br>xhr.timeout = <span class=\"hljs-number\">3000</span> <span class=\"hljs-comment\">// 设置 xhr 请求的超时时间</span><br>xhr.responseType = <span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-comment\">// 设置响应返回的数据格式</span><br>xhr.set<span class=\"hljs-constructor\">RequestHeader(<span class=\"hljs-string\">&quot;X_TEST&quot;</span>,<span class=\"hljs-string\">&quot;time.geekbang&quot;</span>)</span><br><br><span class=\"hljs-comment\">// 发出请求</span><br>xhr.send<span class=\"hljs-literal\">()</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这一个网络请求多次使用了异步回调，使得代码逻辑显得不连贯和不线性。所以可以封装该请求使得符合我们的观看直觉。但即使封装之后也会出现低于回调的问题，这使得代码陷入一个非常混乱的局面，引入promise就可以很好解决低于回调的问题。（其实promise我也研究不是很透彻，包括后面的async await ，以后有时间仔细学习，这里就不细讲了）</p>\n<h3 id=\"5-2-async-await\"><a href=\"#5-2-async-await\" class=\"headerlink\" title=\"5.2 async await\"></a>5.2 async await</h3><p>即使promise能够解决异步回调编码风格问题使其看起来更能理解，但是过多的<u>then方法</u>依旧似乎有着语义化不明显的问题，所以<u>ES7</u>引入了<u>async await</u>很好解决了这个问题。async await使得异步回掉函数的写法和同步回调几乎一样，视觉上一目了然非常简介。</p>\n<p>async await其实背后的技术就是promise和生成器的应用。如下代码所示就是一个生成器的应用。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lua\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">genDemo</span><span class=\"hljs-params\">()</span></span> &#123;<br>    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot; 开始执行第一段 &quot;</span>)<br>    <span class=\"hljs-built_in\">yield</span> <span class=\"hljs-string\">&#x27;generator 2&#x27;</span><br><br>    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot; 开始执行第二段 &quot;</span>)<br>    <span class=\"hljs-built_in\">yield</span> <span class=\"hljs-string\">&#x27;generator 2&#x27;</span><br><br>    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot; 开始执行第三段 &quot;</span>)<br>    <span class=\"hljs-built_in\">yield</span> <span class=\"hljs-string\">&#x27;generator 2&#x27;</span><br><br>    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot; 执行结束 &quot;</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;generator 2&#x27;</span><br>&#125;<br><br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;main 0&#x27;</span>)<br>let gen = genDemo()<br>console.<span class=\"hljs-built_in\">log</span>(gen.<span class=\"hljs-built_in\">next</span>().value)<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;main 1&#x27;</span>)<br>console.<span class=\"hljs-built_in\">log</span>(gen.<span class=\"hljs-built_in\">next</span>().value)<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;main 2&#x27;</span>)<br>console.<span class=\"hljs-built_in\">log</span>(gen.<span class=\"hljs-built_in\">next</span>().value)<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;main 3&#x27;</span>)<br>console.<span class=\"hljs-built_in\">log</span>(gen.<span class=\"hljs-built_in\">next</span>().value)<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;main 4&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>执行这个函数观察输出结果可以发现genDemo并不是一次执行完成的，全局代码和genDemo代码交易执行，这就是<u>生成器函</u>数的特性。</p>\n<p>这里就涉及到了<u>协程</u>的概念，我们已经知道进程和线程的概念，一个进程里有多个线程，相类似的一个线程里也有多个协程，并且同一时间只能执行一个协程。如果从A协程启动了B协程，那么我们就将A协程称为B协程的<u>父协程</u>。如上代码就是执行在一个线程内的程序，但是它有两个协程，全局的父协程以及genDemo所对应的子协程。他们的连接和应用关系如下图所示。</p>\n<p><img src=\"/images/react/2022012404.png\"></p>\n<p>我们可以知道：第一、在生成器函数内部执行一段代码，如果遇到<u> yield </u>关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。外部函数可以通过<u> next</u> 方法恢复函数的执行。</p>\n<p>我们必须知道一个线程中的协程是<u>交互执行</u>而不是并发执行的，它们的切换是通过yield和gen.next来配合完成的。另外，当gen协程中调用了yied方法时，JavaScript引擎就会保留gen协程当前的<u>调用栈</u>信息，并恢复父协程的调用栈信息；同样当父协程中执行gen.next时也会保留父协程的调用栈信息而恢复gen协程的调用栈信息，可以参考下图所示。</p>\n<p><img src=\"/images/react/2022012405.png\"></p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>本文来源于<a href=\"http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82\">http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程</a><a href=\"https://time.geekbang.org/column/intro/216\">《浏览器工作原理与实践》_-极客时间</a>。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。</em></p>\n<hr>\n<p>我们已经知道每个渲染进程都有一个主进程，它需要处理DOM、计算样式、处理布局以及处理JavaScript的各种任务，工作特别繁忙，那么这些任务是如何有条不紊地被主进程处理的呢？这就涉及到了浏览器的休息队列和事件循环系统。</p>\n<h2 id=\"1-消息队列和事件循环\"><a href=\"#1-消息队列和事件循环\" class=\"headerlink\" title=\"1.消息队列和事件循环\"></a>1.消息队列和事件循环</h2><h3 id=\"1-1-单线程处理任务结构\"><a href=\"#1-1-单线程处理任务结构\" class=\"headerlink\" title=\"1.1 单线程处理任务结构\"></a>1.1 单线程处理任务结构</h3><p>主线程会有一个事件处理的<u>消息队列</u>，那些需要执行的任务会逐个加入消息队列当中，按照先进先出的顺序被主线程去执行。</p>\n<p>但是主线程在运行过程中如何接收新的任务呢？这就涉及到了<u>事件循环机制</u>，在主线程中添加一个循环语句实时监听新任务的产生。</p>\n<p>不过在这样的结构下主线程处理的所有任务都是内部任务，而有一些IO任务比如接收键盘消息等外部任务又如何添加到渲染进程的主线程当中呢？IO任务是由<u>IO线程</u>来管理的，当IO线程接收到这些处理事件时会将其添加到主线程的消息队列中，这样渲染主线程就能接收这些外部任务了。</p>\n<p>在此基础上渲染进程还会经常接收其他进程的交互处理信息例如网络进程、浏览器进程的相关信息，这些进程产生的事件又是如何添加到渲染进程的消息队列中进行处理的呢？如下图所示，这些跨进程任务和渲染进程的IO线程进行沟通交互来进行任务的传送。</p>\n<p><img src=\"/images/react/2022012401.png\"></p>\n<p>当需要退出页面时，则会考虑到安全退出渲染进程主线程的问题，chrome会在主线程中设置一个<u>退出标志变量</u>，主线程每次执行完一个任务时都会判断退出标志是否有变化。如果有则会安全推出线程。</p>\n<h3 id=\"1-2-该结构的缺点\"><a href=\"#1-2-该结构的缺点\" class=\"headerlink\" title=\"1.2 该结构的缺点\"></a>1.2 该结构的缺点</h3><p>单线程以及先入先出的结构会产生两个问题。</p>\n<p>第一：<u>如何处理高优先级任务</u>。比方说DOM节点变化渲染就是个需要优先处理的任务，针对这个情况，<u>微任务</u>就诞生了。我们将消息队列中的任务称为宏任务，每个宏任务都有一个微任务队列。在主线程执行某个宏任务的过程中如果监听接收到哪些需要优先处理的任务，就会把这些任务添加到当前的微任务队列中，当当前的宏任务执行结束后就执行微任务队列中的所有微任务，再继续执行下一个宏任务。</p>\n<p>第二：<u>如何解决单个任务执行时长过久的情况</u>。因为是单线程执行，一次只能执行一个任务，当一个任务执行过久就会让人视觉上感受到页面卡顿的效果，针对这种情况，JavaScript采用<u>回调功能</u>来规避问题。</p>\n<h3 id=\"1-3-浏览器中的页面\"><a href=\"#1-3-浏览器中的页面\" class=\"headerlink\" title=\"1.3 浏览器中的页面\"></a>1.3 浏览器中的页面</h3><p>可以再chrome的开发者工具中，点击“Performance”标签来查看页面加载的事件执行情况，如下图所示。</p>\n<p><img src=\"/images/react/2022012402.png\"></p>\n<h2 id=\"2-Webapi：setTimeout\"><a href=\"#2-Webapi：setTimeout\" class=\"headerlink\" title=\"2.Webapi：setTimeout\"></a>2.Webapi：setTimeout</h2><p>setTimeout是一个<u>定时器</u>，用来指定某个函数在多少毫秒之后执行，它会返回一个整数来表示定时器的编号，利用该编号可以取消定时器。以下为使用代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showName</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot; 极客时间 &quot;</span>)<br>&#125;<br><span class=\"hljs-keyword\">var</span> timerID = <span class=\"hljs-built_in\">setTimeout</span>(showName,<span class=\"hljs-number\">200</span>);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-setTimeout的实现\"><a href=\"#2-1-setTimeout的实现\" class=\"headerlink\" title=\"2.1 setTimeout的实现\"></a>2.1 setTimeout的实现</h3><p>定时器的作用就是为了在指定时间内执行某任务，如果将定时器放在普通的消息队列中，有可能在执行该定时器时就已经超过了任务时长。为了解决该问题，JavaScript又引入了<u>延迟队列机制</u>。</p>\n<p>当JavaScript创建一个定时器时，渲染经常会将该定时器的回调任务添加到延迟队列当中，其中包括回调任务函数名称、发起时间、延迟执行时间。在主线程中每当处理完一个宏任务就会去执行延迟队列当中那些已经到期的任务。</p>\n<h3 id=\"2-2-使用setTimeout的注意事项\"><a href=\"#2-2-使用setTimeout的注意事项\" class=\"headerlink\" title=\"2.2 使用setTimeout的注意事项\"></a>2.2 使用setTimeout的注意事项</h3><p><u>如果当前任务执行时间过久，会影响延迟到期任务执行。</u>因为每次执行延迟队列中的任务都是在执行完一个宏任务之后的事情，如果该宏任务占用太多时间也有可能超过延迟队列中的任务定时时间。</p>\n<p><u>如果setTimeout存在嵌套调用，那么系统会设置最短时间为4ms 。</u>当setTimeout的嵌套函数调用超过5次以上，后面每次调用的最小时间间隔为4ms 。所以一些实时性较高的需求不太适合使用setTime。比如JavaScript动画。</p>\n<p><u>延迟执行时间有最大值。</u>定时器的执行延迟时间的最大值一般都为2147483647ms (大约24.8天，根据浏览器而异)，如果超出该值则会溢出，所以延迟时间的取值不能超过该值。</p>\n<p>使用setTimeout设置的回调函数中的this不符合直觉。</p>\n<p>比如以下这段代码的this就是指向全局，输出为1 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> name= <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">var</span> MyObj = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-number\">2</span>,<br>  <span class=\"hljs-attr\">showName</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.name);<br>  &#125;<br>&#125;<br><span class=\"hljs-built_in\">setTimeout</span>(MyObj.showName,<span class=\"hljs-number\">1000</span>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"3-Webapi-XMLHttpRequest\"><a href=\"#3-Webapi-XMLHttpRequest\" class=\"headerlink\" title=\"3.Webapi : XMLHttpRequest\"></a>3.Webapi : XMLHttpRequest</h2><p>XMLHttpRequest这个api的引入使得更新网络数据时无需刷新整张页面而直接操作DOM来更新页面内容。在深入理解XMLHttpRequest之前先理解<u>同步回调</u>和<u>异步回调</u>两个概念。</p>\n<h3 id=\"3-1-回调函数VS系统调用栈\"><a href=\"#3-1-回调函数VS系统调用栈\" class=\"headerlink\" title=\"3.1 回调函数VS系统调用栈\"></a>3.1 回调函数VS系统调用栈</h3><p>将一个函数作为参数传递给另一个函数，那么作为参数的这个函数就是回调函数（其他情况也可以是回调函数，不一定必须是参数）。回调函数分为同步回调和异步回调，同步回调函数是指在主函数返回之前执行的函数，异步回调则是在主函数外部执行的回调函数，如下代码所示。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">//同步回调</span><br><span class=\"hljs-keyword\">let</span> callback = <span class=\"hljs-keyword\">function</span><span class=\"hljs-literal\">()</span>&#123;<br>    console.log(&#x27;i am <span class=\"hljs-keyword\">do</span> homework&#x27;)<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-keyword\">do</span><span class=\"hljs-constructor\">Work(<span class=\"hljs-params\">cb</span>)</span> &#123;<br>    console.log(&#x27;start <span class=\"hljs-keyword\">do</span> work&#x27;)<br>    cb<span class=\"hljs-literal\">()</span><br>    console.log(&#x27;<span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span> work&#x27;)<br>&#125;<br><span class=\"hljs-keyword\">do</span><span class=\"hljs-constructor\">Work(<span class=\"hljs-params\">callback</span>)</span><br><br><span class=\"hljs-comment\">//异步回调</span><br><span class=\"hljs-keyword\">let</span> callback = <span class=\"hljs-keyword\">function</span><span class=\"hljs-literal\">()</span>&#123;<br>    console.log(&#x27;i am <span class=\"hljs-keyword\">do</span> homework&#x27;)<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-keyword\">do</span><span class=\"hljs-constructor\">Work(<span class=\"hljs-params\">cb</span>)</span> &#123;<br>    console.log(&#x27;start <span class=\"hljs-keyword\">do</span> work&#x27;)<br>    set<span class=\"hljs-constructor\">Timeout(<span class=\"hljs-params\">cb</span>,1000)</span>   <br>    console.log(&#x27;<span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span> work&#x27;)<br>&#125;<br><span class=\"hljs-keyword\">do</span><span class=\"hljs-constructor\">Work(<span class=\"hljs-params\">callback</span>)</span><br><span class=\"hljs-comment\">//异步回调</span><br></code></pre></td></tr></table></figure>\n\n<p>在页面的事件循环系统中，每一个消息队列中的任务都有一个系统调用栈，这个类似于JavaScript的调用栈，在当前任务被执行的过程中，同步回调就是在当前主函数的上下文中执行回调函数。异步回调会有两种处理方式：第一种是将异步函数做成一个任务添加到信息队列尾部；2.第二种是异步函数添加到维任务队列中，就可以在当前任务的末尾执行微任务。</p>\n<h3 id=\"3-2-XMLHttpRequest运行机制\"><a href=\"#3-2-XMLHttpRequest运行机制\" class=\"headerlink\" title=\"3.2 XMLHttpRequest运行机制\"></a>3.2 XMLHttpRequest运行机制</h3><p>首先通过以下图片可以了解XMLHttpRequest的实行机制。</p>\n<p><img src=\"/images/react/2022012403.png\"></p>\n<p>先从 XMLHttpRequest 的用法开始，首先看下面这样一段请求代码：</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs qml\"> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">GetWebData</span>(<span class=\"hljs-params\">URL</span>)</span>&#123;<br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 1: 新建 XMLHttpRequest 请求对象</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">let</span> xhr = <span class=\"hljs-keyword\">new</span> XMLHttpRequest()<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 2: 注册相关事件回调处理函数 </span><br><span class=\"hljs-comment\">     */</span><br>    xhr.onreadystatechange = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>        <span class=\"hljs-keyword\">switch</span>(xhr.readyState)&#123;<br>          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span>: <span class=\"hljs-comment\">// 请求未初始化</span><br>            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot; 请求未初始化 &quot;</span>)<br>            <span class=\"hljs-keyword\">break</span>;<br>          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:<span class=\"hljs-comment\">//OPENED</span><br>            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;OPENED&quot;</span>)<br>            <span class=\"hljs-keyword\">break</span>;<br>          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:<span class=\"hljs-comment\">//HEADERS_RECEIVED</span><br>            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;HEADERS_RECEIVED&quot;</span>)<br>            <span class=\"hljs-keyword\">break</span>;<br>          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">3</span>:<span class=\"hljs-comment\">//LOADING  </span><br>            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;LOADING&quot;</span>)<br>            <span class=\"hljs-keyword\">break</span>;<br>          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">4</span>:<span class=\"hljs-comment\">//DONE</span><br>            <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.status == <span class=\"hljs-number\">200</span>||<span class=\"hljs-keyword\">this</span>.status == <span class=\"hljs-number\">304</span>)&#123;<br>                <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.responseText);<br>                &#125;<br>            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;DONE&quot;</span>)<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>    &#125;<br><br>    xhr.ontimeout = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;ontimeout&#x27;</span>) &#125;<br>    xhr.onerror = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;onerror&#x27;</span>) &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 3: 打开请求</span><br><span class=\"hljs-comment\">     */</span><br>    xhr.open(<span class=\"hljs-string\">&#x27;Get&#x27;</span>, URL, <span class=\"hljs-literal\">true</span>);<span class=\"hljs-comment\">// 创建一个 Get 请求, 采用异步</span><br><br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 4: 配置参数</span><br><span class=\"hljs-comment\">     */</span><br>    xhr.timeout = <span class=\"hljs-number\">3000</span> <span class=\"hljs-comment\">// 设置 xhr 请求的超时时间</span><br>    xhr.responseType = <span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-comment\">// 设置响应返回的数据格式</span><br>    xhr.setRequestHeader(<span class=\"hljs-string\">&quot;X_TEST&quot;</span>,<span class=\"hljs-string\">&quot;time.geekbang&quot;</span>)<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 5: 发送请求</span><br><span class=\"hljs-comment\">     */</span><br>    xhr.send();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在封装请求时的第一步，创建XMLHttpRequest对象，第二步为xhr对象注册回调函数，第三步配置基础的请求信息，第四步发起请求。</p>\n<h3 id=\"3-3-XMLHttpRequest使用过程中的”坑“\"><a href=\"#3-3-XMLHttpRequest使用过程中的”坑“\" class=\"headerlink\" title=\"3.3 XMLHttpRequest使用过程中的”坑“\"></a>3.3 XMLHttpRequest使用过程中的”坑“</h3><p><strong>跨域问题</strong>：默认情况下，跨域请求是不被允许的。</p>\n<p><strong>HTTPS混合内容问题</strong>：HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。通常，如果 HTTPS 请求页面中使用混合内容，浏览器会针对 HTTPS 混合内容显示警告，用来向用户表明此 HTTPS 页面包含不安全的资源。</p>\n<h2 id=\"4-宏任务与微任务\"><a href=\"#4-宏任务与微任务\" class=\"headerlink\" title=\"4.宏任务与微任务\"></a>4.宏任务与微任务</h2><h3 id=\"4-1-宏任务\"><a href=\"#4-1-宏任务\" class=\"headerlink\" title=\"4.1 宏任务\"></a>4.1 宏任务</h3><p>页面中大部分任务都是在渲染进程的主线程上执行的，包括渲染事件（解析DOM、计算布局、绘制），用户交互事件、JavaScript脚本执行事件，网络请求完成，文件读写完成事件等。为了让这些任务有条不紊在主线程上执行而引入了消息队列和事件循环机制，在消息队列中的任务就是宏任务。</p>\n<h3 id=\"4-2-微任务\"><a href=\"#4-2-微任务\" class=\"headerlink\" title=\"4.2 微任务\"></a>4.2 微任务</h3><p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前。有两种方式可以创造微任务，分别是使用<u>MutationObserver</u>以及使用<u>Promise</u>。从V8引擎上分析，在执行一段JavaScript任务时JavaScript引擎会创建一个全局执行上下文，这个执行上下文中就包括微任务队列，在该JavaScript脚本执行结束前即即将销毁其执行上下文时会先检测其为任务队列，直到为任务队列彻底没有内容后才会销毁。</p>\n<h3 id=\"4-3-监听DOM变化方法演变\"><a href=\"#4-3-监听DOM变化方法演变\" class=\"headerlink\" title=\"4.3 监听DOM变化方法演变\"></a>4.3 监听DOM变化方法演变</h3><p>监听DOM变化是前端工程师一项非常核心的需求。一开始监听DOM的变化是设置<u>setTimeout或者setInterval</u>来定时检测DOM是否有变化，这个问题会有事件间隔长短以及资源消耗等问题，2000年的时候引入了<u>Mutation Event</u>，这个方法采用观察者设计模式，当DOM有变动时就会立刻触发相应的事件，采用的方法是同步回调。但是Mutation Event让每一次DOM发送变化要立刻调用JavaScript接口，这种实时性造成严重的性能问题，为了解决其同步回调产生的性能问题而引入了<u>MutionObserver</u>。它采用”异步+微任务“的策列来解决这些问题。</p>\n<h2 id=\"5-Promise和async-await\"><a href=\"#5-Promise和async-await\" class=\"headerlink\" title=\"5.Promise和async await\"></a>5.Promise和async await</h2><h3 id=\"5-1-异步编码问题\"><a href=\"#5-1-异步编码问题\" class=\"headerlink\" title=\"5.1 异步编码问题\"></a>5.1 异步编码问题</h3><p>Promise解决了异步编码风格的问题。看普通的异步回调情况，如下代码所示。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">// 执行状态</span><br><span class=\"hljs-keyword\">function</span> on<span class=\"hljs-constructor\">Resolve(<span class=\"hljs-params\">response</span>)</span>&#123;console.log(response) &#125;<br><span class=\"hljs-keyword\">function</span> on<span class=\"hljs-constructor\">Reject(<span class=\"hljs-params\">error</span>)</span>&#123;console.log(error) &#125;<br><br><span class=\"hljs-keyword\">let</span> xhr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">XMLHttpRequest()</span><br>xhr.ontimeout = <span class=\"hljs-keyword\">function</span>(e) &#123; on<span class=\"hljs-constructor\">Reject(<span class=\"hljs-params\">e</span>)</span>&#125;<br>xhr.onerror = <span class=\"hljs-keyword\">function</span>(e) &#123; on<span class=\"hljs-constructor\">Reject(<span class=\"hljs-params\">e</span>)</span> &#125;<br>xhr.onreadystatechange = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-literal\">()</span> &#123; on<span class=\"hljs-constructor\">Resolve(<span class=\"hljs-params\">xhr</span>.<span class=\"hljs-params\">response</span>)</span> &#125;<br><br><span class=\"hljs-comment\">// 设置请求类型，请求 URL，是否同步信息</span><br><span class=\"hljs-keyword\">let</span> URL = &#x27;https:<span class=\"hljs-comment\">//time.geekbang.com&#x27;</span><br>xhr.<span class=\"hljs-keyword\">open</span>(&#x27;Get&#x27;, URL, <span class=\"hljs-literal\">true</span>);<br><br><span class=\"hljs-comment\">// 设置参数</span><br>xhr.timeout = <span class=\"hljs-number\">3000</span> <span class=\"hljs-comment\">// 设置 xhr 请求的超时时间</span><br>xhr.responseType = <span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-comment\">// 设置响应返回的数据格式</span><br>xhr.set<span class=\"hljs-constructor\">RequestHeader(<span class=\"hljs-string\">&quot;X_TEST&quot;</span>,<span class=\"hljs-string\">&quot;time.geekbang&quot;</span>)</span><br><br><span class=\"hljs-comment\">// 发出请求</span><br>xhr.send<span class=\"hljs-literal\">()</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这一个网络请求多次使用了异步回调，使得代码逻辑显得不连贯和不线性。所以可以封装该请求使得符合我们的观看直觉。但即使封装之后也会出现低于回调的问题，这使得代码陷入一个非常混乱的局面，引入promise就可以很好解决低于回调的问题。（其实promise我也研究不是很透彻，包括后面的async await ，以后有时间仔细学习，这里就不细讲了）</p>\n<h3 id=\"5-2-async-await\"><a href=\"#5-2-async-await\" class=\"headerlink\" title=\"5.2 async await\"></a>5.2 async await</h3><p>即使promise能够解决异步回调编码风格问题使其看起来更能理解，但是过多的<u>then方法</u>依旧似乎有着语义化不明显的问题，所以<u>ES7</u>引入了<u>async await</u>很好解决了这个问题。async await使得异步回掉函数的写法和同步回调几乎一样，视觉上一目了然非常简介。</p>\n<p>async await其实背后的技术就是promise和生成器的应用。如下代码所示就是一个生成器的应用。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lua\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">genDemo</span><span class=\"hljs-params\">()</span></span> &#123;<br>    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot; 开始执行第一段 &quot;</span>)<br>    <span class=\"hljs-built_in\">yield</span> <span class=\"hljs-string\">&#x27;generator 2&#x27;</span><br><br>    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot; 开始执行第二段 &quot;</span>)<br>    <span class=\"hljs-built_in\">yield</span> <span class=\"hljs-string\">&#x27;generator 2&#x27;</span><br><br>    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot; 开始执行第三段 &quot;</span>)<br>    <span class=\"hljs-built_in\">yield</span> <span class=\"hljs-string\">&#x27;generator 2&#x27;</span><br><br>    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot; 执行结束 &quot;</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;generator 2&#x27;</span><br>&#125;<br><br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;main 0&#x27;</span>)<br>let gen = genDemo()<br>console.<span class=\"hljs-built_in\">log</span>(gen.<span class=\"hljs-built_in\">next</span>().value)<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;main 1&#x27;</span>)<br>console.<span class=\"hljs-built_in\">log</span>(gen.<span class=\"hljs-built_in\">next</span>().value)<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;main 2&#x27;</span>)<br>console.<span class=\"hljs-built_in\">log</span>(gen.<span class=\"hljs-built_in\">next</span>().value)<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;main 3&#x27;</span>)<br>console.<span class=\"hljs-built_in\">log</span>(gen.<span class=\"hljs-built_in\">next</span>().value)<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;main 4&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>执行这个函数观察输出结果可以发现genDemo并不是一次执行完成的，全局代码和genDemo代码交易执行，这就是<u>生成器函</u>数的特性。</p>\n<p>这里就涉及到了<u>协程</u>的概念，我们已经知道进程和线程的概念，一个进程里有多个线程，相类似的一个线程里也有多个协程，并且同一时间只能执行一个协程。如果从A协程启动了B协程，那么我们就将A协程称为B协程的<u>父协程</u>。如上代码就是执行在一个线程内的程序，但是它有两个协程，全局的父协程以及genDemo所对应的子协程。他们的连接和应用关系如下图所示。</p>\n<p><img src=\"/images/react/2022012404.png\"></p>\n<p>我们可以知道：第一、在生成器函数内部执行一段代码，如果遇到<u> yield </u>关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。外部函数可以通过<u> next</u> 方法恢复函数的执行。</p>\n<p>我们必须知道一个线程中的协程是<u>交互执行</u>而不是并发执行的，它们的切换是通过yield和gen.next来配合完成的。另外，当gen协程中调用了yied方法时，JavaScript引擎就会保留gen协程当前的<u>调用栈</u>信息，并恢复父协程的调用栈信息；同样当父协程中执行gen.next时也会保留父协程的调用栈信息而恢复gen协程的调用栈信息，可以参考下图所示。</p>\n<p><img src=\"/images/react/2022012405.png\"></p>\n"},{"_content":"浏览器安全\n\n主要分为三大块——web页面安全、浏览器网络安全、浏览器系统安全。\n\n如果Web页面没有安全策略，那么Web世界会是什么样子的？回收非常开放的，任何资源都可以直接进入，网站可以加载并执行其他网站的资源，这回产生信息泄露，恶意篡改数据等问题。针对这种情况，Web页面安全策略中的核心策略是同源策略。\n\n\n\n两个URL拥有相同的协议（HTTP OR HTTPS）、相同的域名、相同的端口，则这两个URL是同源的，如下所示：\n\n```\nhttps://time.geekbang.org/?category=1\nhttps://time.geekbang.org/?category=0\n```\n\n同源策略带来了极大安全性的同时也限制了Web的自由，为此引入了CSP策略，CSP的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联JavaScript代码。通过这些手段就可以大大减少 XSS 攻击。\n\n引入了跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。\n\nXSS攻击全称是Cross Site Scripting，翻译过来就是“跨站脚本”。黑客往HTML文件中或者DOM中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本来进行攻击。\n\nXSS攻击分为存储型XSS攻击，黑客通过站点漏洞将而已的JavaScript代码提交到网络数据库中，当用户请求含有该JavaScript脚本的页面时就会被进行攻击。反射型XSS工具，而已JavaScript脚本属于用户发送给网站请求中的一部分，随后网站又将而已JavaScript脚本返回给用户，当该脚本在用户页面被执行时就会受到攻击。另外需要注意的是，Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。基于DOM的XSS攻击。黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。\n\n如何组织XSS攻击\n\n1.服务器对输入脚本进行过滤或转码。\n\n2.充分利用CSP。\n\n3.使用HttpOnly属性。\n\n除了XSS攻击还有CSRF攻击\n\nCSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，**CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事**\n\n和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。\n\n发起CSRF攻击的三个必要条件：\n\n- 第一个，目标站点一定要有 CSRF 漏洞；\n- 第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；\n- 第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。\n\n具体的防范措施如下所示：\n\n1.充分利用好Cookie的SameSite属性\n\n2.验证请求的来源站点，由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。\n\n3.使用CSRF Token来验证和防范。\n","source":"_posts/浏览器安全问题.md","raw":"浏览器安全\n\n主要分为三大块——web页面安全、浏览器网络安全、浏览器系统安全。\n\n如果Web页面没有安全策略，那么Web世界会是什么样子的？回收非常开放的，任何资源都可以直接进入，网站可以加载并执行其他网站的资源，这回产生信息泄露，恶意篡改数据等问题。针对这种情况，Web页面安全策略中的核心策略是同源策略。\n\n\n\n两个URL拥有相同的协议（HTTP OR HTTPS）、相同的域名、相同的端口，则这两个URL是同源的，如下所示：\n\n```\nhttps://time.geekbang.org/?category=1\nhttps://time.geekbang.org/?category=0\n```\n\n同源策略带来了极大安全性的同时也限制了Web的自由，为此引入了CSP策略，CSP的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联JavaScript代码。通过这些手段就可以大大减少 XSS 攻击。\n\n引入了跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。\n\nXSS攻击全称是Cross Site Scripting，翻译过来就是“跨站脚本”。黑客往HTML文件中或者DOM中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本来进行攻击。\n\nXSS攻击分为存储型XSS攻击，黑客通过站点漏洞将而已的JavaScript代码提交到网络数据库中，当用户请求含有该JavaScript脚本的页面时就会被进行攻击。反射型XSS工具，而已JavaScript脚本属于用户发送给网站请求中的一部分，随后网站又将而已JavaScript脚本返回给用户，当该脚本在用户页面被执行时就会受到攻击。另外需要注意的是，Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。基于DOM的XSS攻击。黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。\n\n如何组织XSS攻击\n\n1.服务器对输入脚本进行过滤或转码。\n\n2.充分利用CSP。\n\n3.使用HttpOnly属性。\n\n除了XSS攻击还有CSRF攻击\n\nCSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，**CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事**\n\n和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。\n\n发起CSRF攻击的三个必要条件：\n\n- 第一个，目标站点一定要有 CSRF 漏洞；\n- 第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；\n- 第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。\n\n具体的防范措施如下所示：\n\n1.充分利用好Cookie的SameSite属性\n\n2.验证请求的来源站点，由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。\n\n3.使用CSRF Token来验证和防范。\n","slug":"浏览器安全问题","published":1,"date":"2022-02-22T03:04:39.113Z","updated":"2022-02-23T04:41:49.232Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh2h001v6wtv3cipfzph","content":"<p>浏览器安全</p>\n<p>主要分为三大块——web页面安全、浏览器网络安全、浏览器系统安全。</p>\n<p>如果Web页面没有安全策略，那么Web世界会是什么样子的？回收非常开放的，任何资源都可以直接进入，网站可以加载并执行其他网站的资源，这回产生信息泄露，恶意篡改数据等问题。针对这种情况，Web页面安全策略中的核心策略是同源策略。</p>\n<p>两个URL拥有相同的协议（HTTP OR HTTPS）、相同的域名、相同的端口，则这两个URL是同源的，如下所示：</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\"><span class=\"hljs-symbol\">https:</span>//time.geekbang<span class=\"hljs-meta\">.org</span>/?category=<span class=\"hljs-number\">1</span><br><span class=\"hljs-symbol\">https:</span>//time.geekbang<span class=\"hljs-meta\">.org</span>/?category=<span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n\n<p>同源策略带来了极大安全性的同时也限制了Web的自由，为此引入了CSP策略，CSP的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联JavaScript代码。通过这些手段就可以大大减少 XSS 攻击。</p>\n<p>引入了跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。</p>\n<p>XSS攻击全称是Cross Site Scripting，翻译过来就是“跨站脚本”。黑客往HTML文件中或者DOM中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本来进行攻击。</p>\n<p>XSS攻击分为存储型XSS攻击，黑客通过站点漏洞将而已的JavaScript代码提交到网络数据库中，当用户请求含有该JavaScript脚本的页面时就会被进行攻击。反射型XSS工具，而已JavaScript脚本属于用户发送给网站请求中的一部分，随后网站又将而已JavaScript脚本返回给用户，当该脚本在用户页面被执行时就会受到攻击。另外需要注意的是，Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。基于DOM的XSS攻击。黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。</p>\n<p>如何组织XSS攻击</p>\n<p>1.服务器对输入脚本进行过滤或转码。</p>\n<p>2.充分利用CSP。</p>\n<p>3.使用HttpOnly属性。</p>\n<p>除了XSS攻击还有CSRF攻击</p>\n<p>CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，<strong>CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事</strong></p>\n<p>和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</p>\n<p>发起CSRF攻击的三个必要条件：</p>\n<ul>\n<li>第一个，目标站点一定要有 CSRF 漏洞；</li>\n<li>第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；</li>\n<li>第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。</li>\n</ul>\n<p>具体的防范措施如下所示：</p>\n<p>1.充分利用好Cookie的SameSite属性</p>\n<p>2.验证请求的来源站点，由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。</p>\n<p>3.使用CSRF Token来验证和防范。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<p>浏览器安全</p>\n<p>主要分为三大块——web页面安全、浏览器网络安全、浏览器系统安全。</p>\n<p>如果Web页面没有安全策略，那么Web世界会是什么样子的？回收非常开放的，任何资源都可以直接进入，网站可以加载并执行其他网站的资源，这回产生信息泄露，恶意篡改数据等问题。针对这种情况，Web页面安全策略中的核心策略是同源策略。</p>\n<p>两个URL拥有相同的协议（HTTP OR HTTPS）、相同的域名、相同的端口，则这两个URL是同源的，如下所示：</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\"><span class=\"hljs-symbol\">https:</span>//time.geekbang<span class=\"hljs-meta\">.org</span>/?category=<span class=\"hljs-number\">1</span><br><span class=\"hljs-symbol\">https:</span>//time.geekbang<span class=\"hljs-meta\">.org</span>/?category=<span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n\n<p>同源策略带来了极大安全性的同时也限制了Web的自由，为此引入了CSP策略，CSP的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联JavaScript代码。通过这些手段就可以大大减少 XSS 攻击。</p>\n<p>引入了跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。</p>\n<p>XSS攻击全称是Cross Site Scripting，翻译过来就是“跨站脚本”。黑客往HTML文件中或者DOM中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本来进行攻击。</p>\n<p>XSS攻击分为存储型XSS攻击，黑客通过站点漏洞将而已的JavaScript代码提交到网络数据库中，当用户请求含有该JavaScript脚本的页面时就会被进行攻击。反射型XSS工具，而已JavaScript脚本属于用户发送给网站请求中的一部分，随后网站又将而已JavaScript脚本返回给用户，当该脚本在用户页面被执行时就会受到攻击。另外需要注意的是，Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。基于DOM的XSS攻击。黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。</p>\n<p>如何组织XSS攻击</p>\n<p>1.服务器对输入脚本进行过滤或转码。</p>\n<p>2.充分利用CSP。</p>\n<p>3.使用HttpOnly属性。</p>\n<p>除了XSS攻击还有CSRF攻击</p>\n<p>CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，<strong>CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事</strong></p>\n<p>和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</p>\n<p>发起CSRF攻击的三个必要条件：</p>\n<ul>\n<li>第一个，目标站点一定要有 CSRF 漏洞；</li>\n<li>第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；</li>\n<li>第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。</li>\n</ul>\n<p>具体的防范措施如下所示：</p>\n<p>1.充分利用好Cookie的SameSite属性</p>\n<p>2.验证请求的来源站点，由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。</p>\n<p>3.使用CSRF Token来验证和防范。</p>\n"},{"title":"虚无的日常","date":"2022-03-25T10:17:35.000Z","_content":"\n\n\nXXX，\n\n  傍晚好。你有陷入毕业焦虑吗。我不知道自己要什么。\n\n  其实我已经思考过了，我知道自己应该怎么走。只是还是会觉得虚无。\n\n  心情不好，我就不停地吃，不停地吃，不停地吃。\n\n  我的嘴巴是一个无法填满的洞，需要我不停地填满，我又想到了一种死法，是一种徒劳无获的填充，就像是精卫填海，最后疲倦而死。\n\n我不停地填充我的嘴，我不停填充我的欲望，我不停填充我内心的空洞。不停地，还没有等我的胃撕破，我就陷入一种疲惫的死亡。\n\n  我好空洞，我好虚无，我好迷茫。\n\n  我害怕被别人瞧不起，我害怕真正智慧的人鄙夷我的空洞，鄙夷我的虚无，鄙夷我的迷茫。\n\n  因为我不知道该怎么生活。我把什么东西都读的七零八碎的，拉康的精神分析说，我被社会的各种符号干扰，我失去了主动选择方向的能力，我用自由交换稳定，我在加强建构社会的符号体系。\n\n  一个选择自杀的人放弃生活和不知道怎么生活有区别吗？\n\n  《where reasons end》里的一段话。有时候我们放弃很多东西不就是因为我们不知道该如何和这些东西相处吗。\n\n  昨晚梦见了大学crush的女生。梦里我认真叫她的名字，XX。她的名字很好听。梦里我向她表白，梦里我们在一起了。她很瘦，很白净，下颌线很清晰，薄嘴唇，秀气的鼻子，声音很小只会让我觉得她很可爱。我基本没有和她单独在一起过，没有和她说过一句多余的话，事实上，我做出最有勇气的事情就是大三的时候主动找她组队，事实上，我基本不敢直视她，事实上，我坐在她身边都有点紧张。实际上，我非常喜欢她。\n\n  所以梦境的美好只能衬托出现实的懦弱。\n\n  我和树建立了一个精神上的良好连接。我们认识两年了，我们从来没有见过面，我们互相了解彼此，我对她说了很多很多，她对我说了很多很多。我们某种程度不需要见面，但是我们都期待见面。我很珍惜这段关系，有一天，我突然意识到我也会有嫉妒。嫉妒就代表着爱吧，即使这份爱是单纯而真挚的，知己之间的爱。可是知己这个词是否也过于亲密？有一天，我突然意识到她有她的生活，她的生活中有个很重要的真实的人，那个人是不可取代的，是能让她精神崩溃的，我一直知道那个人的存在，但是我们的交流里已经不怎么提她的存在。以至于我偶尔忘记了她，直到那一天，我突然被迫直视那个人的存在。然后我竟然有一种被压抑的嫉妒。原本是强烈的嫉妒，但是它被压抑了，因为我不能需要“强烈”。我嫉妒那个人与树之间强烈而深刻的连结，这似乎已经不是君子之交的友谊。可是我不能放肆自己去释放这种情感，只能被压抑，因为感情本来就是自私的，我不想在感情中做不平等交易。\n\n  前段日子给你写了信，后来读了后觉得写的很糟糕，我有点后悔发送。\n\n  祝好，我在思念你。\n","source":"_posts/虚无的日常.md","raw":"---\ntitle: 虚无的日常\ndate: 2022-03-25 18:17:35\ntags: 日记\n---\n\n\n\nXXX，\n\n  傍晚好。你有陷入毕业焦虑吗。我不知道自己要什么。\n\n  其实我已经思考过了，我知道自己应该怎么走。只是还是会觉得虚无。\n\n  心情不好，我就不停地吃，不停地吃，不停地吃。\n\n  我的嘴巴是一个无法填满的洞，需要我不停地填满，我又想到了一种死法，是一种徒劳无获的填充，就像是精卫填海，最后疲倦而死。\n\n我不停地填充我的嘴，我不停填充我的欲望，我不停填充我内心的空洞。不停地，还没有等我的胃撕破，我就陷入一种疲惫的死亡。\n\n  我好空洞，我好虚无，我好迷茫。\n\n  我害怕被别人瞧不起，我害怕真正智慧的人鄙夷我的空洞，鄙夷我的虚无，鄙夷我的迷茫。\n\n  因为我不知道该怎么生活。我把什么东西都读的七零八碎的，拉康的精神分析说，我被社会的各种符号干扰，我失去了主动选择方向的能力，我用自由交换稳定，我在加强建构社会的符号体系。\n\n  一个选择自杀的人放弃生活和不知道怎么生活有区别吗？\n\n  《where reasons end》里的一段话。有时候我们放弃很多东西不就是因为我们不知道该如何和这些东西相处吗。\n\n  昨晚梦见了大学crush的女生。梦里我认真叫她的名字，XX。她的名字很好听。梦里我向她表白，梦里我们在一起了。她很瘦，很白净，下颌线很清晰，薄嘴唇，秀气的鼻子，声音很小只会让我觉得她很可爱。我基本没有和她单独在一起过，没有和她说过一句多余的话，事实上，我做出最有勇气的事情就是大三的时候主动找她组队，事实上，我基本不敢直视她，事实上，我坐在她身边都有点紧张。实际上，我非常喜欢她。\n\n  所以梦境的美好只能衬托出现实的懦弱。\n\n  我和树建立了一个精神上的良好连接。我们认识两年了，我们从来没有见过面，我们互相了解彼此，我对她说了很多很多，她对我说了很多很多。我们某种程度不需要见面，但是我们都期待见面。我很珍惜这段关系，有一天，我突然意识到我也会有嫉妒。嫉妒就代表着爱吧，即使这份爱是单纯而真挚的，知己之间的爱。可是知己这个词是否也过于亲密？有一天，我突然意识到她有她的生活，她的生活中有个很重要的真实的人，那个人是不可取代的，是能让她精神崩溃的，我一直知道那个人的存在，但是我们的交流里已经不怎么提她的存在。以至于我偶尔忘记了她，直到那一天，我突然被迫直视那个人的存在。然后我竟然有一种被压抑的嫉妒。原本是强烈的嫉妒，但是它被压抑了，因为我不能需要“强烈”。我嫉妒那个人与树之间强烈而深刻的连结，这似乎已经不是君子之交的友谊。可是我不能放肆自己去释放这种情感，只能被压抑，因为感情本来就是自私的，我不想在感情中做不平等交易。\n\n  前段日子给你写了信，后来读了后觉得写的很糟糕，我有点后悔发送。\n\n  祝好，我在思念你。\n","slug":"虚无的日常","published":1,"updated":"2022-03-25T10:55:34.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh2m001z6wtv9zvu8kqk","content":"<p>XXX，</p>\n<p>  傍晚好。你有陷入毕业焦虑吗。我不知道自己要什么。</p>\n<p>  其实我已经思考过了，我知道自己应该怎么走。只是还是会觉得虚无。</p>\n<p>  心情不好，我就不停地吃，不停地吃，不停地吃。</p>\n<p>  我的嘴巴是一个无法填满的洞，需要我不停地填满，我又想到了一种死法，是一种徒劳无获的填充，就像是精卫填海，最后疲倦而死。</p>\n<p>我不停地填充我的嘴，我不停填充我的欲望，我不停填充我内心的空洞。不停地，还没有等我的胃撕破，我就陷入一种疲惫的死亡。</p>\n<p>  我好空洞，我好虚无，我好迷茫。</p>\n<p>  我害怕被别人瞧不起，我害怕真正智慧的人鄙夷我的空洞，鄙夷我的虚无，鄙夷我的迷茫。</p>\n<p>  因为我不知道该怎么生活。我把什么东西都读的七零八碎的，拉康的精神分析说，我被社会的各种符号干扰，我失去了主动选择方向的能力，我用自由交换稳定，我在加强建构社会的符号体系。</p>\n<p>  一个选择自杀的人放弃生活和不知道怎么生活有区别吗？</p>\n<p>  《where reasons end》里的一段话。有时候我们放弃很多东西不就是因为我们不知道该如何和这些东西相处吗。</p>\n<p>  昨晚梦见了大学crush的女生。梦里我认真叫她的名字，XX。她的名字很好听。梦里我向她表白，梦里我们在一起了。她很瘦，很白净，下颌线很清晰，薄嘴唇，秀气的鼻子，声音很小只会让我觉得她很可爱。我基本没有和她单独在一起过，没有和她说过一句多余的话，事实上，我做出最有勇气的事情就是大三的时候主动找她组队，事实上，我基本不敢直视她，事实上，我坐在她身边都有点紧张。实际上，我非常喜欢她。</p>\n<p>  所以梦境的美好只能衬托出现实的懦弱。</p>\n<p>  我和树建立了一个精神上的良好连接。我们认识两年了，我们从来没有见过面，我们互相了解彼此，我对她说了很多很多，她对我说了很多很多。我们某种程度不需要见面，但是我们都期待见面。我很珍惜这段关系，有一天，我突然意识到我也会有嫉妒。嫉妒就代表着爱吧，即使这份爱是单纯而真挚的，知己之间的爱。可是知己这个词是否也过于亲密？有一天，我突然意识到她有她的生活，她的生活中有个很重要的真实的人，那个人是不可取代的，是能让她精神崩溃的，我一直知道那个人的存在，但是我们的交流里已经不怎么提她的存在。以至于我偶尔忘记了她，直到那一天，我突然被迫直视那个人的存在。然后我竟然有一种被压抑的嫉妒。原本是强烈的嫉妒，但是它被压抑了，因为我不能需要“强烈”。我嫉妒那个人与树之间强烈而深刻的连结，这似乎已经不是君子之交的友谊。可是我不能放肆自己去释放这种情感，只能被压抑，因为感情本来就是自私的，我不想在感情中做不平等交易。</p>\n<p>  前段日子给你写了信，后来读了后觉得写的很糟糕，我有点后悔发送。</p>\n<p>  祝好，我在思念你。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<p>XXX，</p>\n<p>  傍晚好。你有陷入毕业焦虑吗。我不知道自己要什么。</p>\n<p>  其实我已经思考过了，我知道自己应该怎么走。只是还是会觉得虚无。</p>\n<p>  心情不好，我就不停地吃，不停地吃，不停地吃。</p>\n<p>  我的嘴巴是一个无法填满的洞，需要我不停地填满，我又想到了一种死法，是一种徒劳无获的填充，就像是精卫填海，最后疲倦而死。</p>\n<p>我不停地填充我的嘴，我不停填充我的欲望，我不停填充我内心的空洞。不停地，还没有等我的胃撕破，我就陷入一种疲惫的死亡。</p>\n<p>  我好空洞，我好虚无，我好迷茫。</p>\n<p>  我害怕被别人瞧不起，我害怕真正智慧的人鄙夷我的空洞，鄙夷我的虚无，鄙夷我的迷茫。</p>\n<p>  因为我不知道该怎么生活。我把什么东西都读的七零八碎的，拉康的精神分析说，我被社会的各种符号干扰，我失去了主动选择方向的能力，我用自由交换稳定，我在加强建构社会的符号体系。</p>\n<p>  一个选择自杀的人放弃生活和不知道怎么生活有区别吗？</p>\n<p>  《where reasons end》里的一段话。有时候我们放弃很多东西不就是因为我们不知道该如何和这些东西相处吗。</p>\n<p>  昨晚梦见了大学crush的女生。梦里我认真叫她的名字，XX。她的名字很好听。梦里我向她表白，梦里我们在一起了。她很瘦，很白净，下颌线很清晰，薄嘴唇，秀气的鼻子，声音很小只会让我觉得她很可爱。我基本没有和她单独在一起过，没有和她说过一句多余的话，事实上，我做出最有勇气的事情就是大三的时候主动找她组队，事实上，我基本不敢直视她，事实上，我坐在她身边都有点紧张。实际上，我非常喜欢她。</p>\n<p>  所以梦境的美好只能衬托出现实的懦弱。</p>\n<p>  我和树建立了一个精神上的良好连接。我们认识两年了，我们从来没有见过面，我们互相了解彼此，我对她说了很多很多，她对我说了很多很多。我们某种程度不需要见面，但是我们都期待见面。我很珍惜这段关系，有一天，我突然意识到我也会有嫉妒。嫉妒就代表着爱吧，即使这份爱是单纯而真挚的，知己之间的爱。可是知己这个词是否也过于亲密？有一天，我突然意识到她有她的生活，她的生活中有个很重要的真实的人，那个人是不可取代的，是能让她精神崩溃的，我一直知道那个人的存在，但是我们的交流里已经不怎么提她的存在。以至于我偶尔忘记了她，直到那一天，我突然被迫直视那个人的存在。然后我竟然有一种被压抑的嫉妒。原本是强烈的嫉妒，但是它被压抑了，因为我不能需要“强烈”。我嫉妒那个人与树之间强烈而深刻的连结，这似乎已经不是君子之交的友谊。可是我不能放肆自己去释放这种情感，只能被压抑，因为感情本来就是自私的，我不想在感情中做不平等交易。</p>\n<p>  前段日子给你写了信，后来读了后觉得写的很糟糕，我有点后悔发送。</p>\n<p>  祝好，我在思念你。</p>\n"},{"title":"计算机网络基础知识点","date":"2021-12-20T00:28:05.000Z","_content":"\n------\n\n*本文来源于https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。*\n\n------\n\n## 1.network、internet、Internet的区别\n\nnetwork是计算机的网络，把计算机主机连接起来（有很多种网络，包括局域网、广域网等），而internet则是把<u>广域网</u>的一种，是泛指，不一定采取TCP/IP协议；internet是网络的网络。Internet是全球最大最开放的internet，<u>采用TCP/IP协议</u>。\n\n## 2.ISP\n\nISP（Internet Service Provider 互联网服务提供商）在互联网<u>主干网上</u>提供相应服务使个体设备接入互联网。在中国比较热门的互联网提供商有移动、联通、电信等。\n\n## 3.主机之间通信方式\n\n**C/S 客户-服务器方式：**以服务器为核心提供客户资源\n\n**P2P 点对点方式：**双方对等、共享资源（比如迅雷下载）\n\n## 4.电路交换、分组交换\n\n**电路交换：**电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终<u>占用</u>该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。\n\n**分组交换：**每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换<u>不需要占用传输线路</u>。\n\n## 5.计算机网络体系结构\n\nOSI 国际标准的网络体系结构，共有七层，自下往上分别是<u>物理层、数据链路层、网络层、运输层、会话层、应用层</u>。\n\nTCP/IP协议是民间运用最广泛的网络协议，它简化了OSI协议，只有四层，自下往上是<u>网络接口层、网际层、运输层、应用层</u>。\n\n因为上面两个结构有层数太多或太少的问题，所以往往采取折中的方式即五层协议的体系架构，它自下往上分别是<u>物理层、数据链路层、网络层、运输层、应用层</u>。\n\n**物理层**：传输的是可以通过<u>物理介质</u>运输的数据比特流。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。\n\n**数据链路层**：物理寻址，同时将原始的比特流转变为<u>逻辑传输路线</u>。主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧，该层涉及到的协议有<u>以太网协议、点对点协议</u>。\n\n**网络层**：它通过路由选择算法，为分组通过通信子网选择最适当的路径，以实现网络的互连功能。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、流量控制、拥塞控制等将信息从一台网络设备传送到另一台网络设备。该层协议的代表包括<u>IP、IPX 协议</u>等。\n\n**运输层**：该层是通信子网和资源子网的接口和桥梁，起到了承上启下的作用。该层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时对数据进行分割然后将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此,运输层负责提供主机中<u>两个进程之间数据的可靠传送</u>。运输层的目的是向用户透明地传送报文，它向高层屏蔽了下层数据通信的细节。该层主要有两种协议：<u>TCP协议、UDP协议</u>。\n\n**会话层**：其主要任务是负责维护两个实体之间的会话连接确保点到点的传输不被中断，并进行会话管理和数据交换管理，即组织和协调两个会话进程之间的通信，并对数据交换进行管理。\n\n**表示层**：主要功能是协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异,，以使一个主机应用层的数据可以被另一个主机的应用层理解。\n\n**应用层**：用户应用程序和网络之间的接口，完成用户希望在网络上完成的各种工作。该层的协议有<u>HTTP、DNS协议</u>，数据单位为<u>报文</u>。\n\nTCP/IP协议相当于五层协议的下面两层合并成一层（网络接口层）。\n\n## 6.应用层\n\n**DNS：**域名解析，提供了主机名和IP地址相互转化的服务，域名的层次结构如下所示：\n\n![](/images/react/2021122001.png)\n\nDNS使用的端口是53，可以使用UDP或TCP协议，如果返回的响应超过512字节或者是区域传输则会使用TCP进行运输。\n\n**FTP：**使用TCP进行连接，需要两个连接（控制连接、数据连接）来传输一个文件。端口：20、21.有主动传输和被动传输两种模式。\n\n**DHCP：**动态主机配置协议.一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。\n\n电子邮件协议：一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。发送协议常用**SMTP**（只能发送ASCII码，MIMI扩充了SMTP，可以发送非ASCII码）、读取协议常用POP3（阅后即焚，最新版本可不焚）和IMAP。\n\n**常用端口：**如下图所示：\n\n![](/images/react/2021122002.png)\n\n须知0-1023是熟知端口，客服端生产的随机端口必须大于1024。\n\n## 7.传输层（报文）\n\n### 7.1 UDP和TCP的区别\n\nUDP 用户数据报协议，无连接，尽最大可能交付，没有拥塞控制，面对报文（应用层传下来的报文，只在其头部添加UDP首部），支持一对一、一对多、多对一、多对多的连接。\n\nTCP面向连接，提供可靠交付，有拥塞控制（TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复），提供全双工通信，面向字节流（应用层传下来的报文看成字节流，并拆分成数据块），连接一对一。\n\n### 7.2 UDP首部\n\nUDP的首部有8字节以及12字节的伪首部，伪首部是为了计算检验而临时添加，首部8字节包括2字节源端口和目的端口，2字节长度和检验和。以下为UDP首部示意图：\n\n![](/images/react/2021122003.png)\n\n### 7.3 TCP首部\n\nTCP首部长度不固定，有20字节的固定头部，具体情况如下图所示：\n\n![](/images/react/2021122004.png)\n\n序号：当前报文的序号，下一个报文的序号则为前一个报文的序号加上前一个报文的长度。\n\n确认号：因为TCP协议是可靠的一对一协议，所以当前报文发出时也要有希望接收到的下一个报文的序号，将接收到的下一个报文的序号则是前一个报文的确认号。\n\n数据偏移：实际就是TCP报文头部长度。\n\n确认位ACK：只有当ACK=1时确认号字段才有效。\n\n同步位SYN：建立连接时用来同步序号。SYN=1,ACK=0表示这是一个请求连接报文，SYN=1,ACK=1是同意连接的响应报文。\n\n终止位FIN：FIN=1表示释放一个连接。\n\n### 7.4 TCP的三次握手\n\n第一次握手：客服端向服务端发送请求报文，其中ACK=0,SYN=1。\n\n第二次握手：服务端返回客服端一个响应报文，其中SYN=1,ACK=1。\n\n第三次握手：客服端向服务端发送确认报文，其中SYN=0,ACK=1。\n\n三次握手成功建立连接。\n\n**需要三次握手的原因（面试题）：**\n\n三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。如果没有三次握手，会出现这种现象，客户端发送请求访问报文给服务端，但是这个报文在网络中受阻延迟没有及时传达到，而超时后客户端会再次发送请求报文给服务端，此时服务端就会收到并且要处理先后两条请求报文，有了三次握手，客户端会忽略服务器发送的第二条响应请求报文，不会进行第三次握手。\n\n### 7.5 TCP的四次挥手\n\n在客户端要关闭服务时需要和服务端进行四次挥手。\n\n第一次挥手：客户端向服务端发送释放请求报文，其中FIN=1\n\n第二次挥手：TCP处于半关闭状态，客户端无法再发送报文给服务端，服务端可以向客户端发送服务器端发送还未传送完毕的数据。\n\n第三次挥手：服务端向客户端发送释放报文，FIN=1\n\n第四次挥手：客户端向服务端发送确认报文，等待2MSL后释放应用。服务端收到确认报文后释放应用。\n\n**四次挥手的原因（面试题）：**\n\n客户端发送释放报文后，TCP处于半关闭状态，这个状态能让服务端继续发送未传送完毕的数据，数据传完后，服务器会发送释放报文。\n\n**四次挥手过程中TIME_WAIT的原因（面试题）：**\n\n在客户端收到服务端的FIN释放报文时回有2MSL（MSL 一个报文在网络中最大的存活时间）的等待时间，这是为了确保自己发送给服务端的确认报文能顺利传达，若出现意外则可以再次发送。也可让这段连续时间内产生的报文在网络中消失以避免干扰之后的连接请求。\n\n## 8.网络层（分组）\n\n网络层是整个互联网的核心，其中最关键的就是IP协议，其将异构的物理网络连接起来。与IP协议配套的还有地址解析协议ARP、网际控制报文协议ICMP、网际组管理协议IGMP。\n\n### 8.1 IP协议\n\n通过IP地址，保证了联网设备的唯一性，实现了网络通信的面向无连接和不可靠的传输功能。\n\nIP地址的偏执方式经历了三个历史阶段：分类、子网划分、无分类。\n\n**分类**：32位的IP地址根据网络号的长度（8、16、24位）分为A、B、C类地址以及多播地址D类、今后使用地址E类。具体几类地址的区别如下所示：\n\n![](/images/react/2021122005.png)\n\n**子网划分**：对于局域网内部的网络可进行子网划分，首先需要配置子网掩码。\n\n**无分类**：无分类编制CIDR消除了以上两种情况概念，使用网络前缀和主机号来对IP地址进行编码。如128.14.35.7/20 就是使用CIDR进行表示，其代表前 20 位为网络前缀。\n\n### 8.2 ARP协议\n\nARP协议实现了通过IP地址获得<u>MAC地址</u>。MAC地址是主机的硬件地址。每个主机都有一个<u>ARP高速缓存</u>，即IP地址到MAC地址的映射表。如果主机A没有主机B的MAC地址，只要获得其IP地址，通过广播的形式将访问信息发送给B，B 收到请求就将其MAC地址发送给A，这样A就可以通过ARP发送信息给B了。\n\n### 8.3 ICMP协议\n\nICMP协议是为了更有效地转发IP数据包，它被封装在IP数据报中，但不属于高层协议。<u>Ping</u>是ICNMP的一个重要应用，主要用来测试两台主机之间的连通性。\n\n### 8.4 虚拟专用网VPN\n\n因为实际的主机数要远远大于IP地址，并且也不需要把所有的主机接入到外部的互联网中，所以就有了专用地址，即机构内的计算机可使用仅在本机构有效的IP地址。VPN使用公用的互联网作为本机构各个专用网之间的通信载体，其功能是在公用网络上建立专用网络，进行加密通讯，即只要本机构的主机才能进行通讯。\n\n### 8.5 网络地址转换NAT\n\n专用网内部主机想要和互联网上的主机进行通讯时即要使用NAT进行IP地址的转换，把本地IP转为全球IP。\n\n### 8.6 路由选择协议\n\n内部路由选择协议有<u>RIP</u>和<u>OSPF</u>协议。RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。为了克服RIP的缺点而开发了OSPF协议，即开放最短路径优先。\n\n外部路由选择协议有<u>BGP</u>协议——边界网关协议。\n\n## 9.数据链路层（帧）\n\n### 9.1 基本问题\n\n**封装成帧**：链路层以帧的形式进行传输，需要将网络层的分组添加首部和尾部用于标记帧的开始和结束。\n\n**透明传输**：如果帧内部有首部或尾部相同的内容就容易错误定位帧的位置，所以需要在帧内部添加响应的<u>转义字符</u>以解决该问题。\n\n**差错检测**：目前使用最广泛的是<u>CRC</u>（循环冗余检验）来检查比特差错。\n\n### 9.2 信道分类\n\n分为广播信道和点对点信道，广播信道是一对多通信，采用<u>CSMA/CD协议</u>，表示载波监听多点接入/碰撞检测；点对点信道是一对一通信，采用<u>PPP协议</u>，这是一种用户计算机和 ISP 进行通信时所使用的数据链路层协议。\n\n### 9.3 信道复用技术\n\n包括频分复用、时分复用、波分复用、码分复用。\n\n### 9.4 局域网、以太网与虚拟局域网\n\n局域网是一种<u>广播信道</u>，以太网是<u>特殊的局域网</u>。局域网的特点为网络是一个单位所拥有，且地理位置和站点数目均有限。按照拓扑结构可将局域网分为<u>星型、环形、直线型</u>；以太网是一种星型局域网，早期使用集线器作为传输数据的物理设备，作用于比特而非帧，现在使用<u>交换机</u>，这是一种链路层设备。交换机具有学习功能，学习交换表的内容，交换表存储着MAC地址到接口的映射。<u>虚拟局域网</u>建立了与物理位置无关的逻辑组，只有在同一个虚拟局域网内的成员才能收到链路层广播信息。\n\n## 10.物理层\n\n### 10.1 通信方式\n\n根据信息的传输方向分为单工通信（单向传输）、半双工通信（双向交替传输）、全双工通信（双向同时传输）。\n\n### 10.2 带通调制\n\n带通调制将离散的数字信号转为连续的模拟信号。","source":"_posts/计算机网络复习.md","raw":"---\ntitle: 计算机网络基础知识点\ndate: 2021-12-20 08:28:05\ntags: [计算机网络, 学习,前端面试]\ncategories:\n- 计算机基础复习\n---\n\n------\n\n*本文来源于https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。*\n\n------\n\n## 1.network、internet、Internet的区别\n\nnetwork是计算机的网络，把计算机主机连接起来（有很多种网络，包括局域网、广域网等），而internet则是把<u>广域网</u>的一种，是泛指，不一定采取TCP/IP协议；internet是网络的网络。Internet是全球最大最开放的internet，<u>采用TCP/IP协议</u>。\n\n## 2.ISP\n\nISP（Internet Service Provider 互联网服务提供商）在互联网<u>主干网上</u>提供相应服务使个体设备接入互联网。在中国比较热门的互联网提供商有移动、联通、电信等。\n\n## 3.主机之间通信方式\n\n**C/S 客户-服务器方式：**以服务器为核心提供客户资源\n\n**P2P 点对点方式：**双方对等、共享资源（比如迅雷下载）\n\n## 4.电路交换、分组交换\n\n**电路交换：**电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终<u>占用</u>该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。\n\n**分组交换：**每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换<u>不需要占用传输线路</u>。\n\n## 5.计算机网络体系结构\n\nOSI 国际标准的网络体系结构，共有七层，自下往上分别是<u>物理层、数据链路层、网络层、运输层、会话层、应用层</u>。\n\nTCP/IP协议是民间运用最广泛的网络协议，它简化了OSI协议，只有四层，自下往上是<u>网络接口层、网际层、运输层、应用层</u>。\n\n因为上面两个结构有层数太多或太少的问题，所以往往采取折中的方式即五层协议的体系架构，它自下往上分别是<u>物理层、数据链路层、网络层、运输层、应用层</u>。\n\n**物理层**：传输的是可以通过<u>物理介质</u>运输的数据比特流。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。\n\n**数据链路层**：物理寻址，同时将原始的比特流转变为<u>逻辑传输路线</u>。主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧，该层涉及到的协议有<u>以太网协议、点对点协议</u>。\n\n**网络层**：它通过路由选择算法，为分组通过通信子网选择最适当的路径，以实现网络的互连功能。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、流量控制、拥塞控制等将信息从一台网络设备传送到另一台网络设备。该层协议的代表包括<u>IP、IPX 协议</u>等。\n\n**运输层**：该层是通信子网和资源子网的接口和桥梁，起到了承上启下的作用。该层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时对数据进行分割然后将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此,运输层负责提供主机中<u>两个进程之间数据的可靠传送</u>。运输层的目的是向用户透明地传送报文，它向高层屏蔽了下层数据通信的细节。该层主要有两种协议：<u>TCP协议、UDP协议</u>。\n\n**会话层**：其主要任务是负责维护两个实体之间的会话连接确保点到点的传输不被中断，并进行会话管理和数据交换管理，即组织和协调两个会话进程之间的通信，并对数据交换进行管理。\n\n**表示层**：主要功能是协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异,，以使一个主机应用层的数据可以被另一个主机的应用层理解。\n\n**应用层**：用户应用程序和网络之间的接口，完成用户希望在网络上完成的各种工作。该层的协议有<u>HTTP、DNS协议</u>，数据单位为<u>报文</u>。\n\nTCP/IP协议相当于五层协议的下面两层合并成一层（网络接口层）。\n\n## 6.应用层\n\n**DNS：**域名解析，提供了主机名和IP地址相互转化的服务，域名的层次结构如下所示：\n\n![](/images/react/2021122001.png)\n\nDNS使用的端口是53，可以使用UDP或TCP协议，如果返回的响应超过512字节或者是区域传输则会使用TCP进行运输。\n\n**FTP：**使用TCP进行连接，需要两个连接（控制连接、数据连接）来传输一个文件。端口：20、21.有主动传输和被动传输两种模式。\n\n**DHCP：**动态主机配置协议.一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。\n\n电子邮件协议：一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。发送协议常用**SMTP**（只能发送ASCII码，MIMI扩充了SMTP，可以发送非ASCII码）、读取协议常用POP3（阅后即焚，最新版本可不焚）和IMAP。\n\n**常用端口：**如下图所示：\n\n![](/images/react/2021122002.png)\n\n须知0-1023是熟知端口，客服端生产的随机端口必须大于1024。\n\n## 7.传输层（报文）\n\n### 7.1 UDP和TCP的区别\n\nUDP 用户数据报协议，无连接，尽最大可能交付，没有拥塞控制，面对报文（应用层传下来的报文，只在其头部添加UDP首部），支持一对一、一对多、多对一、多对多的连接。\n\nTCP面向连接，提供可靠交付，有拥塞控制（TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复），提供全双工通信，面向字节流（应用层传下来的报文看成字节流，并拆分成数据块），连接一对一。\n\n### 7.2 UDP首部\n\nUDP的首部有8字节以及12字节的伪首部，伪首部是为了计算检验而临时添加，首部8字节包括2字节源端口和目的端口，2字节长度和检验和。以下为UDP首部示意图：\n\n![](/images/react/2021122003.png)\n\n### 7.3 TCP首部\n\nTCP首部长度不固定，有20字节的固定头部，具体情况如下图所示：\n\n![](/images/react/2021122004.png)\n\n序号：当前报文的序号，下一个报文的序号则为前一个报文的序号加上前一个报文的长度。\n\n确认号：因为TCP协议是可靠的一对一协议，所以当前报文发出时也要有希望接收到的下一个报文的序号，将接收到的下一个报文的序号则是前一个报文的确认号。\n\n数据偏移：实际就是TCP报文头部长度。\n\n确认位ACK：只有当ACK=1时确认号字段才有效。\n\n同步位SYN：建立连接时用来同步序号。SYN=1,ACK=0表示这是一个请求连接报文，SYN=1,ACK=1是同意连接的响应报文。\n\n终止位FIN：FIN=1表示释放一个连接。\n\n### 7.4 TCP的三次握手\n\n第一次握手：客服端向服务端发送请求报文，其中ACK=0,SYN=1。\n\n第二次握手：服务端返回客服端一个响应报文，其中SYN=1,ACK=1。\n\n第三次握手：客服端向服务端发送确认报文，其中SYN=0,ACK=1。\n\n三次握手成功建立连接。\n\n**需要三次握手的原因（面试题）：**\n\n三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。如果没有三次握手，会出现这种现象，客户端发送请求访问报文给服务端，但是这个报文在网络中受阻延迟没有及时传达到，而超时后客户端会再次发送请求报文给服务端，此时服务端就会收到并且要处理先后两条请求报文，有了三次握手，客户端会忽略服务器发送的第二条响应请求报文，不会进行第三次握手。\n\n### 7.5 TCP的四次挥手\n\n在客户端要关闭服务时需要和服务端进行四次挥手。\n\n第一次挥手：客户端向服务端发送释放请求报文，其中FIN=1\n\n第二次挥手：TCP处于半关闭状态，客户端无法再发送报文给服务端，服务端可以向客户端发送服务器端发送还未传送完毕的数据。\n\n第三次挥手：服务端向客户端发送释放报文，FIN=1\n\n第四次挥手：客户端向服务端发送确认报文，等待2MSL后释放应用。服务端收到确认报文后释放应用。\n\n**四次挥手的原因（面试题）：**\n\n客户端发送释放报文后，TCP处于半关闭状态，这个状态能让服务端继续发送未传送完毕的数据，数据传完后，服务器会发送释放报文。\n\n**四次挥手过程中TIME_WAIT的原因（面试题）：**\n\n在客户端收到服务端的FIN释放报文时回有2MSL（MSL 一个报文在网络中最大的存活时间）的等待时间，这是为了确保自己发送给服务端的确认报文能顺利传达，若出现意外则可以再次发送。也可让这段连续时间内产生的报文在网络中消失以避免干扰之后的连接请求。\n\n## 8.网络层（分组）\n\n网络层是整个互联网的核心，其中最关键的就是IP协议，其将异构的物理网络连接起来。与IP协议配套的还有地址解析协议ARP、网际控制报文协议ICMP、网际组管理协议IGMP。\n\n### 8.1 IP协议\n\n通过IP地址，保证了联网设备的唯一性，实现了网络通信的面向无连接和不可靠的传输功能。\n\nIP地址的偏执方式经历了三个历史阶段：分类、子网划分、无分类。\n\n**分类**：32位的IP地址根据网络号的长度（8、16、24位）分为A、B、C类地址以及多播地址D类、今后使用地址E类。具体几类地址的区别如下所示：\n\n![](/images/react/2021122005.png)\n\n**子网划分**：对于局域网内部的网络可进行子网划分，首先需要配置子网掩码。\n\n**无分类**：无分类编制CIDR消除了以上两种情况概念，使用网络前缀和主机号来对IP地址进行编码。如128.14.35.7/20 就是使用CIDR进行表示，其代表前 20 位为网络前缀。\n\n### 8.2 ARP协议\n\nARP协议实现了通过IP地址获得<u>MAC地址</u>。MAC地址是主机的硬件地址。每个主机都有一个<u>ARP高速缓存</u>，即IP地址到MAC地址的映射表。如果主机A没有主机B的MAC地址，只要获得其IP地址，通过广播的形式将访问信息发送给B，B 收到请求就将其MAC地址发送给A，这样A就可以通过ARP发送信息给B了。\n\n### 8.3 ICMP协议\n\nICMP协议是为了更有效地转发IP数据包，它被封装在IP数据报中，但不属于高层协议。<u>Ping</u>是ICNMP的一个重要应用，主要用来测试两台主机之间的连通性。\n\n### 8.4 虚拟专用网VPN\n\n因为实际的主机数要远远大于IP地址，并且也不需要把所有的主机接入到外部的互联网中，所以就有了专用地址，即机构内的计算机可使用仅在本机构有效的IP地址。VPN使用公用的互联网作为本机构各个专用网之间的通信载体，其功能是在公用网络上建立专用网络，进行加密通讯，即只要本机构的主机才能进行通讯。\n\n### 8.5 网络地址转换NAT\n\n专用网内部主机想要和互联网上的主机进行通讯时即要使用NAT进行IP地址的转换，把本地IP转为全球IP。\n\n### 8.6 路由选择协议\n\n内部路由选择协议有<u>RIP</u>和<u>OSPF</u>协议。RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。为了克服RIP的缺点而开发了OSPF协议，即开放最短路径优先。\n\n外部路由选择协议有<u>BGP</u>协议——边界网关协议。\n\n## 9.数据链路层（帧）\n\n### 9.1 基本问题\n\n**封装成帧**：链路层以帧的形式进行传输，需要将网络层的分组添加首部和尾部用于标记帧的开始和结束。\n\n**透明传输**：如果帧内部有首部或尾部相同的内容就容易错误定位帧的位置，所以需要在帧内部添加响应的<u>转义字符</u>以解决该问题。\n\n**差错检测**：目前使用最广泛的是<u>CRC</u>（循环冗余检验）来检查比特差错。\n\n### 9.2 信道分类\n\n分为广播信道和点对点信道，广播信道是一对多通信，采用<u>CSMA/CD协议</u>，表示载波监听多点接入/碰撞检测；点对点信道是一对一通信，采用<u>PPP协议</u>，这是一种用户计算机和 ISP 进行通信时所使用的数据链路层协议。\n\n### 9.3 信道复用技术\n\n包括频分复用、时分复用、波分复用、码分复用。\n\n### 9.4 局域网、以太网与虚拟局域网\n\n局域网是一种<u>广播信道</u>，以太网是<u>特殊的局域网</u>。局域网的特点为网络是一个单位所拥有，且地理位置和站点数目均有限。按照拓扑结构可将局域网分为<u>星型、环形、直线型</u>；以太网是一种星型局域网，早期使用集线器作为传输数据的物理设备，作用于比特而非帧，现在使用<u>交换机</u>，这是一种链路层设备。交换机具有学习功能，学习交换表的内容，交换表存储着MAC地址到接口的映射。<u>虚拟局域网</u>建立了与物理位置无关的逻辑组，只有在同一个虚拟局域网内的成员才能收到链路层广播信息。\n\n## 10.物理层\n\n### 10.1 通信方式\n\n根据信息的传输方向分为单工通信（单向传输）、半双工通信（双向交替传输）、全双工通信（双向同时传输）。\n\n### 10.2 带通调制\n\n带通调制将离散的数字信号转为连续的模拟信号。","slug":"计算机网络复习","published":1,"updated":"2022-02-23T08:52:21.985Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh3800346wtv2n86hvgi","content":"<hr>\n<p><em>本文来源于<a href=\"https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82\">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。</a></em></p>\n<hr>\n<h2 id=\"1-network、internet、Internet的区别\"><a href=\"#1-network、internet、Internet的区别\" class=\"headerlink\" title=\"1.network、internet、Internet的区别\"></a>1.network、internet、Internet的区别</h2><p>network是计算机的网络，把计算机主机连接起来（有很多种网络，包括局域网、广域网等），而internet则是把<u>广域网</u>的一种，是泛指，不一定采取TCP/IP协议；internet是网络的网络。Internet是全球最大最开放的internet，<u>采用TCP/IP协议</u>。</p>\n<h2 id=\"2-ISP\"><a href=\"#2-ISP\" class=\"headerlink\" title=\"2.ISP\"></a>2.ISP</h2><p>ISP（Internet Service Provider 互联网服务提供商）在互联网<u>主干网上</u>提供相应服务使个体设备接入互联网。在中国比较热门的互联网提供商有移动、联通、电信等。</p>\n<h2 id=\"3-主机之间通信方式\"><a href=\"#3-主机之间通信方式\" class=\"headerlink\" title=\"3.主机之间通信方式\"></a>3.主机之间通信方式</h2><p><strong>C/S 客户-服务器方式：</strong>以服务器为核心提供客户资源</p>\n<p><strong>P2P 点对点方式：</strong>双方对等、共享资源（比如迅雷下载）</p>\n<h2 id=\"4-电路交换、分组交换\"><a href=\"#4-电路交换、分组交换\" class=\"headerlink\" title=\"4.电路交换、分组交换\"></a>4.电路交换、分组交换</h2><p><strong>电路交换：</strong>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终<u>占用</u>该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p>\n<p><strong>分组交换：</strong>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换<u>不需要占用传输线路</u>。</p>\n<h2 id=\"5-计算机网络体系结构\"><a href=\"#5-计算机网络体系结构\" class=\"headerlink\" title=\"5.计算机网络体系结构\"></a>5.计算机网络体系结构</h2><p>OSI 国际标准的网络体系结构，共有七层，自下往上分别是<u>物理层、数据链路层、网络层、运输层、会话层、应用层</u>。</p>\n<p>TCP/IP协议是民间运用最广泛的网络协议，它简化了OSI协议，只有四层，自下往上是<u>网络接口层、网际层、运输层、应用层</u>。</p>\n<p>因为上面两个结构有层数太多或太少的问题，所以往往采取折中的方式即五层协议的体系架构，它自下往上分别是<u>物理层、数据链路层、网络层、运输层、应用层</u>。</p>\n<p><strong>物理层</strong>：传输的是可以通过<u>物理介质</u>运输的数据比特流。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p>\n<p><strong>数据链路层</strong>：物理寻址，同时将原始的比特流转变为<u>逻辑传输路线</u>。主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧，该层涉及到的协议有<u>以太网协议、点对点协议</u>。</p>\n<p><strong>网络层</strong>：它通过路由选择算法，为分组通过通信子网选择最适当的路径，以实现网络的互连功能。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、流量控制、拥塞控制等将信息从一台网络设备传送到另一台网络设备。该层协议的代表包括<u>IP、IPX 协议</u>等。</p>\n<p><strong>运输层</strong>：该层是通信子网和资源子网的接口和桥梁，起到了承上启下的作用。该层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时对数据进行分割然后将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此,运输层负责提供主机中<u>两个进程之间数据的可靠传送</u>。运输层的目的是向用户透明地传送报文，它向高层屏蔽了下层数据通信的细节。该层主要有两种协议：<u>TCP协议、UDP协议</u>。</p>\n<p><strong>会话层</strong>：其主要任务是负责维护两个实体之间的会话连接确保点到点的传输不被中断，并进行会话管理和数据交换管理，即组织和协调两个会话进程之间的通信，并对数据交换进行管理。</p>\n<p><strong>表示层</strong>：主要功能是协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异,，以使一个主机应用层的数据可以被另一个主机的应用层理解。</p>\n<p><strong>应用层</strong>：用户应用程序和网络之间的接口，完成用户希望在网络上完成的各种工作。该层的协议有<u>HTTP、DNS协议</u>，数据单位为<u>报文</u>。</p>\n<p>TCP/IP协议相当于五层协议的下面两层合并成一层（网络接口层）。</p>\n<h2 id=\"6-应用层\"><a href=\"#6-应用层\" class=\"headerlink\" title=\"6.应用层\"></a>6.应用层</h2><p><strong>DNS：</strong>域名解析，提供了主机名和IP地址相互转化的服务，域名的层次结构如下所示：</p>\n<p><img src=\"/images/react/2021122001.png\"></p>\n<p>DNS使用的端口是53，可以使用UDP或TCP协议，如果返回的响应超过512字节或者是区域传输则会使用TCP进行运输。</p>\n<p><strong>FTP：</strong>使用TCP进行连接，需要两个连接（控制连接、数据连接）来传输一个文件。端口：20、21.有主动传输和被动传输两种模式。</p>\n<p><strong>DHCP：</strong>动态主机配置协议.一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。</p>\n<p>电子邮件协议：一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。发送协议常用<strong>SMTP</strong>（只能发送ASCII码，MIMI扩充了SMTP，可以发送非ASCII码）、读取协议常用POP3（阅后即焚，最新版本可不焚）和IMAP。</p>\n<p><strong>常用端口：</strong>如下图所示：</p>\n<p><img src=\"/images/react/2021122002.png\"></p>\n<p>须知0-1023是熟知端口，客服端生产的随机端口必须大于1024。</p>\n<h2 id=\"7-传输层（报文）\"><a href=\"#7-传输层（报文）\" class=\"headerlink\" title=\"7.传输层（报文）\"></a>7.传输层（报文）</h2><h3 id=\"7-1-UDP和TCP的区别\"><a href=\"#7-1-UDP和TCP的区别\" class=\"headerlink\" title=\"7.1 UDP和TCP的区别\"></a>7.1 UDP和TCP的区别</h3><p>UDP 用户数据报协议，无连接，尽最大可能交付，没有拥塞控制，面对报文（应用层传下来的报文，只在其头部添加UDP首部），支持一对一、一对多、多对一、多对多的连接。</p>\n<p>TCP面向连接，提供可靠交付，有拥塞控制（TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复），提供全双工通信，面向字节流（应用层传下来的报文看成字节流，并拆分成数据块），连接一对一。</p>\n<h3 id=\"7-2-UDP首部\"><a href=\"#7-2-UDP首部\" class=\"headerlink\" title=\"7.2 UDP首部\"></a>7.2 UDP首部</h3><p>UDP的首部有8字节以及12字节的伪首部，伪首部是为了计算检验而临时添加，首部8字节包括2字节源端口和目的端口，2字节长度和检验和。以下为UDP首部示意图：</p>\n<p><img src=\"/images/react/2021122003.png\"></p>\n<h3 id=\"7-3-TCP首部\"><a href=\"#7-3-TCP首部\" class=\"headerlink\" title=\"7.3 TCP首部\"></a>7.3 TCP首部</h3><p>TCP首部长度不固定，有20字节的固定头部，具体情况如下图所示：</p>\n<p><img src=\"/images/react/2021122004.png\"></p>\n<p>序号：当前报文的序号，下一个报文的序号则为前一个报文的序号加上前一个报文的长度。</p>\n<p>确认号：因为TCP协议是可靠的一对一协议，所以当前报文发出时也要有希望接收到的下一个报文的序号，将接收到的下一个报文的序号则是前一个报文的确认号。</p>\n<p>数据偏移：实际就是TCP报文头部长度。</p>\n<p>确认位ACK：只有当ACK=1时确认号字段才有效。</p>\n<p>同步位SYN：建立连接时用来同步序号。SYN=1,ACK=0表示这是一个请求连接报文，SYN=1,ACK=1是同意连接的响应报文。</p>\n<p>终止位FIN：FIN=1表示释放一个连接。</p>\n<h3 id=\"7-4-TCP的三次握手\"><a href=\"#7-4-TCP的三次握手\" class=\"headerlink\" title=\"7.4 TCP的三次握手\"></a>7.4 TCP的三次握手</h3><p>第一次握手：客服端向服务端发送请求报文，其中ACK=0,SYN=1。</p>\n<p>第二次握手：服务端返回客服端一个响应报文，其中SYN=1,ACK=1。</p>\n<p>第三次握手：客服端向服务端发送确认报文，其中SYN=0,ACK=1。</p>\n<p>三次握手成功建立连接。</p>\n<p><strong>需要三次握手的原因（面试题）：</strong></p>\n<p>三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。如果没有三次握手，会出现这种现象，客户端发送请求访问报文给服务端，但是这个报文在网络中受阻延迟没有及时传达到，而超时后客户端会再次发送请求报文给服务端，此时服务端就会收到并且要处理先后两条请求报文，有了三次握手，客户端会忽略服务器发送的第二条响应请求报文，不会进行第三次握手。</p>\n<h3 id=\"7-5-TCP的四次挥手\"><a href=\"#7-5-TCP的四次挥手\" class=\"headerlink\" title=\"7.5 TCP的四次挥手\"></a>7.5 TCP的四次挥手</h3><p>在客户端要关闭服务时需要和服务端进行四次挥手。</p>\n<p>第一次挥手：客户端向服务端发送释放请求报文，其中FIN=1</p>\n<p>第二次挥手：TCP处于半关闭状态，客户端无法再发送报文给服务端，服务端可以向客户端发送服务器端发送还未传送完毕的数据。</p>\n<p>第三次挥手：服务端向客户端发送释放报文，FIN=1</p>\n<p>第四次挥手：客户端向服务端发送确认报文，等待2MSL后释放应用。服务端收到确认报文后释放应用。</p>\n<p><strong>四次挥手的原因（面试题）：</strong></p>\n<p>客户端发送释放报文后，TCP处于半关闭状态，这个状态能让服务端继续发送未传送完毕的数据，数据传完后，服务器会发送释放报文。</p>\n<p><strong>四次挥手过程中TIME_WAIT的原因（面试题）：</strong></p>\n<p>在客户端收到服务端的FIN释放报文时回有2MSL（MSL 一个报文在网络中最大的存活时间）的等待时间，这是为了确保自己发送给服务端的确认报文能顺利传达，若出现意外则可以再次发送。也可让这段连续时间内产生的报文在网络中消失以避免干扰之后的连接请求。</p>\n<h2 id=\"8-网络层（分组）\"><a href=\"#8-网络层（分组）\" class=\"headerlink\" title=\"8.网络层（分组）\"></a>8.网络层（分组）</h2><p>网络层是整个互联网的核心，其中最关键的就是IP协议，其将异构的物理网络连接起来。与IP协议配套的还有地址解析协议ARP、网际控制报文协议ICMP、网际组管理协议IGMP。</p>\n<h3 id=\"8-1-IP协议\"><a href=\"#8-1-IP协议\" class=\"headerlink\" title=\"8.1 IP协议\"></a>8.1 IP协议</h3><p>通过IP地址，保证了联网设备的唯一性，实现了网络通信的面向无连接和不可靠的传输功能。</p>\n<p>IP地址的偏执方式经历了三个历史阶段：分类、子网划分、无分类。</p>\n<p><strong>分类</strong>：32位的IP地址根据网络号的长度（8、16、24位）分为A、B、C类地址以及多播地址D类、今后使用地址E类。具体几类地址的区别如下所示：</p>\n<p><img src=\"/images/react/2021122005.png\"></p>\n<p><strong>子网划分</strong>：对于局域网内部的网络可进行子网划分，首先需要配置子网掩码。</p>\n<p><strong>无分类</strong>：无分类编制CIDR消除了以上两种情况概念，使用网络前缀和主机号来对IP地址进行编码。如128.14.35.7/20 就是使用CIDR进行表示，其代表前 20 位为网络前缀。</p>\n<h3 id=\"8-2-ARP协议\"><a href=\"#8-2-ARP协议\" class=\"headerlink\" title=\"8.2 ARP协议\"></a>8.2 ARP协议</h3><p>ARP协议实现了通过IP地址获得<u>MAC地址</u>。MAC地址是主机的硬件地址。每个主机都有一个<u>ARP高速缓存</u>，即IP地址到MAC地址的映射表。如果主机A没有主机B的MAC地址，只要获得其IP地址，通过广播的形式将访问信息发送给B，B 收到请求就将其MAC地址发送给A，这样A就可以通过ARP发送信息给B了。</p>\n<h3 id=\"8-3-ICMP协议\"><a href=\"#8-3-ICMP协议\" class=\"headerlink\" title=\"8.3 ICMP协议\"></a>8.3 ICMP协议</h3><p>ICMP协议是为了更有效地转发IP数据包，它被封装在IP数据报中，但不属于高层协议。<u>Ping</u>是ICNMP的一个重要应用，主要用来测试两台主机之间的连通性。</p>\n<h3 id=\"8-4-虚拟专用网VPN\"><a href=\"#8-4-虚拟专用网VPN\" class=\"headerlink\" title=\"8.4 虚拟专用网VPN\"></a>8.4 虚拟专用网VPN</h3><p>因为实际的主机数要远远大于IP地址，并且也不需要把所有的主机接入到外部的互联网中，所以就有了专用地址，即机构内的计算机可使用仅在本机构有效的IP地址。VPN使用公用的互联网作为本机构各个专用网之间的通信载体，其功能是在公用网络上建立专用网络，进行加密通讯，即只要本机构的主机才能进行通讯。</p>\n<h3 id=\"8-5-网络地址转换NAT\"><a href=\"#8-5-网络地址转换NAT\" class=\"headerlink\" title=\"8.5 网络地址转换NAT\"></a>8.5 网络地址转换NAT</h3><p>专用网内部主机想要和互联网上的主机进行通讯时即要使用NAT进行IP地址的转换，把本地IP转为全球IP。</p>\n<h3 id=\"8-6-路由选择协议\"><a href=\"#8-6-路由选择协议\" class=\"headerlink\" title=\"8.6 路由选择协议\"></a>8.6 路由选择协议</h3><p>内部路由选择协议有<u>RIP</u>和<u>OSPF</u>协议。RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。为了克服RIP的缺点而开发了OSPF协议，即开放最短路径优先。</p>\n<p>外部路由选择协议有<u>BGP</u>协议——边界网关协议。</p>\n<h2 id=\"9-数据链路层（帧）\"><a href=\"#9-数据链路层（帧）\" class=\"headerlink\" title=\"9.数据链路层（帧）\"></a>9.数据链路层（帧）</h2><h3 id=\"9-1-基本问题\"><a href=\"#9-1-基本问题\" class=\"headerlink\" title=\"9.1 基本问题\"></a>9.1 基本问题</h3><p><strong>封装成帧</strong>：链路层以帧的形式进行传输，需要将网络层的分组添加首部和尾部用于标记帧的开始和结束。</p>\n<p><strong>透明传输</strong>：如果帧内部有首部或尾部相同的内容就容易错误定位帧的位置，所以需要在帧内部添加响应的<u>转义字符</u>以解决该问题。</p>\n<p><strong>差错检测</strong>：目前使用最广泛的是<u>CRC</u>（循环冗余检验）来检查比特差错。</p>\n<h3 id=\"9-2-信道分类\"><a href=\"#9-2-信道分类\" class=\"headerlink\" title=\"9.2 信道分类\"></a>9.2 信道分类</h3><p>分为广播信道和点对点信道，广播信道是一对多通信，采用<u>CSMA/CD协议</u>，表示载波监听多点接入/碰撞检测；点对点信道是一对一通信，采用<u>PPP协议</u>，这是一种用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p>\n<h3 id=\"9-3-信道复用技术\"><a href=\"#9-3-信道复用技术\" class=\"headerlink\" title=\"9.3 信道复用技术\"></a>9.3 信道复用技术</h3><p>包括频分复用、时分复用、波分复用、码分复用。</p>\n<h3 id=\"9-4-局域网、以太网与虚拟局域网\"><a href=\"#9-4-局域网、以太网与虚拟局域网\" class=\"headerlink\" title=\"9.4 局域网、以太网与虚拟局域网\"></a>9.4 局域网、以太网与虚拟局域网</h3><p>局域网是一种<u>广播信道</u>，以太网是<u>特殊的局域网</u>。局域网的特点为网络是一个单位所拥有，且地理位置和站点数目均有限。按照拓扑结构可将局域网分为<u>星型、环形、直线型</u>；以太网是一种星型局域网，早期使用集线器作为传输数据的物理设备，作用于比特而非帧，现在使用<u>交换机</u>，这是一种链路层设备。交换机具有学习功能，学习交换表的内容，交换表存储着MAC地址到接口的映射。<u>虚拟局域网</u>建立了与物理位置无关的逻辑组，只有在同一个虚拟局域网内的成员才能收到链路层广播信息。</p>\n<h2 id=\"10-物理层\"><a href=\"#10-物理层\" class=\"headerlink\" title=\"10.物理层\"></a>10.物理层</h2><h3 id=\"10-1-通信方式\"><a href=\"#10-1-通信方式\" class=\"headerlink\" title=\"10.1 通信方式\"></a>10.1 通信方式</h3><p>根据信息的传输方向分为单工通信（单向传输）、半双工通信（双向交替传输）、全双工通信（双向同时传输）。</p>\n<h3 id=\"10-2-带通调制\"><a href=\"#10-2-带通调制\" class=\"headerlink\" title=\"10.2 带通调制\"></a>10.2 带通调制</h3><p>带通调制将离散的数字信号转为连续的模拟信号。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>本文来源于<a href=\"https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82\">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。</a></em></p>\n<hr>\n<h2 id=\"1-network、internet、Internet的区别\"><a href=\"#1-network、internet、Internet的区别\" class=\"headerlink\" title=\"1.network、internet、Internet的区别\"></a>1.network、internet、Internet的区别</h2><p>network是计算机的网络，把计算机主机连接起来（有很多种网络，包括局域网、广域网等），而internet则是把<u>广域网</u>的一种，是泛指，不一定采取TCP/IP协议；internet是网络的网络。Internet是全球最大最开放的internet，<u>采用TCP/IP协议</u>。</p>\n<h2 id=\"2-ISP\"><a href=\"#2-ISP\" class=\"headerlink\" title=\"2.ISP\"></a>2.ISP</h2><p>ISP（Internet Service Provider 互联网服务提供商）在互联网<u>主干网上</u>提供相应服务使个体设备接入互联网。在中国比较热门的互联网提供商有移动、联通、电信等。</p>\n<h2 id=\"3-主机之间通信方式\"><a href=\"#3-主机之间通信方式\" class=\"headerlink\" title=\"3.主机之间通信方式\"></a>3.主机之间通信方式</h2><p><strong>C/S 客户-服务器方式：</strong>以服务器为核心提供客户资源</p>\n<p><strong>P2P 点对点方式：</strong>双方对等、共享资源（比如迅雷下载）</p>\n<h2 id=\"4-电路交换、分组交换\"><a href=\"#4-电路交换、分组交换\" class=\"headerlink\" title=\"4.电路交换、分组交换\"></a>4.电路交换、分组交换</h2><p><strong>电路交换：</strong>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终<u>占用</u>该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p>\n<p><strong>分组交换：</strong>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换<u>不需要占用传输线路</u>。</p>\n<h2 id=\"5-计算机网络体系结构\"><a href=\"#5-计算机网络体系结构\" class=\"headerlink\" title=\"5.计算机网络体系结构\"></a>5.计算机网络体系结构</h2><p>OSI 国际标准的网络体系结构，共有七层，自下往上分别是<u>物理层、数据链路层、网络层、运输层、会话层、应用层</u>。</p>\n<p>TCP/IP协议是民间运用最广泛的网络协议，它简化了OSI协议，只有四层，自下往上是<u>网络接口层、网际层、运输层、应用层</u>。</p>\n<p>因为上面两个结构有层数太多或太少的问题，所以往往采取折中的方式即五层协议的体系架构，它自下往上分别是<u>物理层、数据链路层、网络层、运输层、应用层</u>。</p>\n<p><strong>物理层</strong>：传输的是可以通过<u>物理介质</u>运输的数据比特流。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p>\n<p><strong>数据链路层</strong>：物理寻址，同时将原始的比特流转变为<u>逻辑传输路线</u>。主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧，该层涉及到的协议有<u>以太网协议、点对点协议</u>。</p>\n<p><strong>网络层</strong>：它通过路由选择算法，为分组通过通信子网选择最适当的路径，以实现网络的互连功能。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、流量控制、拥塞控制等将信息从一台网络设备传送到另一台网络设备。该层协议的代表包括<u>IP、IPX 协议</u>等。</p>\n<p><strong>运输层</strong>：该层是通信子网和资源子网的接口和桥梁，起到了承上启下的作用。该层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时对数据进行分割然后将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此,运输层负责提供主机中<u>两个进程之间数据的可靠传送</u>。运输层的目的是向用户透明地传送报文，它向高层屏蔽了下层数据通信的细节。该层主要有两种协议：<u>TCP协议、UDP协议</u>。</p>\n<p><strong>会话层</strong>：其主要任务是负责维护两个实体之间的会话连接确保点到点的传输不被中断，并进行会话管理和数据交换管理，即组织和协调两个会话进程之间的通信，并对数据交换进行管理。</p>\n<p><strong>表示层</strong>：主要功能是协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异,，以使一个主机应用层的数据可以被另一个主机的应用层理解。</p>\n<p><strong>应用层</strong>：用户应用程序和网络之间的接口，完成用户希望在网络上完成的各种工作。该层的协议有<u>HTTP、DNS协议</u>，数据单位为<u>报文</u>。</p>\n<p>TCP/IP协议相当于五层协议的下面两层合并成一层（网络接口层）。</p>\n<h2 id=\"6-应用层\"><a href=\"#6-应用层\" class=\"headerlink\" title=\"6.应用层\"></a>6.应用层</h2><p><strong>DNS：</strong>域名解析，提供了主机名和IP地址相互转化的服务，域名的层次结构如下所示：</p>\n<p><img src=\"/images/react/2021122001.png\"></p>\n<p>DNS使用的端口是53，可以使用UDP或TCP协议，如果返回的响应超过512字节或者是区域传输则会使用TCP进行运输。</p>\n<p><strong>FTP：</strong>使用TCP进行连接，需要两个连接（控制连接、数据连接）来传输一个文件。端口：20、21.有主动传输和被动传输两种模式。</p>\n<p><strong>DHCP：</strong>动态主机配置协议.一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。</p>\n<p>电子邮件协议：一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。发送协议常用<strong>SMTP</strong>（只能发送ASCII码，MIMI扩充了SMTP，可以发送非ASCII码）、读取协议常用POP3（阅后即焚，最新版本可不焚）和IMAP。</p>\n<p><strong>常用端口：</strong>如下图所示：</p>\n<p><img src=\"/images/react/2021122002.png\"></p>\n<p>须知0-1023是熟知端口，客服端生产的随机端口必须大于1024。</p>\n<h2 id=\"7-传输层（报文）\"><a href=\"#7-传输层（报文）\" class=\"headerlink\" title=\"7.传输层（报文）\"></a>7.传输层（报文）</h2><h3 id=\"7-1-UDP和TCP的区别\"><a href=\"#7-1-UDP和TCP的区别\" class=\"headerlink\" title=\"7.1 UDP和TCP的区别\"></a>7.1 UDP和TCP的区别</h3><p>UDP 用户数据报协议，无连接，尽最大可能交付，没有拥塞控制，面对报文（应用层传下来的报文，只在其头部添加UDP首部），支持一对一、一对多、多对一、多对多的连接。</p>\n<p>TCP面向连接，提供可靠交付，有拥塞控制（TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复），提供全双工通信，面向字节流（应用层传下来的报文看成字节流，并拆分成数据块），连接一对一。</p>\n<h3 id=\"7-2-UDP首部\"><a href=\"#7-2-UDP首部\" class=\"headerlink\" title=\"7.2 UDP首部\"></a>7.2 UDP首部</h3><p>UDP的首部有8字节以及12字节的伪首部，伪首部是为了计算检验而临时添加，首部8字节包括2字节源端口和目的端口，2字节长度和检验和。以下为UDP首部示意图：</p>\n<p><img src=\"/images/react/2021122003.png\"></p>\n<h3 id=\"7-3-TCP首部\"><a href=\"#7-3-TCP首部\" class=\"headerlink\" title=\"7.3 TCP首部\"></a>7.3 TCP首部</h3><p>TCP首部长度不固定，有20字节的固定头部，具体情况如下图所示：</p>\n<p><img src=\"/images/react/2021122004.png\"></p>\n<p>序号：当前报文的序号，下一个报文的序号则为前一个报文的序号加上前一个报文的长度。</p>\n<p>确认号：因为TCP协议是可靠的一对一协议，所以当前报文发出时也要有希望接收到的下一个报文的序号，将接收到的下一个报文的序号则是前一个报文的确认号。</p>\n<p>数据偏移：实际就是TCP报文头部长度。</p>\n<p>确认位ACK：只有当ACK=1时确认号字段才有效。</p>\n<p>同步位SYN：建立连接时用来同步序号。SYN=1,ACK=0表示这是一个请求连接报文，SYN=1,ACK=1是同意连接的响应报文。</p>\n<p>终止位FIN：FIN=1表示释放一个连接。</p>\n<h3 id=\"7-4-TCP的三次握手\"><a href=\"#7-4-TCP的三次握手\" class=\"headerlink\" title=\"7.4 TCP的三次握手\"></a>7.4 TCP的三次握手</h3><p>第一次握手：客服端向服务端发送请求报文，其中ACK=0,SYN=1。</p>\n<p>第二次握手：服务端返回客服端一个响应报文，其中SYN=1,ACK=1。</p>\n<p>第三次握手：客服端向服务端发送确认报文，其中SYN=0,ACK=1。</p>\n<p>三次握手成功建立连接。</p>\n<p><strong>需要三次握手的原因（面试题）：</strong></p>\n<p>三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。如果没有三次握手，会出现这种现象，客户端发送请求访问报文给服务端，但是这个报文在网络中受阻延迟没有及时传达到，而超时后客户端会再次发送请求报文给服务端，此时服务端就会收到并且要处理先后两条请求报文，有了三次握手，客户端会忽略服务器发送的第二条响应请求报文，不会进行第三次握手。</p>\n<h3 id=\"7-5-TCP的四次挥手\"><a href=\"#7-5-TCP的四次挥手\" class=\"headerlink\" title=\"7.5 TCP的四次挥手\"></a>7.5 TCP的四次挥手</h3><p>在客户端要关闭服务时需要和服务端进行四次挥手。</p>\n<p>第一次挥手：客户端向服务端发送释放请求报文，其中FIN=1</p>\n<p>第二次挥手：TCP处于半关闭状态，客户端无法再发送报文给服务端，服务端可以向客户端发送服务器端发送还未传送完毕的数据。</p>\n<p>第三次挥手：服务端向客户端发送释放报文，FIN=1</p>\n<p>第四次挥手：客户端向服务端发送确认报文，等待2MSL后释放应用。服务端收到确认报文后释放应用。</p>\n<p><strong>四次挥手的原因（面试题）：</strong></p>\n<p>客户端发送释放报文后，TCP处于半关闭状态，这个状态能让服务端继续发送未传送完毕的数据，数据传完后，服务器会发送释放报文。</p>\n<p><strong>四次挥手过程中TIME_WAIT的原因（面试题）：</strong></p>\n<p>在客户端收到服务端的FIN释放报文时回有2MSL（MSL 一个报文在网络中最大的存活时间）的等待时间，这是为了确保自己发送给服务端的确认报文能顺利传达，若出现意外则可以再次发送。也可让这段连续时间内产生的报文在网络中消失以避免干扰之后的连接请求。</p>\n<h2 id=\"8-网络层（分组）\"><a href=\"#8-网络层（分组）\" class=\"headerlink\" title=\"8.网络层（分组）\"></a>8.网络层（分组）</h2><p>网络层是整个互联网的核心，其中最关键的就是IP协议，其将异构的物理网络连接起来。与IP协议配套的还有地址解析协议ARP、网际控制报文协议ICMP、网际组管理协议IGMP。</p>\n<h3 id=\"8-1-IP协议\"><a href=\"#8-1-IP协议\" class=\"headerlink\" title=\"8.1 IP协议\"></a>8.1 IP协议</h3><p>通过IP地址，保证了联网设备的唯一性，实现了网络通信的面向无连接和不可靠的传输功能。</p>\n<p>IP地址的偏执方式经历了三个历史阶段：分类、子网划分、无分类。</p>\n<p><strong>分类</strong>：32位的IP地址根据网络号的长度（8、16、24位）分为A、B、C类地址以及多播地址D类、今后使用地址E类。具体几类地址的区别如下所示：</p>\n<p><img src=\"/images/react/2021122005.png\"></p>\n<p><strong>子网划分</strong>：对于局域网内部的网络可进行子网划分，首先需要配置子网掩码。</p>\n<p><strong>无分类</strong>：无分类编制CIDR消除了以上两种情况概念，使用网络前缀和主机号来对IP地址进行编码。如128.14.35.7/20 就是使用CIDR进行表示，其代表前 20 位为网络前缀。</p>\n<h3 id=\"8-2-ARP协议\"><a href=\"#8-2-ARP协议\" class=\"headerlink\" title=\"8.2 ARP协议\"></a>8.2 ARP协议</h3><p>ARP协议实现了通过IP地址获得<u>MAC地址</u>。MAC地址是主机的硬件地址。每个主机都有一个<u>ARP高速缓存</u>，即IP地址到MAC地址的映射表。如果主机A没有主机B的MAC地址，只要获得其IP地址，通过广播的形式将访问信息发送给B，B 收到请求就将其MAC地址发送给A，这样A就可以通过ARP发送信息给B了。</p>\n<h3 id=\"8-3-ICMP协议\"><a href=\"#8-3-ICMP协议\" class=\"headerlink\" title=\"8.3 ICMP协议\"></a>8.3 ICMP协议</h3><p>ICMP协议是为了更有效地转发IP数据包，它被封装在IP数据报中，但不属于高层协议。<u>Ping</u>是ICNMP的一个重要应用，主要用来测试两台主机之间的连通性。</p>\n<h3 id=\"8-4-虚拟专用网VPN\"><a href=\"#8-4-虚拟专用网VPN\" class=\"headerlink\" title=\"8.4 虚拟专用网VPN\"></a>8.4 虚拟专用网VPN</h3><p>因为实际的主机数要远远大于IP地址，并且也不需要把所有的主机接入到外部的互联网中，所以就有了专用地址，即机构内的计算机可使用仅在本机构有效的IP地址。VPN使用公用的互联网作为本机构各个专用网之间的通信载体，其功能是在公用网络上建立专用网络，进行加密通讯，即只要本机构的主机才能进行通讯。</p>\n<h3 id=\"8-5-网络地址转换NAT\"><a href=\"#8-5-网络地址转换NAT\" class=\"headerlink\" title=\"8.5 网络地址转换NAT\"></a>8.5 网络地址转换NAT</h3><p>专用网内部主机想要和互联网上的主机进行通讯时即要使用NAT进行IP地址的转换，把本地IP转为全球IP。</p>\n<h3 id=\"8-6-路由选择协议\"><a href=\"#8-6-路由选择协议\" class=\"headerlink\" title=\"8.6 路由选择协议\"></a>8.6 路由选择协议</h3><p>内部路由选择协议有<u>RIP</u>和<u>OSPF</u>协议。RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。为了克服RIP的缺点而开发了OSPF协议，即开放最短路径优先。</p>\n<p>外部路由选择协议有<u>BGP</u>协议——边界网关协议。</p>\n<h2 id=\"9-数据链路层（帧）\"><a href=\"#9-数据链路层（帧）\" class=\"headerlink\" title=\"9.数据链路层（帧）\"></a>9.数据链路层（帧）</h2><h3 id=\"9-1-基本问题\"><a href=\"#9-1-基本问题\" class=\"headerlink\" title=\"9.1 基本问题\"></a>9.1 基本问题</h3><p><strong>封装成帧</strong>：链路层以帧的形式进行传输，需要将网络层的分组添加首部和尾部用于标记帧的开始和结束。</p>\n<p><strong>透明传输</strong>：如果帧内部有首部或尾部相同的内容就容易错误定位帧的位置，所以需要在帧内部添加响应的<u>转义字符</u>以解决该问题。</p>\n<p><strong>差错检测</strong>：目前使用最广泛的是<u>CRC</u>（循环冗余检验）来检查比特差错。</p>\n<h3 id=\"9-2-信道分类\"><a href=\"#9-2-信道分类\" class=\"headerlink\" title=\"9.2 信道分类\"></a>9.2 信道分类</h3><p>分为广播信道和点对点信道，广播信道是一对多通信，采用<u>CSMA/CD协议</u>，表示载波监听多点接入/碰撞检测；点对点信道是一对一通信，采用<u>PPP协议</u>，这是一种用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p>\n<h3 id=\"9-3-信道复用技术\"><a href=\"#9-3-信道复用技术\" class=\"headerlink\" title=\"9.3 信道复用技术\"></a>9.3 信道复用技术</h3><p>包括频分复用、时分复用、波分复用、码分复用。</p>\n<h3 id=\"9-4-局域网、以太网与虚拟局域网\"><a href=\"#9-4-局域网、以太网与虚拟局域网\" class=\"headerlink\" title=\"9.4 局域网、以太网与虚拟局域网\"></a>9.4 局域网、以太网与虚拟局域网</h3><p>局域网是一种<u>广播信道</u>，以太网是<u>特殊的局域网</u>。局域网的特点为网络是一个单位所拥有，且地理位置和站点数目均有限。按照拓扑结构可将局域网分为<u>星型、环形、直线型</u>；以太网是一种星型局域网，早期使用集线器作为传输数据的物理设备，作用于比特而非帧，现在使用<u>交换机</u>，这是一种链路层设备。交换机具有学习功能，学习交换表的内容，交换表存储着MAC地址到接口的映射。<u>虚拟局域网</u>建立了与物理位置无关的逻辑组，只有在同一个虚拟局域网内的成员才能收到链路层广播信息。</p>\n<h2 id=\"10-物理层\"><a href=\"#10-物理层\" class=\"headerlink\" title=\"10.物理层\"></a>10.物理层</h2><h3 id=\"10-1-通信方式\"><a href=\"#10-1-通信方式\" class=\"headerlink\" title=\"10.1 通信方式\"></a>10.1 通信方式</h3><p>根据信息的传输方向分为单工通信（单向传输）、半双工通信（双向交替传输）、全双工通信（双向同时传输）。</p>\n<h3 id=\"10-2-带通调制\"><a href=\"#10-2-带通调制\" class=\"headerlink\" title=\"10.2 带通调制\"></a>10.2 带通调制</h3><p>带通调制将离散的数字信号转为连续的模拟信号。</p>\n"},{"title":"面向对象思想知识点","date":"2021-12-21T02:01:12.000Z","_content":"\n------\n\n*本文来源于https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过*。\n\n------\n\n## 1.三大特性\n\n**封装**：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。具有<u>减少耦合、减轻维护负担、提高软件可重用性</u>等特点。\n\n**继承**：继承实现了 <u>IS-A</u> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。\n\n**多态**：分为<u>编译时多态</u>和<u>运行时多态</u>。编译时多态主要指方法重载，运行时多态指程序中定义对象引用所指的具体类型在运行期间才确定。\n\n## 2.类图\n\n类图用来描述实体之间的关系，在类途中存在以下几种关系：\n\n**泛化关系**：用来描述<u>继承</u>关系，在 Java 中使用 extends 关键字，如下图所示。\n\n![](/images/2021122106.png)\n\n**实现关系**：用来实现一个<u>接口</u>，在 Java 中使用 implements 关键字，如下图所示。\n\n![](/images/2021122107.png)\n\n**聚合关系**：表示整体由部分组成，但是整体和部分<u>不是强依赖</u>的，整体不存在了部分还是会存在，如下图所示。\n\n![](/images/2021122108.png)\n\n**组合关系**：组合中整体和部分是<u>强依赖</u>的，整体不存在了部分也不存在了，如下图所示。\n\n![](/images/2021122109.png)\n\n**关联关系**：表示不同类对象之间有关联，这是一种<u>静态关系</u>，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示，如下图所示。\n\n![](/images/2021122110.png)\n\n**依赖关系**：依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：A 类是 B 类方法的局部变量；A 类是 B 类方法的参数；A 类向 B 类发送消息，从而影响 B 类发生变化，如下图所示。\n\n![](/images/2021122110.png)\n\n## 3.设计原则\n\n**S.O.L.I.D**：分别为单一责任原则、开放封闭原则、里氏替换原则、接口分离原则、依赖倒置原则。\n\n","source":"_posts/面向对象思想.md","raw":"---\ntitle: 面向对象思想知识点\ndate: 2021-12-21 10:01:12\ntags: [学习,前端面试，面向对象思想]\ncategories:\n- 计算机基础复习\n---\n\n------\n\n*本文来源于https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过*。\n\n------\n\n## 1.三大特性\n\n**封装**：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。具有<u>减少耦合、减轻维护负担、提高软件可重用性</u>等特点。\n\n**继承**：继承实现了 <u>IS-A</u> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。\n\n**多态**：分为<u>编译时多态</u>和<u>运行时多态</u>。编译时多态主要指方法重载，运行时多态指程序中定义对象引用所指的具体类型在运行期间才确定。\n\n## 2.类图\n\n类图用来描述实体之间的关系，在类途中存在以下几种关系：\n\n**泛化关系**：用来描述<u>继承</u>关系，在 Java 中使用 extends 关键字，如下图所示。\n\n![](/images/2021122106.png)\n\n**实现关系**：用来实现一个<u>接口</u>，在 Java 中使用 implements 关键字，如下图所示。\n\n![](/images/2021122107.png)\n\n**聚合关系**：表示整体由部分组成，但是整体和部分<u>不是强依赖</u>的，整体不存在了部分还是会存在，如下图所示。\n\n![](/images/2021122108.png)\n\n**组合关系**：组合中整体和部分是<u>强依赖</u>的，整体不存在了部分也不存在了，如下图所示。\n\n![](/images/2021122109.png)\n\n**关联关系**：表示不同类对象之间有关联，这是一种<u>静态关系</u>，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示，如下图所示。\n\n![](/images/2021122110.png)\n\n**依赖关系**：依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：A 类是 B 类方法的局部变量；A 类是 B 类方法的参数；A 类向 B 类发送消息，从而影响 B 类发生变化，如下图所示。\n\n![](/images/2021122110.png)\n\n## 3.设计原则\n\n**S.O.L.I.D**：分别为单一责任原则、开放封闭原则、里氏替换原则、接口分离原则、依赖倒置原则。\n\n","slug":"面向对象思想","published":1,"updated":"2021-12-21T12:24:14.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh3800356wtv941idi29","content":"<hr>\n<p><em>本文来源于<a href=\"https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82%E5%B9%B6%E4%B8%94%E5%9B%A0%E4%B8%BA%E6%9C%AC%E6%AC%A1%E5%A4%8D%E4%B9%A0%E6%98%AF%E4%BA%89%E5%AF%B9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E4%BC%9A%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%88%BB%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%AA%E4%BC%9A%E7%B2%97%E7%95%A5%E6%89%AB%E8%BF%87\">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过</a></em>。</p>\n<hr>\n<h2 id=\"1-三大特性\"><a href=\"#1-三大特性\" class=\"headerlink\" title=\"1.三大特性\"></a>1.三大特性</h2><p><strong>封装</strong>：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。具有<u>减少耦合、减轻维护负担、提高软件可重用性</u>等特点。</p>\n<p><strong>继承</strong>：继承实现了 <u>IS-A</u> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>\n<p><strong>多态</strong>：分为<u>编译时多态</u>和<u>运行时多态</u>。编译时多态主要指方法重载，运行时多态指程序中定义对象引用所指的具体类型在运行期间才确定。</p>\n<h2 id=\"2-类图\"><a href=\"#2-类图\" class=\"headerlink\" title=\"2.类图\"></a>2.类图</h2><p>类图用来描述实体之间的关系，在类途中存在以下几种关系：</p>\n<p><strong>泛化关系</strong>：用来描述<u>继承</u>关系，在 Java 中使用 extends 关键字，如下图所示。</p>\n<p><img src=\"/images/2021122106.png\"></p>\n<p><strong>实现关系</strong>：用来实现一个<u>接口</u>，在 Java 中使用 implements 关键字，如下图所示。</p>\n<p><img src=\"/images/2021122107.png\"></p>\n<p><strong>聚合关系</strong>：表示整体由部分组成，但是整体和部分<u>不是强依赖</u>的，整体不存在了部分还是会存在，如下图所示。</p>\n<p><img src=\"/images/2021122108.png\"></p>\n<p><strong>组合关系</strong>：组合中整体和部分是<u>强依赖</u>的，整体不存在了部分也不存在了，如下图所示。</p>\n<p><img src=\"/images/2021122109.png\"></p>\n<p><strong>关联关系</strong>：表示不同类对象之间有关联，这是一种<u>静态关系</u>，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示，如下图所示。</p>\n<p><img src=\"/images/2021122110.png\"></p>\n<p><strong>依赖关系</strong>：依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：A 类是 B 类方法的局部变量；A 类是 B 类方法的参数；A 类向 B 类发送消息，从而影响 B 类发生变化，如下图所示。</p>\n<p><img src=\"/images/2021122110.png\"></p>\n<h2 id=\"3-设计原则\"><a href=\"#3-设计原则\" class=\"headerlink\" title=\"3.设计原则\"></a>3.设计原则</h2><p><strong>S.O.L.I.D</strong>：分别为单一责任原则、开放封闭原则、里氏替换原则、接口分离原则、依赖倒置原则。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>本文来源于<a href=\"https://github.com/CyC2018/CS-Notes%EF%BC%8C%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E4%BD%86%E6%9C%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%8E%9F%E6%96%87%E4%B8%80%E8%87%B4%E3%80%82%E5%B9%B6%E4%B8%94%E5%9B%A0%E4%B8%BA%E6%9C%AC%E6%AC%A1%E5%A4%8D%E4%B9%A0%E6%98%AF%E4%BA%89%E5%AF%B9%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E4%BC%9A%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%8D%E4%B9%A0%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%88%BB%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%AA%E4%BC%9A%E7%B2%97%E7%95%A5%E6%89%AB%E8%BF%87\">https://github.com/CyC2018/CS-Notes，是在阅读该资源时的笔记整理，但有大部分的内容和原文一致。并且因为本次复习是争对前端面试的准备，所以也会选择性复习，对于深刻的，计算类知识点只会粗略扫过</a></em>。</p>\n<hr>\n<h2 id=\"1-三大特性\"><a href=\"#1-三大特性\" class=\"headerlink\" title=\"1.三大特性\"></a>1.三大特性</h2><p><strong>封装</strong>：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。具有<u>减少耦合、减轻维护负担、提高软件可重用性</u>等特点。</p>\n<p><strong>继承</strong>：继承实现了 <u>IS-A</u> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>\n<p><strong>多态</strong>：分为<u>编译时多态</u>和<u>运行时多态</u>。编译时多态主要指方法重载，运行时多态指程序中定义对象引用所指的具体类型在运行期间才确定。</p>\n<h2 id=\"2-类图\"><a href=\"#2-类图\" class=\"headerlink\" title=\"2.类图\"></a>2.类图</h2><p>类图用来描述实体之间的关系，在类途中存在以下几种关系：</p>\n<p><strong>泛化关系</strong>：用来描述<u>继承</u>关系，在 Java 中使用 extends 关键字，如下图所示。</p>\n<p><img src=\"/images/2021122106.png\"></p>\n<p><strong>实现关系</strong>：用来实现一个<u>接口</u>，在 Java 中使用 implements 关键字，如下图所示。</p>\n<p><img src=\"/images/2021122107.png\"></p>\n<p><strong>聚合关系</strong>：表示整体由部分组成，但是整体和部分<u>不是强依赖</u>的，整体不存在了部分还是会存在，如下图所示。</p>\n<p><img src=\"/images/2021122108.png\"></p>\n<p><strong>组合关系</strong>：组合中整体和部分是<u>强依赖</u>的，整体不存在了部分也不存在了，如下图所示。</p>\n<p><img src=\"/images/2021122109.png\"></p>\n<p><strong>关联关系</strong>：表示不同类对象之间有关联，这是一种<u>静态关系</u>，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示，如下图所示。</p>\n<p><img src=\"/images/2021122110.png\"></p>\n<p><strong>依赖关系</strong>：依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：A 类是 B 类方法的局部变量；A 类是 B 类方法的参数；A 类向 B 类发送消息，从而影响 B 类发生变化，如下图所示。</p>\n<p><img src=\"/images/2021122110.png\"></p>\n<h2 id=\"3-设计原则\"><a href=\"#3-设计原则\" class=\"headerlink\" title=\"3.设计原则\"></a>3.设计原则</h2><p><strong>S.O.L.I.D</strong>：分别为单一责任原则、开放封闭原则、里氏替换原则、接口分离原则、依赖倒置原则。</p>\n"},{"title":"浏览器中JavaScript执行机制","date":"2021-12-27T01:15:42.000Z","_content":"\n---\n\n*本文来源于[http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。](http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82)*\n\n---\n\n## 1.变量提升\n\n使用过JavaScipt的程序员都清除JavaScipt是按顺序执行的，不过看以下代码的输出结果，就会发现似乎并没有按'顺序'执行。\n\n```\nshowName()\nconsole.log(myname)\nvar myname = '极客时间'\nfunction showName() {\n    console.log('函数showName被执行');\n}\n```\n\n执行结果如下图所示：\n\n![](/images/react/2021122701.png)\n\n据图可知，在变量和函数进行声明之前就调用了它们，但是依旧能够执行。并且函数能够正常执行但是变量却是`underfined`。如果删掉变量声明，即上述代码的第三行，那么执行结果又会是什么呢？如下图所示，代码会报错。\n\n![](/images/react/2021122702.png)\n\n可见如果在下文定义了变量和函数，那么在上文中使用该变量和函数时不会报错，不过函数可以顺利输出结果，但是变量却是`underfined`，而如果在下文没有定义，则会报错。这种情况被称为<u>变量提升</u>。\n\n### 1.1 什么是变量提升\n\n首先先要了解<u>声明和赋值</u>的概念，对于下面这行代码：\n\n```\nvarname = 'name'\n```\n\n其实可以分为两个阶段，即变量的声明阶段和变量赋值阶段：\n\n```\nvar name = underfined\nname = 'name'\n```\n\n而争对函数可以看下段代码\n\n```\nfunction foo(){\n    console.log('foo')\n}//这个函数定义本身就是函数声明\n\nvar bar=function(){\n    console.log('bar')\n}\n//变量声明 var bar = underfined\n//变量赋值 var = function(){ ... }\n```\n\n可见对于函数来说，<u>函数声明</u>就是函数定义本身。\n\n变量提升就是在JavaScipt代码执行过程中，把变量和函数的声明部分提到代码开头的行为，对于变量声明会设置默认值即`underfined`。\n\n如下图所示，就是我们的第一段代码进行变量提升后造成的效果。\n\n```\n//先进行变量提升，即提取变量和函数的声明\nvar myname = underfined\nfunction showName(){\n    console.log('showName被调用')\n}\n\n//再是代码的可执行部分\nshowName()\nconsole.log(myname)\nmyname='极客时间'//去掉原来的var变量声明，变成变量赋值操作\n```\n\n上面就是变量提升带来的效果，其实一共就是两个步骤：1.提取变量和函数的声明放在代码顶部，对于变量声明进行`underfined`赋值。2.再执行代码可执行部分，对于原先的声明进行去除操作。\n\n### 1.2 Java代码的执行流程\n\n在了解什么是变量声明后，我们会以为变量声明的过程中是将代码的顺序进行改变的过程，但其实并不是，<u>实际上代码的位置并没有改变</u>，变量和函数声明的位置也没有变。JavaScipt的执行流程如下图所示：\n\n![](/images/react/2021122703.png)\n\n其中，变量提升的实现其实是在<u>编译阶段</u>实现的。输入一段代码，经过编译后会生成两部分内容：执行上下文和可执行代码。如下图所示：\n\n![](/images/react/2021122704.png)\n\n据图可知，在执行上下文中会保存代码的<u>环境变量</u>，其中就包括变量声明。\n\n```\nshowName()\nconsole.log(myname)\nvar myname = '极客时间'\nfunction showName() {\n    console.log('函数showName被执行');\n}\n```\n\n对于这段代码，编辑阶段的JavaScript引擎会对其进行分析处理，第1行第2行代码因为不是变量？函数声明则不进行处理，第3行是变量声明，于是JavaScipt引擎会在环境对象中创造一个myname的属性并初始化为`underfined`，第4行则是一个函数声明，JavaScript引擎会将函数定义存储岛堆中，并在环境对象中创建一个showName属性，将该属性指向堆中函数的位置。接下来JavaScipt会将声明以外的代码编译成字节码。这样就有了包含环境对象（变量声明）的执行上下文和可执行代码了。\n\n接下来就是进行执行阶段。在执行阶段，JavaScipt引擎是按照可执行代码的顺序一步一步执行的，争对上面这段代码的可执行部分就是：\n\n```\nshowName()\nconsole.log(myname)\nmyname='极客时间'\n```\n\n执行第1行时，JavaScript引擎会先在执行上下文的变量环境中寻找与此函数同名的属性，如果找到，就输出该属性的引用结果。\n\n执行第2行时，JavaScipt引擎同理在变量环境中查找`myname`属性，找到后就输出该属性值。\n\n执行第3行时，会将变量环境中的`myname`属性的值改为“极客时间”。\n\n以上就是变量提升在JavaScipt实际编译流程中的实现原理。\n\n3.代码中出现相同的变量/函数怎么办\n\n如下列代码所示：\n\n```\nfunction showName() {\n    console.log('极客邦');\n}\nshowName();\nfunction showName() {\n    console.log('极客时间');\n}\nshowName(); \n```\n\n实际上在编译阶段获取变量环境时就会将已有的showName属性在第一次定义后进行第二次修改，或者是覆盖第一次定义。所以实际运行时两个函数输出的结果是相同的，都是‘极客时间’。\n\n## 2.调用栈\n\n上面一节通过变量提升的概率了解了JavaScipt引擎的编译过程，接下来具体深入该过程，这一节了解的是调用栈这一概念。\n\n### 2.1 什么是函数调用\n\n函数调用就是运行一个函数，如下列代码所示：\n\n```\nvar a = 2\nfunction add(){\nvar b = 10\nreturn  a+b\n}\nadd()\n```\n\n其中`add()`就是一个函数调用。根据这段代码按照上一节所学的可以知道，再进行add函数调用前会创建<u>执行上下文</u>，其中包括了变量环境，但这就涉及到了全局变量和局部变量的问题，在函数内部定义的变量又是怎么进行执行上下文创建的呢。\n\n这就是一个顺序问题，首先获得这段JavaScript代码，JavaScript引擎会先创建一个<u>全局执行上下文</u>。在全局执行上下文中有变量环境如下所示：\n\n```\nVariableEnvironment：\n    a -> underfined,\n    add -> function: {\n    var b=10\n    return a+b\n}\n```\n\n搭建好全局的执行上写文后就进行全局的可执行代码执行，此时调用add函数，又要建立<u>函数内的执行上下文</u>，函数内的环境变量如下所示：\n\n```\nVariableEnvironment：\n    b -> underfined\n}\n```\n\n然后再执行函数内的可执行代码。具体的流程如下图所示：\n\n![](/images/react/2021122705.png)\n\n这其中就需要建立两个执行上下文，但JavaScript是怎么不把它们弄混的呢？这就涉及到了<u>栈</u>的概念。栈就是一种<u>先入后出</u>的结构。\n\n### 2.2 什么是JavaScript的调用栈\n\nJavaScript引擎就是利用栈的结构来管理执行上下文的，在执行上下文创建好后会将其压入栈中，这样的栈就叫做调用栈。\n\n看下面这段代码：\n\n```\nvar a = 2\nfunction add(b,c){\n  return b+c\n}\nfunction addAll(b,c){\nvar d = 10\nresult = add(b,c)\nreturn  a+result+d\n}\naddAll(3,6)\n```\n\n这段代码的执行过程为第一步，创建全局上下文，并将其压入栈底，如下图所示：\n\n![](/images/react/2021122706.png)\n\n然后执行全局代码。\n\n当运行到调用addAll函数时进行第二步，创建该函数的执行上下文，并将其压入栈中，如下图所示：\n\n![](/images/react/2021122707.png)\n\n之后就进入该函数代码的执行阶段。\n\n当执行到add函数的调用语句时就进行到第三步，为其创建执行上下文，并压入栈中，如下图所示：\n\n![](/images/react/2021122708.png)\n\n当ad函数返回时，调用栈会将顶部的执行上下文弹出，然后继续执行，直到返回到只剩下全局执行上下文为止。调用栈是JavaScript引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能追踪到哪个函数正在被执行以及各函数之间的调用关系。\n\n### 2.3 在开发中使用调用栈\n\n利用浏览器查看调用栈：比如打开Chrome的开发者工具，在Sources中打开页面，在相关的JavaScript上设置断点，并且刷新运行，然后在右侧的call stack中就可以看到调用栈。如下图所示。\n\n![](/images/react/2021122709.png)\n\n在call stack中最底层的(anonymous)就是全局执行上下文。\n\n使用`console.trace()`来输出当前函数的调用关系，如下段代码所示：\n\n```\nvar a = 2\nfunction add(b,c)\n{ console.trace()//输出当前函数的调用关系\n  return b+c\n}\nfunction addAll(b,c){\nvar d = 10\nresult = add(b,c)\nreturn  a+result+d\n}\naddAll(3,6)\n```\n\n上面代码的输出结果如下图所示。\n\n![](/images/react/2021122710.png)\n\n### 2.4 栈溢出\n\n需要知道的是调用栈是有大小的，所以当栈内的执行上下文数量超过一定值时，JavaScript引擎就会报错，这种情况就叫做<u>栈溢出</u>。\n\n如下段代码所示：\n\n```\nfunction division(a,b){\n    return division(a,b)\n}\nconsole.log(division(1,2))\n```\n\n执行后会出下如图所示报错：\n\n![](/images/react/2021122711.png)\n\n解决栈溢出的问题是<u>尽量避免回调函数的方法</u>，可以使用循环语句来代替回调函数。\n\n如下端代码所示：\n\n```\nfunction runStack (n) {\n  if (n === 0) return 100;\n  return runStack( n- 2);\n}\nrunStack(50000)\n//这段代码就会产生栈溢出的问题，可以进行以下优化\n\n\n// 优化\nfunction runStack(n) {\n    while (true) {\n        if (n === 0) {\n            return 100;\n        }\n\n        if (n === 1) { // 防止陷入死循环\n            return 200;\n        }\n\n        n = n - 2;\n    }\n}\n\nconsole.log(runStack(50000));\n```\n\n上面这段代码的优化就是使用了while循环来代替了递归函数。\n\n## 3.块级作用域\n\n在上面两节中提到了JavaScript的变量提升现象，这会造成很多误解问题，为了解决这种缺陷ES6引入了<u>let和cons</u>t来解决。let&const使用块级作用域来解决了这个问题。\n\n### 3.1 作用域\n\n作用域就是变量能够访问的范围，JavaScript只有两种作用域：<u>全局作用域、函数作用域</u>。而其他许多语言则还有<u>块级作用域</u>，即用`{}`包围的区间就可以称为一个块级作用域，比如在Java中以下代码都是块级作用域：\n\n```\n//if块\nif(1){}\n\n//while块\nwhile(1){}\n\n//函数块\nfunction foo(){\n\n//for循环块\nfor(let i = 0; i<100; i++){}\n\n//单独一个块\n{}\n```\n\n### 3.2 ES6中的let和const\n\n因为JavaScript的最初设计理念比较简单，所以它存在很多由于没有块级作用域带来的问题，为了解决这些问题，ES6引用了let和const关键字，让其也能像其他语言一样拥有块级作用域。\n\nlet和const分别是定义变量和常量的关键字，如下列代码所示，使用这两个关键字就能够使用块级作用域。\n\n```\nfunction letTest() {\n  let x = 1;\n  if (true) {\n    let x = 2;  // 不同的变量\n    console.log(x);  // 2\n  }\n  console.log(x);  // 1\n}\n```\n\n如果使用var，则两个输出的都是2 。\n\n### 3.3 JavaScript如何支持块级作用域\n\n我们已知JavaScript实现变量提升的原理，那它又是怎么在此基础上又可以实现支持块级作用域的呢？看以下代码来进行解释分析。\n\n```\nfunction foo(){\n    var a = 1\n    let b = 2\n    {\n      let b = 3\n      var c = 4\n      let d = 5\n      console.log(a)\n      console.log(b)\n    }\n    console.log(b) \n    console.log(c)\n    console.log(d)\n}   \nfoo()\n```\n\n当进入这个foo函数时，会创建该函数的执行上下文，首先会将所有的var变量定义存储在执行上下文的变量环境中，同时将属于函数作用域的let or const 变量存储在执行上下文的词法环境中，如图所示。\n\n![](/images/react/2022011001.png)\n\n此时该函数的执行上下文环境已经定义完成，就需要使用JavaScript引擎执行代码，当执行到函数内部的第一个块级作用域`{}`时，foo函数的执行上下文如图所示。\n\n![](/images/react/2022011002.png)\n\n此时var变量a和let变量b已经被赋值。而由于进入了let的作用域，而在词法环境中创建了一个新栈，存储该块级作用域中的变量。\n\n之后当执行到块级作用域中的`console.log(a)`时，JavaScript引擎就会按照以下步骤来搜索变量。\n\n![](/images/react/2022011003.png)\n\n当执行完块级作用域时，词法环境中相应区间就会从栈顶弹出，如图所示。\n\n![](/images/react/2022011004.png)\n\n如下截图所示为改代码的输出结果。\n\n![](/images/react/2022011005.png)\n\n最后因为块级作用域所占内存已经销毁，所以找不到该let变量。\n\n### 3.4 思考题\n\n观察以下代码的输出结果。\n\n```\nlet myname= '极客时间'\n{\n  console.log(myname) \n  let myname= '极客邦'\n}\n```\n\n会出现以下报错。\n\n![](/images/react/2022011006.png)\n\n因为在块级作用域中，从`开始到let myname= '极客邦'`代码之间会形成一个暂时性死区，如果中间去访问变量`myname`，会报初始化之前不能访问`myname`的错误。\n\n## 4.作用域链和闭包\n\n### 4.1 作用域链\n\n当涉及到多个作用域中访问变量的情况就要提到作用域链。像以下代码。\n\n```\nfunction bar() {\n    console.log(myName)\n}\nfunction foo() {\n    var myName = \" 极客邦 \"\n    bar()\n}\nvar myName = \" 极客时间 \"\nfoo()\n```\n\n该代码在bar函数中会输出myName的值，根据上面几节所学，该代码会生成以下的执行上下文调用栈。\n\n![](/images/react/2022011007.png)\n\n在执行代码阶段，bar函数的执行上下文中没有的变量myName应该在哪里找呢，这里其实每一个执行上下文的环境变量中都有一个称为`outer`的外部引用，当该作用域中没有需要的变量，则会向`outer`指向的作用域中去查找。那么bar函数的`outer`会指向哪里呢？如下图所示为各个执行上下文的变量环境outer的指向。\n\n![](/images/react/2022011008.png)\n\n为什么bar函数的outer指向的不是foo函数而是全局呢？这就涉及到<u>函数声明的位置</u>。函数声明的位置觉得了该函数的outer指向，根据该定理观察该代码，可以看出bar和foo函数的声明位置都是在全局，所以它们的outer指向也都是全局。如果bar函数在foo函数内部定义，则它的outer会指向foo函数。这涉及到了<u>词法作用域</u>。\n\n词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。\n\n如下图所示。\n\n![](/images/react/2022011009.png)\n\n该图所示的词法作用域链顺序是：foo 函数作用域—>bar 函数作用域—>main 函数作用域—> 全局作用域。\n\n### 4.2 块级作用域中的变量查找\n\n观察以下代码：\n\n```\nfunction bar() {\n    var myName = \" 极客世界 \"\n    let test1 = 100\n    if (1) {\n        let myName = \"Chrome 浏览器 \"\n        console.log(test)\n    }\n}\nfunction foo() {\n    var myName = \" 极客邦 \"\n    let test = 2\n    {\n        let test = 3\n        bar()\n    }\n}\nvar myName = \" 极客时间 \"\nlet myAge = 10\nlet test = 1\nfoo()\n```\n\n分析其调用栈结构如下图所示：\n\n![](/images/react/2022011010.png)\n\n图中标出的顺序就是其查找变量的顺序。\n\n### 4.3 闭包\n\n观察以下代码：\n\n```\nfunction foo() {\n    var myName = \" 极客时间 \"\n    let test1 = 1\n    const test2 = 2\n    var innerBar = {\n        getName:function(){\n            console.log(test1)\n            return myName\n        },\n        setName:function(newName){\n            myName = newName\n        }\n    }\n    return innerBar\n}\nvar bar = foo()\nbar.setName(\" 极客邦 \")\nbar.getName()\nconsole.log(bar.getName())\n```\n\n其中，当执行代码时，会运行函数foo，也就会生成foo的执行上下文，但是执行完后foo的执行上下文就会在<u>内存中销毁</u>。但是在后面两行中却调用了foo的内部方法setName和getName，而这两个方法则使用了其外部函数foo函数的变量，此时变量myName和test1不会被销毁，而变成了<u>专属</u>`bar.setName`和`bar.getName`方法能使用的变量，这种情况就可以把这些只能够被特定函数访问的变量集合称之为<u>闭包</u>。\n\n![](/images/react/2022011011.png)\n\n那这些闭包是如何使用的呢？如下图所示：\n\n![](/images/react/2022011012.png)\n\n据图可知其执行顺序为setName函数执行上下文->该函数的闭包->全局执行上下文。\n\n也可以利用浏览器中的开发者工具来跟踪其查找变量顺序，如图所示。\n\n![](/images/react/2022011013.png)\n\n### 4.4 闭包回收\n\n如果引用闭包的函数是全局变量，那么该闭包就会一直存在直到页面关闭，如果引用闭包的函数是局部变量，那么该闭包会随着函数的销毁而销毁。所以使用闭包需要注意：<u>当闭包会一直使用则定义其函数为全局变量，否则就定义为局部变量。</u>\n\n### 4.5 思考题\n\n观察下面代码，其输出结果是什么，会形成闭包吗？\n\n```\nvar bar = {\n    myName:\"time.geekbang.com\",\n    printName: function () {\n        console.log(myName)\n    }    \n}\nfunction foo() {\n    let myName = \" 极客时间 \"\n    return bar.printName\n}\nlet myName = \" 极客邦 \"\nlet _printName = foo()\n_printName()\nbar.printName()\n```\n\n这道题其实是个障眼法，只需要确定好函数调用栈就可以很轻松的解答，调用了foo()后，返回的是bar.printName，后续就跟foo函数没有关系了，所以结果就是调用了两次bar.printName()，根据词法作用域，<u>结果都是“极客邦”，也不会形成闭包</u>。\n\n如下图所示。\n\n![](/images/react/2022011014.png)\n\n（其实我也有点糊涂了。）\n\n## 5.this\n\n### 5.1 JavaScript中的this是什么？\n\nthis其实和执行上下文有关，执行上下文一共有三种，分别是<u>全局执行上下文、函数执行上下文和eval执行上下文</u>。每个执行上下文中都包括我们已经知道的变量环节、词法环境以及outer。除此之外，this也包含在执行上下文中。所以根据不同的执行上下文，this也有所不同。\n\n### 5.2 全局执行上下文中的this\n\n直接在浏览器的开发者工具控制台中输入`console.log(this)`，可以看到输出的是window对象，因此可知，<u>全局执行上下文中的this指向window对象</u>，这也是this和作用域链的唯一交点，作用域链最底端包含了window对象。\n\n### 5.3 函数执行上下文中的this\n\n观察以下这段代码：\n\n```\nfunction foo(){\n  console.log(this)\n}\nfoo()\n```\n\n观察输出结果会发现，这个this依旧是指向window。那么可以改变函数内的this指向吗？可以的，有以下几种方法。\n\n**1.通过函数的call方法设置**\n\n如下列代码所示：\n\n```\nlet bar = {\n  myName : \" 极客邦 \",\n  test1 : 1\n}\nfunction foo(){\n  this.myName = \" 极客时间 \"\n}\nfoo.call(bar)\nconsole.log(bar)\nconsole.log(myName)\n```\n\n通过`foo.call(bar)`使得foo函数执行上下文中的this指向了bar。除了<u>call方法</u>，也可以使用<u>bind和apply方法</u>来设置函数执行上下文中的this。\n\n**2.通过对象调用方法设置**\n\n如下代码所示：\n\n```\nvar myObj = {\n  name : \" 极客时间 \", \n  showThis: function(){\n    console.log(this)\n  }\n}\nmyObj.showThis()\n```\n\n当执行`myObj.showThis()`时就会使得`showThis`中的`this`指向`myObj`对象。\n\n**3.通过构造函数中设置**\n\n如下代码所示：\n\n```\nfunction CreateObj(){\n  this.name = \" 极客时间 \"\n}\nvar myObj = new CreateObj()\n```\n\n使用`new`关键字来使函数中的this指向了新对象本身。\n\n### 5.3 this的涉及缺陷以及应对方案\n\n比方说嵌套函数中的this<u>没有继承关系</u>，如段代码所示：\n\n```\nvar myObj = {\n  name : \" 极客时间 \", \n  showThis: function(){\n    console.log(this)\n    function bar(){console.log(this)}\n    bar()\n  }\n}\nmyObj.showThis()\n```\n\n直觉上我们会以为bar函数内部的this也是指向showThis也就是它的外部函数，但其实它指向的是window，解决方法有两种，第一种是在bar函数外使用`var that=this`，在bar函数内使用that就代指showThis中的this，如下代码所示：\n\n```\nvar myObj = {\n  name : \" 极客时间 \", \n  showThis: function(){\n    console.log(this)\n    var that = this\n    function bar(){\n      that.name = \" 极客邦 \"\n    }\n    bar()\n  }\n}\nmyObj.showThis()\nconsole.log(myObj.name)\nconsole.log(window.name)\n```\n\n第二个方法是使用ES6中的<u>箭头函数</u>来声明bar函数，如下段代码所示：\n\n```\nvar myObj = {\n  name : \" 极客时间 \", \n  showThis: function(){\n    console.log(this)\n    var bar = ()=>{\n      this.name = \" 极客邦 \"\n      console.log(this)\n    }\n    bar()\n  }\n}\nmyObj.showThis()\nconsole.log(myObj.name)\nconsole.log(window.name)\n```\n\n因为箭头函数不会创建自身的执行上下文。\n","source":"_posts/浏览器中JavaScript执行机制.md","raw":"---\ntitle: 浏览器中JavaScript执行机制\ndate: 2021-12-27 09:15:42\ntags: [浏览器, JavaScript, 前端面试]\ncategories:\n- 浏览器\n---\n\n---\n\n*本文来源于[http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。](http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82)*\n\n---\n\n## 1.变量提升\n\n使用过JavaScipt的程序员都清除JavaScipt是按顺序执行的，不过看以下代码的输出结果，就会发现似乎并没有按'顺序'执行。\n\n```\nshowName()\nconsole.log(myname)\nvar myname = '极客时间'\nfunction showName() {\n    console.log('函数showName被执行');\n}\n```\n\n执行结果如下图所示：\n\n![](/images/react/2021122701.png)\n\n据图可知，在变量和函数进行声明之前就调用了它们，但是依旧能够执行。并且函数能够正常执行但是变量却是`underfined`。如果删掉变量声明，即上述代码的第三行，那么执行结果又会是什么呢？如下图所示，代码会报错。\n\n![](/images/react/2021122702.png)\n\n可见如果在下文定义了变量和函数，那么在上文中使用该变量和函数时不会报错，不过函数可以顺利输出结果，但是变量却是`underfined`，而如果在下文没有定义，则会报错。这种情况被称为<u>变量提升</u>。\n\n### 1.1 什么是变量提升\n\n首先先要了解<u>声明和赋值</u>的概念，对于下面这行代码：\n\n```\nvarname = 'name'\n```\n\n其实可以分为两个阶段，即变量的声明阶段和变量赋值阶段：\n\n```\nvar name = underfined\nname = 'name'\n```\n\n而争对函数可以看下段代码\n\n```\nfunction foo(){\n    console.log('foo')\n}//这个函数定义本身就是函数声明\n\nvar bar=function(){\n    console.log('bar')\n}\n//变量声明 var bar = underfined\n//变量赋值 var = function(){ ... }\n```\n\n可见对于函数来说，<u>函数声明</u>就是函数定义本身。\n\n变量提升就是在JavaScipt代码执行过程中，把变量和函数的声明部分提到代码开头的行为，对于变量声明会设置默认值即`underfined`。\n\n如下图所示，就是我们的第一段代码进行变量提升后造成的效果。\n\n```\n//先进行变量提升，即提取变量和函数的声明\nvar myname = underfined\nfunction showName(){\n    console.log('showName被调用')\n}\n\n//再是代码的可执行部分\nshowName()\nconsole.log(myname)\nmyname='极客时间'//去掉原来的var变量声明，变成变量赋值操作\n```\n\n上面就是变量提升带来的效果，其实一共就是两个步骤：1.提取变量和函数的声明放在代码顶部，对于变量声明进行`underfined`赋值。2.再执行代码可执行部分，对于原先的声明进行去除操作。\n\n### 1.2 Java代码的执行流程\n\n在了解什么是变量声明后，我们会以为变量声明的过程中是将代码的顺序进行改变的过程，但其实并不是，<u>实际上代码的位置并没有改变</u>，变量和函数声明的位置也没有变。JavaScipt的执行流程如下图所示：\n\n![](/images/react/2021122703.png)\n\n其中，变量提升的实现其实是在<u>编译阶段</u>实现的。输入一段代码，经过编译后会生成两部分内容：执行上下文和可执行代码。如下图所示：\n\n![](/images/react/2021122704.png)\n\n据图可知，在执行上下文中会保存代码的<u>环境变量</u>，其中就包括变量声明。\n\n```\nshowName()\nconsole.log(myname)\nvar myname = '极客时间'\nfunction showName() {\n    console.log('函数showName被执行');\n}\n```\n\n对于这段代码，编辑阶段的JavaScript引擎会对其进行分析处理，第1行第2行代码因为不是变量？函数声明则不进行处理，第3行是变量声明，于是JavaScipt引擎会在环境对象中创造一个myname的属性并初始化为`underfined`，第4行则是一个函数声明，JavaScript引擎会将函数定义存储岛堆中，并在环境对象中创建一个showName属性，将该属性指向堆中函数的位置。接下来JavaScipt会将声明以外的代码编译成字节码。这样就有了包含环境对象（变量声明）的执行上下文和可执行代码了。\n\n接下来就是进行执行阶段。在执行阶段，JavaScipt引擎是按照可执行代码的顺序一步一步执行的，争对上面这段代码的可执行部分就是：\n\n```\nshowName()\nconsole.log(myname)\nmyname='极客时间'\n```\n\n执行第1行时，JavaScript引擎会先在执行上下文的变量环境中寻找与此函数同名的属性，如果找到，就输出该属性的引用结果。\n\n执行第2行时，JavaScipt引擎同理在变量环境中查找`myname`属性，找到后就输出该属性值。\n\n执行第3行时，会将变量环境中的`myname`属性的值改为“极客时间”。\n\n以上就是变量提升在JavaScipt实际编译流程中的实现原理。\n\n3.代码中出现相同的变量/函数怎么办\n\n如下列代码所示：\n\n```\nfunction showName() {\n    console.log('极客邦');\n}\nshowName();\nfunction showName() {\n    console.log('极客时间');\n}\nshowName(); \n```\n\n实际上在编译阶段获取变量环境时就会将已有的showName属性在第一次定义后进行第二次修改，或者是覆盖第一次定义。所以实际运行时两个函数输出的结果是相同的，都是‘极客时间’。\n\n## 2.调用栈\n\n上面一节通过变量提升的概率了解了JavaScipt引擎的编译过程，接下来具体深入该过程，这一节了解的是调用栈这一概念。\n\n### 2.1 什么是函数调用\n\n函数调用就是运行一个函数，如下列代码所示：\n\n```\nvar a = 2\nfunction add(){\nvar b = 10\nreturn  a+b\n}\nadd()\n```\n\n其中`add()`就是一个函数调用。根据这段代码按照上一节所学的可以知道，再进行add函数调用前会创建<u>执行上下文</u>，其中包括了变量环境，但这就涉及到了全局变量和局部变量的问题，在函数内部定义的变量又是怎么进行执行上下文创建的呢。\n\n这就是一个顺序问题，首先获得这段JavaScript代码，JavaScript引擎会先创建一个<u>全局执行上下文</u>。在全局执行上下文中有变量环境如下所示：\n\n```\nVariableEnvironment：\n    a -> underfined,\n    add -> function: {\n    var b=10\n    return a+b\n}\n```\n\n搭建好全局的执行上写文后就进行全局的可执行代码执行，此时调用add函数，又要建立<u>函数内的执行上下文</u>，函数内的环境变量如下所示：\n\n```\nVariableEnvironment：\n    b -> underfined\n}\n```\n\n然后再执行函数内的可执行代码。具体的流程如下图所示：\n\n![](/images/react/2021122705.png)\n\n这其中就需要建立两个执行上下文，但JavaScript是怎么不把它们弄混的呢？这就涉及到了<u>栈</u>的概念。栈就是一种<u>先入后出</u>的结构。\n\n### 2.2 什么是JavaScript的调用栈\n\nJavaScript引擎就是利用栈的结构来管理执行上下文的，在执行上下文创建好后会将其压入栈中，这样的栈就叫做调用栈。\n\n看下面这段代码：\n\n```\nvar a = 2\nfunction add(b,c){\n  return b+c\n}\nfunction addAll(b,c){\nvar d = 10\nresult = add(b,c)\nreturn  a+result+d\n}\naddAll(3,6)\n```\n\n这段代码的执行过程为第一步，创建全局上下文，并将其压入栈底，如下图所示：\n\n![](/images/react/2021122706.png)\n\n然后执行全局代码。\n\n当运行到调用addAll函数时进行第二步，创建该函数的执行上下文，并将其压入栈中，如下图所示：\n\n![](/images/react/2021122707.png)\n\n之后就进入该函数代码的执行阶段。\n\n当执行到add函数的调用语句时就进行到第三步，为其创建执行上下文，并压入栈中，如下图所示：\n\n![](/images/react/2021122708.png)\n\n当ad函数返回时，调用栈会将顶部的执行上下文弹出，然后继续执行，直到返回到只剩下全局执行上下文为止。调用栈是JavaScript引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能追踪到哪个函数正在被执行以及各函数之间的调用关系。\n\n### 2.3 在开发中使用调用栈\n\n利用浏览器查看调用栈：比如打开Chrome的开发者工具，在Sources中打开页面，在相关的JavaScript上设置断点，并且刷新运行，然后在右侧的call stack中就可以看到调用栈。如下图所示。\n\n![](/images/react/2021122709.png)\n\n在call stack中最底层的(anonymous)就是全局执行上下文。\n\n使用`console.trace()`来输出当前函数的调用关系，如下段代码所示：\n\n```\nvar a = 2\nfunction add(b,c)\n{ console.trace()//输出当前函数的调用关系\n  return b+c\n}\nfunction addAll(b,c){\nvar d = 10\nresult = add(b,c)\nreturn  a+result+d\n}\naddAll(3,6)\n```\n\n上面代码的输出结果如下图所示。\n\n![](/images/react/2021122710.png)\n\n### 2.4 栈溢出\n\n需要知道的是调用栈是有大小的，所以当栈内的执行上下文数量超过一定值时，JavaScript引擎就会报错，这种情况就叫做<u>栈溢出</u>。\n\n如下段代码所示：\n\n```\nfunction division(a,b){\n    return division(a,b)\n}\nconsole.log(division(1,2))\n```\n\n执行后会出下如图所示报错：\n\n![](/images/react/2021122711.png)\n\n解决栈溢出的问题是<u>尽量避免回调函数的方法</u>，可以使用循环语句来代替回调函数。\n\n如下端代码所示：\n\n```\nfunction runStack (n) {\n  if (n === 0) return 100;\n  return runStack( n- 2);\n}\nrunStack(50000)\n//这段代码就会产生栈溢出的问题，可以进行以下优化\n\n\n// 优化\nfunction runStack(n) {\n    while (true) {\n        if (n === 0) {\n            return 100;\n        }\n\n        if (n === 1) { // 防止陷入死循环\n            return 200;\n        }\n\n        n = n - 2;\n    }\n}\n\nconsole.log(runStack(50000));\n```\n\n上面这段代码的优化就是使用了while循环来代替了递归函数。\n\n## 3.块级作用域\n\n在上面两节中提到了JavaScript的变量提升现象，这会造成很多误解问题，为了解决这种缺陷ES6引入了<u>let和cons</u>t来解决。let&const使用块级作用域来解决了这个问题。\n\n### 3.1 作用域\n\n作用域就是变量能够访问的范围，JavaScript只有两种作用域：<u>全局作用域、函数作用域</u>。而其他许多语言则还有<u>块级作用域</u>，即用`{}`包围的区间就可以称为一个块级作用域，比如在Java中以下代码都是块级作用域：\n\n```\n//if块\nif(1){}\n\n//while块\nwhile(1){}\n\n//函数块\nfunction foo(){\n\n//for循环块\nfor(let i = 0; i<100; i++){}\n\n//单独一个块\n{}\n```\n\n### 3.2 ES6中的let和const\n\n因为JavaScript的最初设计理念比较简单，所以它存在很多由于没有块级作用域带来的问题，为了解决这些问题，ES6引用了let和const关键字，让其也能像其他语言一样拥有块级作用域。\n\nlet和const分别是定义变量和常量的关键字，如下列代码所示，使用这两个关键字就能够使用块级作用域。\n\n```\nfunction letTest() {\n  let x = 1;\n  if (true) {\n    let x = 2;  // 不同的变量\n    console.log(x);  // 2\n  }\n  console.log(x);  // 1\n}\n```\n\n如果使用var，则两个输出的都是2 。\n\n### 3.3 JavaScript如何支持块级作用域\n\n我们已知JavaScript实现变量提升的原理，那它又是怎么在此基础上又可以实现支持块级作用域的呢？看以下代码来进行解释分析。\n\n```\nfunction foo(){\n    var a = 1\n    let b = 2\n    {\n      let b = 3\n      var c = 4\n      let d = 5\n      console.log(a)\n      console.log(b)\n    }\n    console.log(b) \n    console.log(c)\n    console.log(d)\n}   \nfoo()\n```\n\n当进入这个foo函数时，会创建该函数的执行上下文，首先会将所有的var变量定义存储在执行上下文的变量环境中，同时将属于函数作用域的let or const 变量存储在执行上下文的词法环境中，如图所示。\n\n![](/images/react/2022011001.png)\n\n此时该函数的执行上下文环境已经定义完成，就需要使用JavaScript引擎执行代码，当执行到函数内部的第一个块级作用域`{}`时，foo函数的执行上下文如图所示。\n\n![](/images/react/2022011002.png)\n\n此时var变量a和let变量b已经被赋值。而由于进入了let的作用域，而在词法环境中创建了一个新栈，存储该块级作用域中的变量。\n\n之后当执行到块级作用域中的`console.log(a)`时，JavaScript引擎就会按照以下步骤来搜索变量。\n\n![](/images/react/2022011003.png)\n\n当执行完块级作用域时，词法环境中相应区间就会从栈顶弹出，如图所示。\n\n![](/images/react/2022011004.png)\n\n如下截图所示为改代码的输出结果。\n\n![](/images/react/2022011005.png)\n\n最后因为块级作用域所占内存已经销毁，所以找不到该let变量。\n\n### 3.4 思考题\n\n观察以下代码的输出结果。\n\n```\nlet myname= '极客时间'\n{\n  console.log(myname) \n  let myname= '极客邦'\n}\n```\n\n会出现以下报错。\n\n![](/images/react/2022011006.png)\n\n因为在块级作用域中，从`开始到let myname= '极客邦'`代码之间会形成一个暂时性死区，如果中间去访问变量`myname`，会报初始化之前不能访问`myname`的错误。\n\n## 4.作用域链和闭包\n\n### 4.1 作用域链\n\n当涉及到多个作用域中访问变量的情况就要提到作用域链。像以下代码。\n\n```\nfunction bar() {\n    console.log(myName)\n}\nfunction foo() {\n    var myName = \" 极客邦 \"\n    bar()\n}\nvar myName = \" 极客时间 \"\nfoo()\n```\n\n该代码在bar函数中会输出myName的值，根据上面几节所学，该代码会生成以下的执行上下文调用栈。\n\n![](/images/react/2022011007.png)\n\n在执行代码阶段，bar函数的执行上下文中没有的变量myName应该在哪里找呢，这里其实每一个执行上下文的环境变量中都有一个称为`outer`的外部引用，当该作用域中没有需要的变量，则会向`outer`指向的作用域中去查找。那么bar函数的`outer`会指向哪里呢？如下图所示为各个执行上下文的变量环境outer的指向。\n\n![](/images/react/2022011008.png)\n\n为什么bar函数的outer指向的不是foo函数而是全局呢？这就涉及到<u>函数声明的位置</u>。函数声明的位置觉得了该函数的outer指向，根据该定理观察该代码，可以看出bar和foo函数的声明位置都是在全局，所以它们的outer指向也都是全局。如果bar函数在foo函数内部定义，则它的outer会指向foo函数。这涉及到了<u>词法作用域</u>。\n\n词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。\n\n如下图所示。\n\n![](/images/react/2022011009.png)\n\n该图所示的词法作用域链顺序是：foo 函数作用域—>bar 函数作用域—>main 函数作用域—> 全局作用域。\n\n### 4.2 块级作用域中的变量查找\n\n观察以下代码：\n\n```\nfunction bar() {\n    var myName = \" 极客世界 \"\n    let test1 = 100\n    if (1) {\n        let myName = \"Chrome 浏览器 \"\n        console.log(test)\n    }\n}\nfunction foo() {\n    var myName = \" 极客邦 \"\n    let test = 2\n    {\n        let test = 3\n        bar()\n    }\n}\nvar myName = \" 极客时间 \"\nlet myAge = 10\nlet test = 1\nfoo()\n```\n\n分析其调用栈结构如下图所示：\n\n![](/images/react/2022011010.png)\n\n图中标出的顺序就是其查找变量的顺序。\n\n### 4.3 闭包\n\n观察以下代码：\n\n```\nfunction foo() {\n    var myName = \" 极客时间 \"\n    let test1 = 1\n    const test2 = 2\n    var innerBar = {\n        getName:function(){\n            console.log(test1)\n            return myName\n        },\n        setName:function(newName){\n            myName = newName\n        }\n    }\n    return innerBar\n}\nvar bar = foo()\nbar.setName(\" 极客邦 \")\nbar.getName()\nconsole.log(bar.getName())\n```\n\n其中，当执行代码时，会运行函数foo，也就会生成foo的执行上下文，但是执行完后foo的执行上下文就会在<u>内存中销毁</u>。但是在后面两行中却调用了foo的内部方法setName和getName，而这两个方法则使用了其外部函数foo函数的变量，此时变量myName和test1不会被销毁，而变成了<u>专属</u>`bar.setName`和`bar.getName`方法能使用的变量，这种情况就可以把这些只能够被特定函数访问的变量集合称之为<u>闭包</u>。\n\n![](/images/react/2022011011.png)\n\n那这些闭包是如何使用的呢？如下图所示：\n\n![](/images/react/2022011012.png)\n\n据图可知其执行顺序为setName函数执行上下文->该函数的闭包->全局执行上下文。\n\n也可以利用浏览器中的开发者工具来跟踪其查找变量顺序，如图所示。\n\n![](/images/react/2022011013.png)\n\n### 4.4 闭包回收\n\n如果引用闭包的函数是全局变量，那么该闭包就会一直存在直到页面关闭，如果引用闭包的函数是局部变量，那么该闭包会随着函数的销毁而销毁。所以使用闭包需要注意：<u>当闭包会一直使用则定义其函数为全局变量，否则就定义为局部变量。</u>\n\n### 4.5 思考题\n\n观察下面代码，其输出结果是什么，会形成闭包吗？\n\n```\nvar bar = {\n    myName:\"time.geekbang.com\",\n    printName: function () {\n        console.log(myName)\n    }    \n}\nfunction foo() {\n    let myName = \" 极客时间 \"\n    return bar.printName\n}\nlet myName = \" 极客邦 \"\nlet _printName = foo()\n_printName()\nbar.printName()\n```\n\n这道题其实是个障眼法，只需要确定好函数调用栈就可以很轻松的解答，调用了foo()后，返回的是bar.printName，后续就跟foo函数没有关系了，所以结果就是调用了两次bar.printName()，根据词法作用域，<u>结果都是“极客邦”，也不会形成闭包</u>。\n\n如下图所示。\n\n![](/images/react/2022011014.png)\n\n（其实我也有点糊涂了。）\n\n## 5.this\n\n### 5.1 JavaScript中的this是什么？\n\nthis其实和执行上下文有关，执行上下文一共有三种，分别是<u>全局执行上下文、函数执行上下文和eval执行上下文</u>。每个执行上下文中都包括我们已经知道的变量环节、词法环境以及outer。除此之外，this也包含在执行上下文中。所以根据不同的执行上下文，this也有所不同。\n\n### 5.2 全局执行上下文中的this\n\n直接在浏览器的开发者工具控制台中输入`console.log(this)`，可以看到输出的是window对象，因此可知，<u>全局执行上下文中的this指向window对象</u>，这也是this和作用域链的唯一交点，作用域链最底端包含了window对象。\n\n### 5.3 函数执行上下文中的this\n\n观察以下这段代码：\n\n```\nfunction foo(){\n  console.log(this)\n}\nfoo()\n```\n\n观察输出结果会发现，这个this依旧是指向window。那么可以改变函数内的this指向吗？可以的，有以下几种方法。\n\n**1.通过函数的call方法设置**\n\n如下列代码所示：\n\n```\nlet bar = {\n  myName : \" 极客邦 \",\n  test1 : 1\n}\nfunction foo(){\n  this.myName = \" 极客时间 \"\n}\nfoo.call(bar)\nconsole.log(bar)\nconsole.log(myName)\n```\n\n通过`foo.call(bar)`使得foo函数执行上下文中的this指向了bar。除了<u>call方法</u>，也可以使用<u>bind和apply方法</u>来设置函数执行上下文中的this。\n\n**2.通过对象调用方法设置**\n\n如下代码所示：\n\n```\nvar myObj = {\n  name : \" 极客时间 \", \n  showThis: function(){\n    console.log(this)\n  }\n}\nmyObj.showThis()\n```\n\n当执行`myObj.showThis()`时就会使得`showThis`中的`this`指向`myObj`对象。\n\n**3.通过构造函数中设置**\n\n如下代码所示：\n\n```\nfunction CreateObj(){\n  this.name = \" 极客时间 \"\n}\nvar myObj = new CreateObj()\n```\n\n使用`new`关键字来使函数中的this指向了新对象本身。\n\n### 5.3 this的涉及缺陷以及应对方案\n\n比方说嵌套函数中的this<u>没有继承关系</u>，如段代码所示：\n\n```\nvar myObj = {\n  name : \" 极客时间 \", \n  showThis: function(){\n    console.log(this)\n    function bar(){console.log(this)}\n    bar()\n  }\n}\nmyObj.showThis()\n```\n\n直觉上我们会以为bar函数内部的this也是指向showThis也就是它的外部函数，但其实它指向的是window，解决方法有两种，第一种是在bar函数外使用`var that=this`，在bar函数内使用that就代指showThis中的this，如下代码所示：\n\n```\nvar myObj = {\n  name : \" 极客时间 \", \n  showThis: function(){\n    console.log(this)\n    var that = this\n    function bar(){\n      that.name = \" 极客邦 \"\n    }\n    bar()\n  }\n}\nmyObj.showThis()\nconsole.log(myObj.name)\nconsole.log(window.name)\n```\n\n第二个方法是使用ES6中的<u>箭头函数</u>来声明bar函数，如下段代码所示：\n\n```\nvar myObj = {\n  name : \" 极客时间 \", \n  showThis: function(){\n    console.log(this)\n    var bar = ()=>{\n      this.name = \" 极客邦 \"\n      console.log(this)\n    }\n    bar()\n  }\n}\nmyObj.showThis()\nconsole.log(myObj.name)\nconsole.log(window.name)\n```\n\n因为箭头函数不会创建自身的执行上下文。\n","slug":"浏览器中JavaScript执行机制","published":1,"updated":"2022-01-11T03:13:30.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh3900376wtv30je2diy","content":"<hr>\n<p><em>本文来源于<a href=\"http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82\">http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程<a href=\"https://time.geekbang.org/column/intro/216\">《浏览器工作原理与实践》_-极客时间</a>。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。</a></em></p>\n<hr>\n<h2 id=\"1-变量提升\"><a href=\"#1-变量提升\" class=\"headerlink\" title=\"1.变量提升\"></a>1.变量提升</h2><p>使用过JavaScipt的程序员都清除JavaScipt是按顺序执行的，不过看以下代码的输出结果，就会发现似乎并没有按’顺序’执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">showName()<br><span class=\"hljs-built_in\">console</span>.log(myname)<br><span class=\"hljs-keyword\">var</span> myname = <span class=\"hljs-string\">&#x27;极客时间&#x27;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showName</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;函数showName被执行&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>执行结果如下图所示：</p>\n<p><img src=\"/images/react/2021122701.png\"></p>\n<p>据图可知，在变量和函数进行声明之前就调用了它们，但是依旧能够执行。并且函数能够正常执行但是变量却是<code>underfined</code>。如果删掉变量声明，即上述代码的第三行，那么执行结果又会是什么呢？如下图所示，代码会报错。</p>\n<p><img src=\"/images/react/2021122702.png\"></p>\n<p>可见如果在下文定义了变量和函数，那么在上文中使用该变量和函数时不会报错，不过函数可以顺利输出结果，但是变量却是<code>underfined</code>，而如果在下文没有定义，则会报错。这种情况被称为<u>变量提升</u>。</p>\n<h3 id=\"1-1-什么是变量提升\"><a href=\"#1-1-什么是变量提升\" class=\"headerlink\" title=\"1.1 什么是变量提升\"></a>1.1 什么是变量提升</h3><p>首先先要了解<u>声明和赋值</u>的概念，对于下面这行代码：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">varname</span> = <span class=\"hljs-string\">&#x27;name&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>其实可以分为两个阶段，即变量的声明阶段和变量赋值阶段：</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs delphi\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">name</span> = underfined<br><span class=\"hljs-keyword\">name</span> = <span class=\"hljs-string\">&#x27;name&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>而争对函数可以看下段代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br>&#125;<span class=\"hljs-comment\">//这个函数定义本身就是函数声明</span><br><br><span class=\"hljs-keyword\">var</span> bar=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;bar&#x27;</span>)<br>&#125;<br><span class=\"hljs-comment\">//变量声明 var bar = underfined</span><br><span class=\"hljs-comment\">//变量赋值 var = function()&#123; ... &#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>可见对于函数来说，<u>函数声明</u>就是函数定义本身。</p>\n<p>变量提升就是在JavaScipt代码执行过程中，把变量和函数的声明部分提到代码开头的行为，对于变量声明会设置默认值即<code>underfined</code>。</p>\n<p>如下图所示，就是我们的第一段代码进行变量提升后造成的效果。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-comment\">//先进行变量提升，即提取变量和函数的声明</span><br><span class=\"hljs-selector-tag\">var</span> myname = underfined<br>function showName()&#123;<br>    console<span class=\"hljs-selector-class\">.log</span>(<span class=\"hljs-string\">&#x27;showName被调用&#x27;</span>)<br>&#125;<br><br><span class=\"hljs-comment\">//再是代码的可执行部分</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">showName</span><span class=\"hljs-params\">()</span></span><br>console<span class=\"hljs-selector-class\">.log</span>(myname)<br>myname=<span class=\"hljs-string\">&#x27;极客时间&#x27;</span><span class=\"hljs-comment\">//去掉原来的var变量声明，变成变量赋值操作</span><br></code></pre></td></tr></table></figure>\n\n<p>上面就是变量提升带来的效果，其实一共就是两个步骤：1.提取变量和函数的声明放在代码顶部，对于变量声明进行<code>underfined</code>赋值。2.再执行代码可执行部分，对于原先的声明进行去除操作。</p>\n<h3 id=\"1-2-Java代码的执行流程\"><a href=\"#1-2-Java代码的执行流程\" class=\"headerlink\" title=\"1.2 Java代码的执行流程\"></a>1.2 Java代码的执行流程</h3><p>在了解什么是变量声明后，我们会以为变量声明的过程中是将代码的顺序进行改变的过程，但其实并不是，<u>实际上代码的位置并没有改变</u>，变量和函数声明的位置也没有变。JavaScipt的执行流程如下图所示：</p>\n<p><img src=\"/images/react/2021122703.png\"></p>\n<p>其中，变量提升的实现其实是在<u>编译阶段</u>实现的。输入一段代码，经过编译后会生成两部分内容：执行上下文和可执行代码。如下图所示：</p>\n<p><img src=\"/images/react/2021122704.png\"></p>\n<p>据图可知，在执行上下文中会保存代码的<u>环境变量</u>，其中就包括变量声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">showName()<br><span class=\"hljs-built_in\">console</span>.log(myname)<br><span class=\"hljs-keyword\">var</span> myname = <span class=\"hljs-string\">&#x27;极客时间&#x27;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showName</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;函数showName被执行&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>对于这段代码，编辑阶段的JavaScript引擎会对其进行分析处理，第1行第2行代码因为不是变量？函数声明则不进行处理，第3行是变量声明，于是JavaScipt引擎会在环境对象中创造一个myname的属性并初始化为<code>underfined</code>，第4行则是一个函数声明，JavaScript引擎会将函数定义存储岛堆中，并在环境对象中创建一个showName属性，将该属性指向堆中函数的位置。接下来JavaScipt会将声明以外的代码编译成字节码。这样就有了包含环境对象（变量声明）的执行上下文和可执行代码了。</p>\n<p>接下来就是进行执行阶段。在执行阶段，JavaScipt引擎是按照可执行代码的顺序一步一步执行的，争对上面这段代码的可执行部分就是：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">showName</span><span class=\"hljs-params\">()</span></span><br>console<span class=\"hljs-selector-class\">.log</span>(myname)<br>myname=<span class=\"hljs-string\">&#x27;极客时间&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>执行第1行时，JavaScript引擎会先在执行上下文的变量环境中寻找与此函数同名的属性，如果找到，就输出该属性的引用结果。</p>\n<p>执行第2行时，JavaScipt引擎同理在变量环境中查找<code>myname</code>属性，找到后就输出该属性值。</p>\n<p>执行第3行时，会将变量环境中的<code>myname</code>属性的值改为“极客时间”。</p>\n<p>以上就是变量提升在JavaScipt实际编译流程中的实现原理。</p>\n<p>3.代码中出现相同的变量/函数怎么办</p>\n<p>如下列代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showName</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;极客邦&#x27;</span>);<br>&#125;<br>showName();<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showName</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;极客时间&#x27;</span>);<br>&#125;<br>showName(); <br></code></pre></td></tr></table></figure>\n\n<p>实际上在编译阶段获取变量环境时就会将已有的showName属性在第一次定义后进行第二次修改，或者是覆盖第一次定义。所以实际运行时两个函数输出的结果是相同的，都是‘极客时间’。</p>\n<h2 id=\"2-调用栈\"><a href=\"#2-调用栈\" class=\"headerlink\" title=\"2.调用栈\"></a>2.调用栈</h2><p>上面一节通过变量提升的概率了解了JavaScipt引擎的编译过程，接下来具体深入该过程，这一节了解的是调用栈这一概念。</p>\n<h3 id=\"2-1-什么是函数调用\"><a href=\"#2-1-什么是函数调用\" class=\"headerlink\" title=\"2.1 什么是函数调用\"></a>2.1 什么是函数调用</h3><p>函数调用就是运行一个函数，如下列代码所示：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-selector-tag\">var</span> <span class=\"hljs-selector-tag\">a</span> = <span class=\"hljs-number\">2</span><br>function add()&#123;<br><span class=\"hljs-selector-tag\">var</span> <span class=\"hljs-selector-tag\">b</span> = <span class=\"hljs-number\">10</span><br>return  a+<span class=\"hljs-selector-tag\">b</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-title\">add</span><span class=\"hljs-params\">()</span></span><br></code></pre></td></tr></table></figure>\n\n<p>其中<code>add()</code>就是一个函数调用。根据这段代码按照上一节所学的可以知道，再进行add函数调用前会创建<u>执行上下文</u>，其中包括了变量环境，但这就涉及到了全局变量和局部变量的问题，在函数内部定义的变量又是怎么进行执行上下文创建的呢。</p>\n<p>这就是一个顺序问题，首先获得这段JavaScript代码，JavaScript引擎会先创建一个<u>全局执行上下文</u>。在全局执行上下文中有变量环境如下所示：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">VariableEnvironment：<br>    <span class=\"hljs-keyword\">a</span> -&gt; underfined,<br>    <span class=\"hljs-built_in\">add</span> -&gt; <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>: &#123;</span><br>    var b=<span class=\"hljs-number\">10</span><br>    <span class=\"hljs-literal\">return</span> <span class=\"hljs-keyword\">a</span>+b<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>搭建好全局的执行上写文后就进行全局的可执行代码执行，此时调用add函数，又要建立<u>函数内的执行上下文</u>，函数内的环境变量如下所示：</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">VariableEnvironment：<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">b</span> -&gt;</span> underfined<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后再执行函数内的可执行代码。具体的流程如下图所示：</p>\n<p><img src=\"/images/react/2021122705.png\"></p>\n<p>这其中就需要建立两个执行上下文，但JavaScript是怎么不把它们弄混的呢？这就涉及到了<u>栈</u>的概念。栈就是一种<u>先入后出</u>的结构。</p>\n<h3 id=\"2-2-什么是JavaScript的调用栈\"><a href=\"#2-2-什么是JavaScript的调用栈\" class=\"headerlink\" title=\"2.2 什么是JavaScript的调用栈\"></a>2.2 什么是JavaScript的调用栈</h3><p>JavaScript引擎就是利用栈的结构来管理执行上下文的，在执行上下文创建好后会将其压入栈中，这样的栈就叫做调用栈。</p>\n<p>看下面这段代码：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">var a = <span class=\"hljs-number\">2</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(b,c)&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">b+c</span><br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addAll</span>(b,c)&#123;<br>var d = 10<br>result = add(b,c)<br><span class=\"hljs-keyword\">return</span>  <span class=\"hljs-type\">a+result+d</span><br>&#125;<br>addAll(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">6</span>)<br></code></pre></td></tr></table></figure>\n\n<p>这段代码的执行过程为第一步，创建全局上下文，并将其压入栈底，如下图所示：</p>\n<p><img src=\"/images/react/2021122706.png\"></p>\n<p>然后执行全局代码。</p>\n<p>当运行到调用addAll函数时进行第二步，创建该函数的执行上下文，并将其压入栈中，如下图所示：</p>\n<p><img src=\"/images/react/2021122707.png\"></p>\n<p>之后就进入该函数代码的执行阶段。</p>\n<p>当执行到add函数的调用语句时就进行到第三步，为其创建执行上下文，并压入栈中，如下图所示：</p>\n<p><img src=\"/images/react/2021122708.png\"></p>\n<p>当ad函数返回时，调用栈会将顶部的执行上下文弹出，然后继续执行，直到返回到只剩下全局执行上下文为止。调用栈是JavaScript引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能追踪到哪个函数正在被执行以及各函数之间的调用关系。</p>\n<h3 id=\"2-3-在开发中使用调用栈\"><a href=\"#2-3-在开发中使用调用栈\" class=\"headerlink\" title=\"2.3 在开发中使用调用栈\"></a>2.3 在开发中使用调用栈</h3><p>利用浏览器查看调用栈：比如打开Chrome的开发者工具，在Sources中打开页面，在相关的JavaScript上设置断点，并且刷新运行，然后在右侧的call stack中就可以看到调用栈。如下图所示。</p>\n<p><img src=\"/images/react/2021122709.png\"></p>\n<p>在call stack中最底层的(anonymous)就是全局执行上下文。</p>\n<p>使用<code>console.trace()</code>来输出当前函数的调用关系，如下段代码所示：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-selector-tag\">var</span> <span class=\"hljs-selector-tag\">a</span> = <span class=\"hljs-number\">2</span><br>function add(<span class=\"hljs-selector-tag\">b</span>,c)<br>&#123; console<span class=\"hljs-selector-class\">.trace</span>()<span class=\"hljs-comment\">//输出当前函数的调用关系</span><br>  return b+c<br>&#125;<br>function addAll(<span class=\"hljs-selector-tag\">b</span>,c)&#123;<br><span class=\"hljs-selector-tag\">var</span> d = <span class=\"hljs-number\">10</span><br>result = add(<span class=\"hljs-selector-tag\">b</span>,c)<br>return  a+result+d<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-title\">addAll</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">6</span>)</span></span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码的输出结果如下图所示。</p>\n<p><img src=\"/images/react/2021122710.png\"></p>\n<h3 id=\"2-4-栈溢出\"><a href=\"#2-4-栈溢出\" class=\"headerlink\" title=\"2.4 栈溢出\"></a>2.4 栈溢出</h3><p>需要知道的是调用栈是有大小的，所以当栈内的执行上下文数量超过一定值时，JavaScript引擎就会报错，这种情况就叫做<u>栈溢出</u>。</p>\n<p>如下段代码所示：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">division</span>(a,b)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">division(a,b)</span><br>&#125;<br>console.log(division(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>))<br></code></pre></td></tr></table></figure>\n\n<p>执行后会出下如图所示报错：</p>\n<p><img src=\"/images/react/2021122711.png\"></p>\n<p>解决栈溢出的问题是<u>尽量避免回调函数的方法</u>，可以使用循环语句来代替回调函数。</p>\n<p>如下端代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">runStack</span> (<span class=\"hljs-params\">n</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">100</span>;<br>  <span class=\"hljs-keyword\">return</span> runStack( n- <span class=\"hljs-number\">2</span>);<br>&#125;<br>runStack(<span class=\"hljs-number\">50000</span>)<br><span class=\"hljs-comment\">//这段代码就会产生栈溢出的问题，可以进行以下优化</span><br><br><br><span class=\"hljs-comment\">// 优化</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">runStack</span>(<span class=\"hljs-params\">n</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">100</span>;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">1</span>) &#123; <span class=\"hljs-comment\">// 防止陷入死循环</span><br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">200</span>;<br>        &#125;<br><br>        n = n - <span class=\"hljs-number\">2</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-built_in\">console</span>.log(runStack(<span class=\"hljs-number\">50000</span>));<br></code></pre></td></tr></table></figure>\n\n<p>上面这段代码的优化就是使用了while循环来代替了递归函数。</p>\n<h2 id=\"3-块级作用域\"><a href=\"#3-块级作用域\" class=\"headerlink\" title=\"3.块级作用域\"></a>3.块级作用域</h2><p>在上面两节中提到了JavaScript的变量提升现象，这会造成很多误解问题，为了解决这种缺陷ES6引入了<u>let和cons</u>t来解决。let&amp;const使用块级作用域来解决了这个问题。</p>\n<h3 id=\"3-1-作用域\"><a href=\"#3-1-作用域\" class=\"headerlink\" title=\"3.1 作用域\"></a>3.1 作用域</h3><p>作用域就是变量能够访问的范围，JavaScript只有两种作用域：<u>全局作用域、函数作用域</u>。而其他许多语言则还有<u>块级作用域</u>，即用<code>&#123;&#125;</code>包围的区间就可以称为一个块级作用域，比如在Java中以下代码都是块级作用域：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-comment\">//if块</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">if</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>&#123;&#125;<br><br><span class=\"hljs-comment\">//while块</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">while</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>&#123;&#125;<br><br><span class=\"hljs-comment\">//函数块</span><br>function foo()&#123;<br><br><span class=\"hljs-comment\">//for循环块</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">for</span><span class=\"hljs-params\">(let i = <span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">100</span>; i++)</span></span>&#123;&#125;<br><br><span class=\"hljs-comment\">//单独一个块</span><br>&#123;&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-ES6中的let和const\"><a href=\"#3-2-ES6中的let和const\" class=\"headerlink\" title=\"3.2 ES6中的let和const\"></a>3.2 ES6中的let和const</h3><p>因为JavaScript的最初设计理念比较简单，所以它存在很多由于没有块级作用域带来的问题，为了解决这些问题，ES6引用了let和const关键字，让其也能像其他语言一样拥有块级作用域。</p>\n<p>let和const分别是定义变量和常量的关键字，如下列代码所示，使用这两个关键字就能够使用块级作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">letTest</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">2</span>;  <span class=\"hljs-comment\">// 不同的变量</span><br>    <span class=\"hljs-built_in\">console</span>.log(x);  <span class=\"hljs-comment\">// 2</span><br>  &#125;<br>  <span class=\"hljs-built_in\">console</span>.log(x);  <span class=\"hljs-comment\">// 1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果使用var，则两个输出的都是2 。</p>\n<h3 id=\"3-3-JavaScript如何支持块级作用域\"><a href=\"#3-3-JavaScript如何支持块级作用域\" class=\"headerlink\" title=\"3.3 JavaScript如何支持块级作用域\"></a>3.3 JavaScript如何支持块级作用域</h3><p>我们已知JavaScript实现变量提升的原理，那它又是怎么在此基础上又可以实现支持块级作用域的呢？看以下代码来进行解释分析。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">function foo()&#123;<br>    <span class=\"hljs-selector-tag\">var</span> <span class=\"hljs-selector-tag\">a</span> = <span class=\"hljs-number\">1</span><br>    let <span class=\"hljs-selector-tag\">b</span> = <span class=\"hljs-number\">2</span><br>    &#123;<br>      let <span class=\"hljs-selector-tag\">b</span> = <span class=\"hljs-number\">3</span><br>      <span class=\"hljs-selector-tag\">var</span> c = <span class=\"hljs-number\">4</span><br>      let d = <span class=\"hljs-number\">5</span><br>      console<span class=\"hljs-selector-class\">.log</span>(a)<br>      console<span class=\"hljs-selector-class\">.log</span>(b)<br>    &#125;<br>    console<span class=\"hljs-selector-class\">.log</span>(b) <br>    console<span class=\"hljs-selector-class\">.log</span>(c)<br>    console<span class=\"hljs-selector-class\">.log</span>(d)<br>&#125;   <br><span class=\"hljs-function\"><span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span></span><br></code></pre></td></tr></table></figure>\n\n<p>当进入这个foo函数时，会创建该函数的执行上下文，首先会将所有的var变量定义存储在执行上下文的变量环境中，同时将属于函数作用域的let or const 变量存储在执行上下文的词法环境中，如图所示。</p>\n<p><img src=\"/images/react/2022011001.png\"></p>\n<p>此时该函数的执行上下文环境已经定义完成，就需要使用JavaScript引擎执行代码，当执行到函数内部的第一个块级作用域<code>&#123;&#125;</code>时，foo函数的执行上下文如图所示。</p>\n<p><img src=\"/images/react/2022011002.png\"></p>\n<p>此时var变量a和let变量b已经被赋值。而由于进入了let的作用域，而在词法环境中创建了一个新栈，存储该块级作用域中的变量。</p>\n<p>之后当执行到块级作用域中的<code>console.log(a)</code>时，JavaScript引擎就会按照以下步骤来搜索变量。</p>\n<p><img src=\"/images/react/2022011003.png\"></p>\n<p>当执行完块级作用域时，词法环境中相应区间就会从栈顶弹出，如图所示。</p>\n<p><img src=\"/images/react/2022011004.png\"></p>\n<p>如下截图所示为改代码的输出结果。</p>\n<p><img src=\"/images/react/2022011005.png\"></p>\n<p>最后因为块级作用域所占内存已经销毁，所以找不到该let变量。</p>\n<h3 id=\"3-4-思考题\"><a href=\"#3-4-思考题\" class=\"headerlink\" title=\"3.4 思考题\"></a>3.4 思考题</h3><p>观察以下代码的输出结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> myname= <span class=\"hljs-string\">&#x27;极客时间&#x27;</span><br>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(myname) <br>  <span class=\"hljs-keyword\">let</span> myname= <span class=\"hljs-string\">&#x27;极客邦&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>会出现以下报错。</p>\n<p><img src=\"/images/react/2022011006.png\"></p>\n<p>因为在块级作用域中，从<code>开始到let myname= &#39;极客邦&#39;</code>代码之间会形成一个暂时性死区，如果中间去访问变量<code>myname</code>，会报初始化之前不能访问<code>myname</code>的错误。</p>\n<h2 id=\"4-作用域链和闭包\"><a href=\"#4-作用域链和闭包\" class=\"headerlink\" title=\"4.作用域链和闭包\"></a>4.作用域链和闭包</h2><h3 id=\"4-1-作用域链\"><a href=\"#4-1-作用域链\" class=\"headerlink\" title=\"4.1 作用域链\"></a>4.1 作用域链</h3><p>当涉及到多个作用域中访问变量的情况就要提到作用域链。像以下代码。</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs isbl\"><span class=\"hljs-variable\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">bar</span>() &#123;</span><br><span class=\"hljs-function\">    <span class=\"hljs-variable\">console.log</span>(<span class=\"hljs-variable\">myName</span>)</span><br>&#125;<br><span class=\"hljs-variable\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">foo</span>() &#123;</span><br><span class=\"hljs-function\">    <span class=\"hljs-variable\">var</span> <span class=\"hljs-variable\">myName</span> = <span class=\"hljs-string\">&quot; 极客邦 &quot;</span></span><br><span class=\"hljs-function\">    <span class=\"hljs-title\">bar</span>()</span><br>&#125;<br><span class=\"hljs-variable\">var</span> <span class=\"hljs-variable\">myName</span> = <span class=\"hljs-string\">&quot; 极客时间 &quot;</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">foo</span>()</span><br></code></pre></td></tr></table></figure>\n\n<p>该代码在bar函数中会输出myName的值，根据上面几节所学，该代码会生成以下的执行上下文调用栈。</p>\n<p><img src=\"/images/react/2022011007.png\"></p>\n<p>在执行代码阶段，bar函数的执行上下文中没有的变量myName应该在哪里找呢，这里其实每一个执行上下文的环境变量中都有一个称为<code>outer</code>的外部引用，当该作用域中没有需要的变量，则会向<code>outer</code>指向的作用域中去查找。那么bar函数的<code>outer</code>会指向哪里呢？如下图所示为各个执行上下文的变量环境outer的指向。</p>\n<p><img src=\"/images/react/2022011008.png\"></p>\n<p>为什么bar函数的outer指向的不是foo函数而是全局呢？这就涉及到<u>函数声明的位置</u>。函数声明的位置觉得了该函数的outer指向，根据该定理观察该代码，可以看出bar和foo函数的声明位置都是在全局，所以它们的outer指向也都是全局。如果bar函数在foo函数内部定义，则它的outer会指向foo函数。这涉及到了<u>词法作用域</u>。</p>\n<p>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</p>\n<p>如下图所示。</p>\n<p><img src=\"/images/react/2022011009.png\"></p>\n<p>该图所示的词法作用域链顺序是：foo 函数作用域—&gt;bar 函数作用域—&gt;main 函数作用域—&gt; 全局作用域。</p>\n<h3 id=\"4-2-块级作用域中的变量查找\"><a href=\"#4-2-块级作用域中的变量查找\" class=\"headerlink\" title=\"4.2 块级作用域中的变量查找\"></a>4.2 块级作用域中的变量查找</h3><p>观察以下代码：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\">function bar() &#123;<br>    var <span class=\"hljs-attr\">myName</span> = <span class=\"hljs-string\">&quot; 极客世界 &quot;</span><br>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">test1</span> = <span class=\"hljs-number\">100</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">myName</span> = <span class=\"hljs-string\">&quot;Chrome 浏览器 &quot;</span><br>        console.log(test)<br>    &#125;<br>&#125;<br>function foo() &#123;<br>    var <span class=\"hljs-attr\">myName</span> = <span class=\"hljs-string\">&quot; 极客邦 &quot;</span><br>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">test</span> = <span class=\"hljs-number\">2</span><br>    &#123;<br>        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">test</span> = <span class=\"hljs-number\">3</span><br>        bar()<br>    &#125;<br>&#125;<br>var <span class=\"hljs-attr\">myName</span> = <span class=\"hljs-string\">&quot; 极客时间 &quot;</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">myAge</span> = <span class=\"hljs-number\">10</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">test</span> = <span class=\"hljs-number\">1</span><br>foo()<br></code></pre></td></tr></table></figure>\n\n<p>分析其调用栈结构如下图所示：</p>\n<p><img src=\"/images/react/2022011010.png\"></p>\n<p>图中标出的顺序就是其查找变量的顺序。</p>\n<h3 id=\"4-3-闭包\"><a href=\"#4-3-闭包\" class=\"headerlink\" title=\"4.3 闭包\"></a>4.3 闭包</h3><p>观察以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">var</span> myName = <span class=\"hljs-string\">&quot; 极客时间 &quot;</span><br>    <span class=\"hljs-keyword\">let</span> test1 = <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">const</span> test2 = <span class=\"hljs-number\">2</span><br>    <span class=\"hljs-keyword\">var</span> innerBar = &#123;<br>        <span class=\"hljs-attr\">getName</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>            <span class=\"hljs-built_in\">console</span>.log(test1)<br>            <span class=\"hljs-keyword\">return</span> myName<br>        &#125;,<br>        <span class=\"hljs-attr\">setName</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">newName</span>)</span>&#123;<br>            myName = newName<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> innerBar<br>&#125;<br><span class=\"hljs-keyword\">var</span> bar = foo()<br>bar.setName(<span class=\"hljs-string\">&quot; 极客邦 &quot;</span>)<br>bar.getName()<br><span class=\"hljs-built_in\">console</span>.log(bar.getName())<br></code></pre></td></tr></table></figure>\n\n<p>其中，当执行代码时，会运行函数foo，也就会生成foo的执行上下文，但是执行完后foo的执行上下文就会在<u>内存中销毁</u>。但是在后面两行中却调用了foo的内部方法setName和getName，而这两个方法则使用了其外部函数foo函数的变量，此时变量myName和test1不会被销毁，而变成了<u>专属</u><code>bar.setName</code>和<code>bar.getName</code>方法能使用的变量，这种情况就可以把这些只能够被特定函数访问的变量集合称之为<u>闭包</u>。</p>\n<p><img src=\"/images/react/2022011011.png\"></p>\n<p>那这些闭包是如何使用的呢？如下图所示：</p>\n<p><img src=\"/images/react/2022011012.png\"></p>\n<p>据图可知其执行顺序为setName函数执行上下文-&gt;该函数的闭包-&gt;全局执行上下文。</p>\n<p>也可以利用浏览器中的开发者工具来跟踪其查找变量顺序，如图所示。</p>\n<p><img src=\"/images/react/2022011013.png\"></p>\n<h3 id=\"4-4-闭包回收\"><a href=\"#4-4-闭包回收\" class=\"headerlink\" title=\"4.4 闭包回收\"></a>4.4 闭包回收</h3><p>如果引用闭包的函数是全局变量，那么该闭包就会一直存在直到页面关闭，如果引用闭包的函数是局部变量，那么该闭包会随着函数的销毁而销毁。所以使用闭包需要注意：<u>当闭包会一直使用则定义其函数为全局变量，否则就定义为局部变量。</u></p>\n<h3 id=\"4-5-思考题\"><a href=\"#4-5-思考题\" class=\"headerlink\" title=\"4.5 思考题\"></a>4.5 思考题</h3><p>观察下面代码，其输出结果是什么，会形成闭包吗？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> bar = &#123;<br>    <span class=\"hljs-attr\">myName</span>:<span class=\"hljs-string\">&quot;time.geekbang.com&quot;</span>,<br>    <span class=\"hljs-attr\">printName</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(myName)<br>    &#125;    <br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">let</span> myName = <span class=\"hljs-string\">&quot; 极客时间 &quot;</span><br>    <span class=\"hljs-keyword\">return</span> bar.printName<br>&#125;<br><span class=\"hljs-keyword\">let</span> myName = <span class=\"hljs-string\">&quot; 极客邦 &quot;</span><br><span class=\"hljs-keyword\">let</span> _printName = foo()<br>_printName()<br>bar.printName()<br></code></pre></td></tr></table></figure>\n\n<p>这道题其实是个障眼法，只需要确定好函数调用栈就可以很轻松的解答，调用了foo()后，返回的是bar.printName，后续就跟foo函数没有关系了，所以结果就是调用了两次bar.printName()，根据词法作用域，<u>结果都是“极客邦”，也不会形成闭包</u>。</p>\n<p>如下图所示。</p>\n<p><img src=\"/images/react/2022011014.png\"></p>\n<p>（其实我也有点糊涂了。）</p>\n<h2 id=\"5-this\"><a href=\"#5-this\" class=\"headerlink\" title=\"5.this\"></a>5.this</h2><h3 id=\"5-1-JavaScript中的this是什么？\"><a href=\"#5-1-JavaScript中的this是什么？\" class=\"headerlink\" title=\"5.1 JavaScript中的this是什么？\"></a>5.1 JavaScript中的this是什么？</h3><p>this其实和执行上下文有关，执行上下文一共有三种，分别是<u>全局执行上下文、函数执行上下文和eval执行上下文</u>。每个执行上下文中都包括我们已经知道的变量环节、词法环境以及outer。除此之外，this也包含在执行上下文中。所以根据不同的执行上下文，this也有所不同。</p>\n<h3 id=\"5-2-全局执行上下文中的this\"><a href=\"#5-2-全局执行上下文中的this\" class=\"headerlink\" title=\"5.2 全局执行上下文中的this\"></a>5.2 全局执行上下文中的this</h3><p>直接在浏览器的开发者工具控制台中输入<code>console.log(this)</code>，可以看到输出的是window对象，因此可知，<u>全局执行上下文中的this指向window对象</u>，这也是this和作用域链的唯一交点，作用域链最底端包含了window对象。</p>\n<h3 id=\"5-3-函数执行上下文中的this\"><a href=\"#5-3-函数执行上下文中的this\" class=\"headerlink\" title=\"5.3 函数执行上下文中的this\"></a>5.3 函数执行上下文中的this</h3><p>观察以下这段代码：</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs isbl\"><span class=\"hljs-variable\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">foo</span>()&#123;</span><br><span class=\"hljs-function\">  <span class=\"hljs-variable\">console.log</span>(<span class=\"hljs-variable\">this</span>)</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-title\">foo</span>()</span><br></code></pre></td></tr></table></figure>\n\n<p>观察输出结果会发现，这个this依旧是指向window。那么可以改变函数内的this指向吗？可以的，有以下几种方法。</p>\n<p><strong>1.通过函数的call方法设置</strong></p>\n<p>如下列代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> bar = &#123;<br>  <span class=\"hljs-attr\">myName</span> : <span class=\"hljs-string\">&quot; 极客邦 &quot;</span>,<br>  <span class=\"hljs-attr\">test1</span> : <span class=\"hljs-number\">1</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>  <span class=\"hljs-built_in\">this</span>.myName = <span class=\"hljs-string\">&quot; 极客时间 &quot;</span><br>&#125;<br>foo.call(bar)<br><span class=\"hljs-built_in\">console</span>.log(bar)<br><span class=\"hljs-built_in\">console</span>.log(myName)<br></code></pre></td></tr></table></figure>\n\n<p>通过<code>foo.call(bar)</code>使得foo函数执行上下文中的this指向了bar。除了<u>call方法</u>，也可以使用<u>bind和apply方法</u>来设置函数执行上下文中的this。</p>\n<p><strong>2.通过对象调用方法设置</strong></p>\n<p>如下代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myObj = &#123;<br>  <span class=\"hljs-attr\">name</span> : <span class=\"hljs-string\">&quot; 极客时间 &quot;</span>, <br>  <span class=\"hljs-attr\">showThis</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>)<br>  &#125;<br>&#125;<br>myObj.showThis()<br></code></pre></td></tr></table></figure>\n\n<p>当执行<code>myObj.showThis()</code>时就会使得<code>showThis</code>中的<code>this</code>指向<code>myObj</code>对象。</p>\n<p><strong>3.通过构造函数中设置</strong></p>\n<p>如下代码所示：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">CreateObj</span><span class=\"hljs-params\">()</span></span>&#123;<br>  <span class=\"hljs-keyword\">this</span>.name = <span class=\"hljs-string\">&quot; 极客时间 &quot;</span><br>&#125;<br><span class=\"hljs-keyword\">var</span> myObj = <span class=\"hljs-keyword\">new</span> CreateObj()<br></code></pre></td></tr></table></figure>\n\n<p>使用<code>new</code>关键字来使函数中的this指向了新对象本身。</p>\n<h3 id=\"5-3-this的涉及缺陷以及应对方案\"><a href=\"#5-3-this的涉及缺陷以及应对方案\" class=\"headerlink\" title=\"5.3 this的涉及缺陷以及应对方案\"></a>5.3 this的涉及缺陷以及应对方案</h3><p>比方说嵌套函数中的this<u>没有继承关系</u>，如段代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myObj = &#123;<br>  <span class=\"hljs-attr\">name</span> : <span class=\"hljs-string\">&quot; 极客时间 &quot;</span>, <br>  <span class=\"hljs-attr\">showThis</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>)<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\"></span>)</span>&#123;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>)&#125;<br>    bar()<br>  &#125;<br>&#125;<br>myObj.showThis()<br></code></pre></td></tr></table></figure>\n\n<p>直觉上我们会以为bar函数内部的this也是指向showThis也就是它的外部函数，但其实它指向的是window，解决方法有两种，第一种是在bar函数外使用<code>var that=this</code>，在bar函数内使用that就代指showThis中的this，如下代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myObj = &#123;<br>  <span class=\"hljs-attr\">name</span> : <span class=\"hljs-string\">&quot; 极客时间 &quot;</span>, <br>  <span class=\"hljs-attr\">showThis</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>)<br>    <span class=\"hljs-keyword\">var</span> that = <span class=\"hljs-built_in\">this</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>      that.name = <span class=\"hljs-string\">&quot; 极客邦 &quot;</span><br>    &#125;<br>    bar()<br>  &#125;<br>&#125;<br>myObj.showThis()<br><span class=\"hljs-built_in\">console</span>.log(myObj.name)<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">window</span>.name)<br></code></pre></td></tr></table></figure>\n\n<p>第二个方法是使用ES6中的<u>箭头函数</u>来声明bar函数，如下段代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myObj = &#123;<br>  <span class=\"hljs-attr\">name</span> : <span class=\"hljs-string\">&quot; 极客时间 &quot;</span>, <br>  <span class=\"hljs-attr\">showThis</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>)<br>    <span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-function\">()=&gt;</span>&#123;<br>      <span class=\"hljs-built_in\">this</span>.name = <span class=\"hljs-string\">&quot; 极客邦 &quot;</span><br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>)<br>    &#125;<br>    bar()<br>  &#125;<br>&#125;<br>myObj.showThis()<br><span class=\"hljs-built_in\">console</span>.log(myObj.name)<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">window</span>.name)<br></code></pre></td></tr></table></figure>\n\n<p>因为箭头函数不会创建自身的执行上下文。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>本文来源于<a href=\"http://interview.poetries.top%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E8%BF%99%E6%98%AF%E5%87%BA%E4%BA%8E%E6%9E%81%E5%85%89%E8%AF%BE%E7%A8%8B%5B%E3%80%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B_-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%5D(https://time.geekbang.org/column/intro/216)%E3%80%82%E6%9C%AC%E6%96%87%E7%AB%A0%E6%98%AF%E5%9C%A8%E9%98%85%E8%AF%BB%E8%AF%A5%E8%B5%84%E6%96%99%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86%E7%9B%B4%E6%8E%A5%E6%90%AC%E8%BF%90%E5%8E%9F%E6%96%87%EF%BC%8C%E4%BE%B5%E5%88%A0%E3%80%82\">http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程<a href=\"https://time.geekbang.org/column/intro/216\">《浏览器工作原理与实践》_-极客时间</a>。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。</a></em></p>\n<hr>\n<h2 id=\"1-变量提升\"><a href=\"#1-变量提升\" class=\"headerlink\" title=\"1.变量提升\"></a>1.变量提升</h2><p>使用过JavaScipt的程序员都清除JavaScipt是按顺序执行的，不过看以下代码的输出结果，就会发现似乎并没有按’顺序’执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">showName()<br><span class=\"hljs-built_in\">console</span>.log(myname)<br><span class=\"hljs-keyword\">var</span> myname = <span class=\"hljs-string\">&#x27;极客时间&#x27;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showName</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;函数showName被执行&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>执行结果如下图所示：</p>\n<p><img src=\"/images/react/2021122701.png\"></p>\n<p>据图可知，在变量和函数进行声明之前就调用了它们，但是依旧能够执行。并且函数能够正常执行但是变量却是<code>underfined</code>。如果删掉变量声明，即上述代码的第三行，那么执行结果又会是什么呢？如下图所示，代码会报错。</p>\n<p><img src=\"/images/react/2021122702.png\"></p>\n<p>可见如果在下文定义了变量和函数，那么在上文中使用该变量和函数时不会报错，不过函数可以顺利输出结果，但是变量却是<code>underfined</code>，而如果在下文没有定义，则会报错。这种情况被称为<u>变量提升</u>。</p>\n<h3 id=\"1-1-什么是变量提升\"><a href=\"#1-1-什么是变量提升\" class=\"headerlink\" title=\"1.1 什么是变量提升\"></a>1.1 什么是变量提升</h3><p>首先先要了解<u>声明和赋值</u>的概念，对于下面这行代码：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">varname</span> = <span class=\"hljs-string\">&#x27;name&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>其实可以分为两个阶段，即变量的声明阶段和变量赋值阶段：</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs delphi\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">name</span> = underfined<br><span class=\"hljs-keyword\">name</span> = <span class=\"hljs-string\">&#x27;name&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>而争对函数可以看下段代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br>&#125;<span class=\"hljs-comment\">//这个函数定义本身就是函数声明</span><br><br><span class=\"hljs-keyword\">var</span> bar=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;bar&#x27;</span>)<br>&#125;<br><span class=\"hljs-comment\">//变量声明 var bar = underfined</span><br><span class=\"hljs-comment\">//变量赋值 var = function()&#123; ... &#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>可见对于函数来说，<u>函数声明</u>就是函数定义本身。</p>\n<p>变量提升就是在JavaScipt代码执行过程中，把变量和函数的声明部分提到代码开头的行为，对于变量声明会设置默认值即<code>underfined</code>。</p>\n<p>如下图所示，就是我们的第一段代码进行变量提升后造成的效果。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-comment\">//先进行变量提升，即提取变量和函数的声明</span><br><span class=\"hljs-selector-tag\">var</span> myname = underfined<br>function showName()&#123;<br>    console<span class=\"hljs-selector-class\">.log</span>(<span class=\"hljs-string\">&#x27;showName被调用&#x27;</span>)<br>&#125;<br><br><span class=\"hljs-comment\">//再是代码的可执行部分</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">showName</span><span class=\"hljs-params\">()</span></span><br>console<span class=\"hljs-selector-class\">.log</span>(myname)<br>myname=<span class=\"hljs-string\">&#x27;极客时间&#x27;</span><span class=\"hljs-comment\">//去掉原来的var变量声明，变成变量赋值操作</span><br></code></pre></td></tr></table></figure>\n\n<p>上面就是变量提升带来的效果，其实一共就是两个步骤：1.提取变量和函数的声明放在代码顶部，对于变量声明进行<code>underfined</code>赋值。2.再执行代码可执行部分，对于原先的声明进行去除操作。</p>\n<h3 id=\"1-2-Java代码的执行流程\"><a href=\"#1-2-Java代码的执行流程\" class=\"headerlink\" title=\"1.2 Java代码的执行流程\"></a>1.2 Java代码的执行流程</h3><p>在了解什么是变量声明后，我们会以为变量声明的过程中是将代码的顺序进行改变的过程，但其实并不是，<u>实际上代码的位置并没有改变</u>，变量和函数声明的位置也没有变。JavaScipt的执行流程如下图所示：</p>\n<p><img src=\"/images/react/2021122703.png\"></p>\n<p>其中，变量提升的实现其实是在<u>编译阶段</u>实现的。输入一段代码，经过编译后会生成两部分内容：执行上下文和可执行代码。如下图所示：</p>\n<p><img src=\"/images/react/2021122704.png\"></p>\n<p>据图可知，在执行上下文中会保存代码的<u>环境变量</u>，其中就包括变量声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">showName()<br><span class=\"hljs-built_in\">console</span>.log(myname)<br><span class=\"hljs-keyword\">var</span> myname = <span class=\"hljs-string\">&#x27;极客时间&#x27;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showName</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;函数showName被执行&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>对于这段代码，编辑阶段的JavaScript引擎会对其进行分析处理，第1行第2行代码因为不是变量？函数声明则不进行处理，第3行是变量声明，于是JavaScipt引擎会在环境对象中创造一个myname的属性并初始化为<code>underfined</code>，第4行则是一个函数声明，JavaScript引擎会将函数定义存储岛堆中，并在环境对象中创建一个showName属性，将该属性指向堆中函数的位置。接下来JavaScipt会将声明以外的代码编译成字节码。这样就有了包含环境对象（变量声明）的执行上下文和可执行代码了。</p>\n<p>接下来就是进行执行阶段。在执行阶段，JavaScipt引擎是按照可执行代码的顺序一步一步执行的，争对上面这段代码的可执行部分就是：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">showName</span><span class=\"hljs-params\">()</span></span><br>console<span class=\"hljs-selector-class\">.log</span>(myname)<br>myname=<span class=\"hljs-string\">&#x27;极客时间&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>执行第1行时，JavaScript引擎会先在执行上下文的变量环境中寻找与此函数同名的属性，如果找到，就输出该属性的引用结果。</p>\n<p>执行第2行时，JavaScipt引擎同理在变量环境中查找<code>myname</code>属性，找到后就输出该属性值。</p>\n<p>执行第3行时，会将变量环境中的<code>myname</code>属性的值改为“极客时间”。</p>\n<p>以上就是变量提升在JavaScipt实际编译流程中的实现原理。</p>\n<p>3.代码中出现相同的变量/函数怎么办</p>\n<p>如下列代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showName</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;极客邦&#x27;</span>);<br>&#125;<br>showName();<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showName</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;极客时间&#x27;</span>);<br>&#125;<br>showName(); <br></code></pre></td></tr></table></figure>\n\n<p>实际上在编译阶段获取变量环境时就会将已有的showName属性在第一次定义后进行第二次修改，或者是覆盖第一次定义。所以实际运行时两个函数输出的结果是相同的，都是‘极客时间’。</p>\n<h2 id=\"2-调用栈\"><a href=\"#2-调用栈\" class=\"headerlink\" title=\"2.调用栈\"></a>2.调用栈</h2><p>上面一节通过变量提升的概率了解了JavaScipt引擎的编译过程，接下来具体深入该过程，这一节了解的是调用栈这一概念。</p>\n<h3 id=\"2-1-什么是函数调用\"><a href=\"#2-1-什么是函数调用\" class=\"headerlink\" title=\"2.1 什么是函数调用\"></a>2.1 什么是函数调用</h3><p>函数调用就是运行一个函数，如下列代码所示：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-selector-tag\">var</span> <span class=\"hljs-selector-tag\">a</span> = <span class=\"hljs-number\">2</span><br>function add()&#123;<br><span class=\"hljs-selector-tag\">var</span> <span class=\"hljs-selector-tag\">b</span> = <span class=\"hljs-number\">10</span><br>return  a+<span class=\"hljs-selector-tag\">b</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-title\">add</span><span class=\"hljs-params\">()</span></span><br></code></pre></td></tr></table></figure>\n\n<p>其中<code>add()</code>就是一个函数调用。根据这段代码按照上一节所学的可以知道，再进行add函数调用前会创建<u>执行上下文</u>，其中包括了变量环境，但这就涉及到了全局变量和局部变量的问题，在函数内部定义的变量又是怎么进行执行上下文创建的呢。</p>\n<p>这就是一个顺序问题，首先获得这段JavaScript代码，JavaScript引擎会先创建一个<u>全局执行上下文</u>。在全局执行上下文中有变量环境如下所示：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">VariableEnvironment：<br>    <span class=\"hljs-keyword\">a</span> -&gt; underfined,<br>    <span class=\"hljs-built_in\">add</span> -&gt; <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>: &#123;</span><br>    var b=<span class=\"hljs-number\">10</span><br>    <span class=\"hljs-literal\">return</span> <span class=\"hljs-keyword\">a</span>+b<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>搭建好全局的执行上写文后就进行全局的可执行代码执行，此时调用add函数，又要建立<u>函数内的执行上下文</u>，函数内的环境变量如下所示：</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">VariableEnvironment：<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">b</span> -&gt;</span> underfined<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后再执行函数内的可执行代码。具体的流程如下图所示：</p>\n<p><img src=\"/images/react/2021122705.png\"></p>\n<p>这其中就需要建立两个执行上下文，但JavaScript是怎么不把它们弄混的呢？这就涉及到了<u>栈</u>的概念。栈就是一种<u>先入后出</u>的结构。</p>\n<h3 id=\"2-2-什么是JavaScript的调用栈\"><a href=\"#2-2-什么是JavaScript的调用栈\" class=\"headerlink\" title=\"2.2 什么是JavaScript的调用栈\"></a>2.2 什么是JavaScript的调用栈</h3><p>JavaScript引擎就是利用栈的结构来管理执行上下文的，在执行上下文创建好后会将其压入栈中，这样的栈就叫做调用栈。</p>\n<p>看下面这段代码：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">var a = <span class=\"hljs-number\">2</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(b,c)&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">b+c</span><br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addAll</span>(b,c)&#123;<br>var d = 10<br>result = add(b,c)<br><span class=\"hljs-keyword\">return</span>  <span class=\"hljs-type\">a+result+d</span><br>&#125;<br>addAll(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">6</span>)<br></code></pre></td></tr></table></figure>\n\n<p>这段代码的执行过程为第一步，创建全局上下文，并将其压入栈底，如下图所示：</p>\n<p><img src=\"/images/react/2021122706.png\"></p>\n<p>然后执行全局代码。</p>\n<p>当运行到调用addAll函数时进行第二步，创建该函数的执行上下文，并将其压入栈中，如下图所示：</p>\n<p><img src=\"/images/react/2021122707.png\"></p>\n<p>之后就进入该函数代码的执行阶段。</p>\n<p>当执行到add函数的调用语句时就进行到第三步，为其创建执行上下文，并压入栈中，如下图所示：</p>\n<p><img src=\"/images/react/2021122708.png\"></p>\n<p>当ad函数返回时，调用栈会将顶部的执行上下文弹出，然后继续执行，直到返回到只剩下全局执行上下文为止。调用栈是JavaScript引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能追踪到哪个函数正在被执行以及各函数之间的调用关系。</p>\n<h3 id=\"2-3-在开发中使用调用栈\"><a href=\"#2-3-在开发中使用调用栈\" class=\"headerlink\" title=\"2.3 在开发中使用调用栈\"></a>2.3 在开发中使用调用栈</h3><p>利用浏览器查看调用栈：比如打开Chrome的开发者工具，在Sources中打开页面，在相关的JavaScript上设置断点，并且刷新运行，然后在右侧的call stack中就可以看到调用栈。如下图所示。</p>\n<p><img src=\"/images/react/2021122709.png\"></p>\n<p>在call stack中最底层的(anonymous)就是全局执行上下文。</p>\n<p>使用<code>console.trace()</code>来输出当前函数的调用关系，如下段代码所示：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-selector-tag\">var</span> <span class=\"hljs-selector-tag\">a</span> = <span class=\"hljs-number\">2</span><br>function add(<span class=\"hljs-selector-tag\">b</span>,c)<br>&#123; console<span class=\"hljs-selector-class\">.trace</span>()<span class=\"hljs-comment\">//输出当前函数的调用关系</span><br>  return b+c<br>&#125;<br>function addAll(<span class=\"hljs-selector-tag\">b</span>,c)&#123;<br><span class=\"hljs-selector-tag\">var</span> d = <span class=\"hljs-number\">10</span><br>result = add(<span class=\"hljs-selector-tag\">b</span>,c)<br>return  a+result+d<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-title\">addAll</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">6</span>)</span></span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码的输出结果如下图所示。</p>\n<p><img src=\"/images/react/2021122710.png\"></p>\n<h3 id=\"2-4-栈溢出\"><a href=\"#2-4-栈溢出\" class=\"headerlink\" title=\"2.4 栈溢出\"></a>2.4 栈溢出</h3><p>需要知道的是调用栈是有大小的，所以当栈内的执行上下文数量超过一定值时，JavaScript引擎就会报错，这种情况就叫做<u>栈溢出</u>。</p>\n<p>如下段代码所示：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">division</span>(a,b)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">division(a,b)</span><br>&#125;<br>console.log(division(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>))<br></code></pre></td></tr></table></figure>\n\n<p>执行后会出下如图所示报错：</p>\n<p><img src=\"/images/react/2021122711.png\"></p>\n<p>解决栈溢出的问题是<u>尽量避免回调函数的方法</u>，可以使用循环语句来代替回调函数。</p>\n<p>如下端代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">runStack</span> (<span class=\"hljs-params\">n</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">100</span>;<br>  <span class=\"hljs-keyword\">return</span> runStack( n- <span class=\"hljs-number\">2</span>);<br>&#125;<br>runStack(<span class=\"hljs-number\">50000</span>)<br><span class=\"hljs-comment\">//这段代码就会产生栈溢出的问题，可以进行以下优化</span><br><br><br><span class=\"hljs-comment\">// 优化</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">runStack</span>(<span class=\"hljs-params\">n</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">100</span>;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">1</span>) &#123; <span class=\"hljs-comment\">// 防止陷入死循环</span><br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">200</span>;<br>        &#125;<br><br>        n = n - <span class=\"hljs-number\">2</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-built_in\">console</span>.log(runStack(<span class=\"hljs-number\">50000</span>));<br></code></pre></td></tr></table></figure>\n\n<p>上面这段代码的优化就是使用了while循环来代替了递归函数。</p>\n<h2 id=\"3-块级作用域\"><a href=\"#3-块级作用域\" class=\"headerlink\" title=\"3.块级作用域\"></a>3.块级作用域</h2><p>在上面两节中提到了JavaScript的变量提升现象，这会造成很多误解问题，为了解决这种缺陷ES6引入了<u>let和cons</u>t来解决。let&amp;const使用块级作用域来解决了这个问题。</p>\n<h3 id=\"3-1-作用域\"><a href=\"#3-1-作用域\" class=\"headerlink\" title=\"3.1 作用域\"></a>3.1 作用域</h3><p>作用域就是变量能够访问的范围，JavaScript只有两种作用域：<u>全局作用域、函数作用域</u>。而其他许多语言则还有<u>块级作用域</u>，即用<code>&#123;&#125;</code>包围的区间就可以称为一个块级作用域，比如在Java中以下代码都是块级作用域：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-comment\">//if块</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">if</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>&#123;&#125;<br><br><span class=\"hljs-comment\">//while块</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">while</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>&#123;&#125;<br><br><span class=\"hljs-comment\">//函数块</span><br>function foo()&#123;<br><br><span class=\"hljs-comment\">//for循环块</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">for</span><span class=\"hljs-params\">(let i = <span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">100</span>; i++)</span></span>&#123;&#125;<br><br><span class=\"hljs-comment\">//单独一个块</span><br>&#123;&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-ES6中的let和const\"><a href=\"#3-2-ES6中的let和const\" class=\"headerlink\" title=\"3.2 ES6中的let和const\"></a>3.2 ES6中的let和const</h3><p>因为JavaScript的最初设计理念比较简单，所以它存在很多由于没有块级作用域带来的问题，为了解决这些问题，ES6引用了let和const关键字，让其也能像其他语言一样拥有块级作用域。</p>\n<p>let和const分别是定义变量和常量的关键字，如下列代码所示，使用这两个关键字就能够使用块级作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">letTest</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">2</span>;  <span class=\"hljs-comment\">// 不同的变量</span><br>    <span class=\"hljs-built_in\">console</span>.log(x);  <span class=\"hljs-comment\">// 2</span><br>  &#125;<br>  <span class=\"hljs-built_in\">console</span>.log(x);  <span class=\"hljs-comment\">// 1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果使用var，则两个输出的都是2 。</p>\n<h3 id=\"3-3-JavaScript如何支持块级作用域\"><a href=\"#3-3-JavaScript如何支持块级作用域\" class=\"headerlink\" title=\"3.3 JavaScript如何支持块级作用域\"></a>3.3 JavaScript如何支持块级作用域</h3><p>我们已知JavaScript实现变量提升的原理，那它又是怎么在此基础上又可以实现支持块级作用域的呢？看以下代码来进行解释分析。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">function foo()&#123;<br>    <span class=\"hljs-selector-tag\">var</span> <span class=\"hljs-selector-tag\">a</span> = <span class=\"hljs-number\">1</span><br>    let <span class=\"hljs-selector-tag\">b</span> = <span class=\"hljs-number\">2</span><br>    &#123;<br>      let <span class=\"hljs-selector-tag\">b</span> = <span class=\"hljs-number\">3</span><br>      <span class=\"hljs-selector-tag\">var</span> c = <span class=\"hljs-number\">4</span><br>      let d = <span class=\"hljs-number\">5</span><br>      console<span class=\"hljs-selector-class\">.log</span>(a)<br>      console<span class=\"hljs-selector-class\">.log</span>(b)<br>    &#125;<br>    console<span class=\"hljs-selector-class\">.log</span>(b) <br>    console<span class=\"hljs-selector-class\">.log</span>(c)<br>    console<span class=\"hljs-selector-class\">.log</span>(d)<br>&#125;   <br><span class=\"hljs-function\"><span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span></span><br></code></pre></td></tr></table></figure>\n\n<p>当进入这个foo函数时，会创建该函数的执行上下文，首先会将所有的var变量定义存储在执行上下文的变量环境中，同时将属于函数作用域的let or const 变量存储在执行上下文的词法环境中，如图所示。</p>\n<p><img src=\"/images/react/2022011001.png\"></p>\n<p>此时该函数的执行上下文环境已经定义完成，就需要使用JavaScript引擎执行代码，当执行到函数内部的第一个块级作用域<code>&#123;&#125;</code>时，foo函数的执行上下文如图所示。</p>\n<p><img src=\"/images/react/2022011002.png\"></p>\n<p>此时var变量a和let变量b已经被赋值。而由于进入了let的作用域，而在词法环境中创建了一个新栈，存储该块级作用域中的变量。</p>\n<p>之后当执行到块级作用域中的<code>console.log(a)</code>时，JavaScript引擎就会按照以下步骤来搜索变量。</p>\n<p><img src=\"/images/react/2022011003.png\"></p>\n<p>当执行完块级作用域时，词法环境中相应区间就会从栈顶弹出，如图所示。</p>\n<p><img src=\"/images/react/2022011004.png\"></p>\n<p>如下截图所示为改代码的输出结果。</p>\n<p><img src=\"/images/react/2022011005.png\"></p>\n<p>最后因为块级作用域所占内存已经销毁，所以找不到该let变量。</p>\n<h3 id=\"3-4-思考题\"><a href=\"#3-4-思考题\" class=\"headerlink\" title=\"3.4 思考题\"></a>3.4 思考题</h3><p>观察以下代码的输出结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> myname= <span class=\"hljs-string\">&#x27;极客时间&#x27;</span><br>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(myname) <br>  <span class=\"hljs-keyword\">let</span> myname= <span class=\"hljs-string\">&#x27;极客邦&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>会出现以下报错。</p>\n<p><img src=\"/images/react/2022011006.png\"></p>\n<p>因为在块级作用域中，从<code>开始到let myname= &#39;极客邦&#39;</code>代码之间会形成一个暂时性死区，如果中间去访问变量<code>myname</code>，会报初始化之前不能访问<code>myname</code>的错误。</p>\n<h2 id=\"4-作用域链和闭包\"><a href=\"#4-作用域链和闭包\" class=\"headerlink\" title=\"4.作用域链和闭包\"></a>4.作用域链和闭包</h2><h3 id=\"4-1-作用域链\"><a href=\"#4-1-作用域链\" class=\"headerlink\" title=\"4.1 作用域链\"></a>4.1 作用域链</h3><p>当涉及到多个作用域中访问变量的情况就要提到作用域链。像以下代码。</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs isbl\"><span class=\"hljs-variable\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">bar</span>() &#123;</span><br><span class=\"hljs-function\">    <span class=\"hljs-variable\">console.log</span>(<span class=\"hljs-variable\">myName</span>)</span><br>&#125;<br><span class=\"hljs-variable\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">foo</span>() &#123;</span><br><span class=\"hljs-function\">    <span class=\"hljs-variable\">var</span> <span class=\"hljs-variable\">myName</span> = <span class=\"hljs-string\">&quot; 极客邦 &quot;</span></span><br><span class=\"hljs-function\">    <span class=\"hljs-title\">bar</span>()</span><br>&#125;<br><span class=\"hljs-variable\">var</span> <span class=\"hljs-variable\">myName</span> = <span class=\"hljs-string\">&quot; 极客时间 &quot;</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">foo</span>()</span><br></code></pre></td></tr></table></figure>\n\n<p>该代码在bar函数中会输出myName的值，根据上面几节所学，该代码会生成以下的执行上下文调用栈。</p>\n<p><img src=\"/images/react/2022011007.png\"></p>\n<p>在执行代码阶段，bar函数的执行上下文中没有的变量myName应该在哪里找呢，这里其实每一个执行上下文的环境变量中都有一个称为<code>outer</code>的外部引用，当该作用域中没有需要的变量，则会向<code>outer</code>指向的作用域中去查找。那么bar函数的<code>outer</code>会指向哪里呢？如下图所示为各个执行上下文的变量环境outer的指向。</p>\n<p><img src=\"/images/react/2022011008.png\"></p>\n<p>为什么bar函数的outer指向的不是foo函数而是全局呢？这就涉及到<u>函数声明的位置</u>。函数声明的位置觉得了该函数的outer指向，根据该定理观察该代码，可以看出bar和foo函数的声明位置都是在全局，所以它们的outer指向也都是全局。如果bar函数在foo函数内部定义，则它的outer会指向foo函数。这涉及到了<u>词法作用域</u>。</p>\n<p>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</p>\n<p>如下图所示。</p>\n<p><img src=\"/images/react/2022011009.png\"></p>\n<p>该图所示的词法作用域链顺序是：foo 函数作用域—&gt;bar 函数作用域—&gt;main 函数作用域—&gt; 全局作用域。</p>\n<h3 id=\"4-2-块级作用域中的变量查找\"><a href=\"#4-2-块级作用域中的变量查找\" class=\"headerlink\" title=\"4.2 块级作用域中的变量查找\"></a>4.2 块级作用域中的变量查找</h3><p>观察以下代码：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\">function bar() &#123;<br>    var <span class=\"hljs-attr\">myName</span> = <span class=\"hljs-string\">&quot; 极客世界 &quot;</span><br>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">test1</span> = <span class=\"hljs-number\">100</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">myName</span> = <span class=\"hljs-string\">&quot;Chrome 浏览器 &quot;</span><br>        console.log(test)<br>    &#125;<br>&#125;<br>function foo() &#123;<br>    var <span class=\"hljs-attr\">myName</span> = <span class=\"hljs-string\">&quot; 极客邦 &quot;</span><br>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">test</span> = <span class=\"hljs-number\">2</span><br>    &#123;<br>        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">test</span> = <span class=\"hljs-number\">3</span><br>        bar()<br>    &#125;<br>&#125;<br>var <span class=\"hljs-attr\">myName</span> = <span class=\"hljs-string\">&quot; 极客时间 &quot;</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">myAge</span> = <span class=\"hljs-number\">10</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">test</span> = <span class=\"hljs-number\">1</span><br>foo()<br></code></pre></td></tr></table></figure>\n\n<p>分析其调用栈结构如下图所示：</p>\n<p><img src=\"/images/react/2022011010.png\"></p>\n<p>图中标出的顺序就是其查找变量的顺序。</p>\n<h3 id=\"4-3-闭包\"><a href=\"#4-3-闭包\" class=\"headerlink\" title=\"4.3 闭包\"></a>4.3 闭包</h3><p>观察以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">var</span> myName = <span class=\"hljs-string\">&quot; 极客时间 &quot;</span><br>    <span class=\"hljs-keyword\">let</span> test1 = <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">const</span> test2 = <span class=\"hljs-number\">2</span><br>    <span class=\"hljs-keyword\">var</span> innerBar = &#123;<br>        <span class=\"hljs-attr\">getName</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>            <span class=\"hljs-built_in\">console</span>.log(test1)<br>            <span class=\"hljs-keyword\">return</span> myName<br>        &#125;,<br>        <span class=\"hljs-attr\">setName</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">newName</span>)</span>&#123;<br>            myName = newName<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> innerBar<br>&#125;<br><span class=\"hljs-keyword\">var</span> bar = foo()<br>bar.setName(<span class=\"hljs-string\">&quot; 极客邦 &quot;</span>)<br>bar.getName()<br><span class=\"hljs-built_in\">console</span>.log(bar.getName())<br></code></pre></td></tr></table></figure>\n\n<p>其中，当执行代码时，会运行函数foo，也就会生成foo的执行上下文，但是执行完后foo的执行上下文就会在<u>内存中销毁</u>。但是在后面两行中却调用了foo的内部方法setName和getName，而这两个方法则使用了其外部函数foo函数的变量，此时变量myName和test1不会被销毁，而变成了<u>专属</u><code>bar.setName</code>和<code>bar.getName</code>方法能使用的变量，这种情况就可以把这些只能够被特定函数访问的变量集合称之为<u>闭包</u>。</p>\n<p><img src=\"/images/react/2022011011.png\"></p>\n<p>那这些闭包是如何使用的呢？如下图所示：</p>\n<p><img src=\"/images/react/2022011012.png\"></p>\n<p>据图可知其执行顺序为setName函数执行上下文-&gt;该函数的闭包-&gt;全局执行上下文。</p>\n<p>也可以利用浏览器中的开发者工具来跟踪其查找变量顺序，如图所示。</p>\n<p><img src=\"/images/react/2022011013.png\"></p>\n<h3 id=\"4-4-闭包回收\"><a href=\"#4-4-闭包回收\" class=\"headerlink\" title=\"4.4 闭包回收\"></a>4.4 闭包回收</h3><p>如果引用闭包的函数是全局变量，那么该闭包就会一直存在直到页面关闭，如果引用闭包的函数是局部变量，那么该闭包会随着函数的销毁而销毁。所以使用闭包需要注意：<u>当闭包会一直使用则定义其函数为全局变量，否则就定义为局部变量。</u></p>\n<h3 id=\"4-5-思考题\"><a href=\"#4-5-思考题\" class=\"headerlink\" title=\"4.5 思考题\"></a>4.5 思考题</h3><p>观察下面代码，其输出结果是什么，会形成闭包吗？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> bar = &#123;<br>    <span class=\"hljs-attr\">myName</span>:<span class=\"hljs-string\">&quot;time.geekbang.com&quot;</span>,<br>    <span class=\"hljs-attr\">printName</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>        <span class=\"hljs-built_in\">console</span>.log(myName)<br>    &#125;    <br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">let</span> myName = <span class=\"hljs-string\">&quot; 极客时间 &quot;</span><br>    <span class=\"hljs-keyword\">return</span> bar.printName<br>&#125;<br><span class=\"hljs-keyword\">let</span> myName = <span class=\"hljs-string\">&quot; 极客邦 &quot;</span><br><span class=\"hljs-keyword\">let</span> _printName = foo()<br>_printName()<br>bar.printName()<br></code></pre></td></tr></table></figure>\n\n<p>这道题其实是个障眼法，只需要确定好函数调用栈就可以很轻松的解答，调用了foo()后，返回的是bar.printName，后续就跟foo函数没有关系了，所以结果就是调用了两次bar.printName()，根据词法作用域，<u>结果都是“极客邦”，也不会形成闭包</u>。</p>\n<p>如下图所示。</p>\n<p><img src=\"/images/react/2022011014.png\"></p>\n<p>（其实我也有点糊涂了。）</p>\n<h2 id=\"5-this\"><a href=\"#5-this\" class=\"headerlink\" title=\"5.this\"></a>5.this</h2><h3 id=\"5-1-JavaScript中的this是什么？\"><a href=\"#5-1-JavaScript中的this是什么？\" class=\"headerlink\" title=\"5.1 JavaScript中的this是什么？\"></a>5.1 JavaScript中的this是什么？</h3><p>this其实和执行上下文有关，执行上下文一共有三种，分别是<u>全局执行上下文、函数执行上下文和eval执行上下文</u>。每个执行上下文中都包括我们已经知道的变量环节、词法环境以及outer。除此之外，this也包含在执行上下文中。所以根据不同的执行上下文，this也有所不同。</p>\n<h3 id=\"5-2-全局执行上下文中的this\"><a href=\"#5-2-全局执行上下文中的this\" class=\"headerlink\" title=\"5.2 全局执行上下文中的this\"></a>5.2 全局执行上下文中的this</h3><p>直接在浏览器的开发者工具控制台中输入<code>console.log(this)</code>，可以看到输出的是window对象，因此可知，<u>全局执行上下文中的this指向window对象</u>，这也是this和作用域链的唯一交点，作用域链最底端包含了window对象。</p>\n<h3 id=\"5-3-函数执行上下文中的this\"><a href=\"#5-3-函数执行上下文中的this\" class=\"headerlink\" title=\"5.3 函数执行上下文中的this\"></a>5.3 函数执行上下文中的this</h3><p>观察以下这段代码：</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs isbl\"><span class=\"hljs-variable\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">foo</span>()&#123;</span><br><span class=\"hljs-function\">  <span class=\"hljs-variable\">console.log</span>(<span class=\"hljs-variable\">this</span>)</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-title\">foo</span>()</span><br></code></pre></td></tr></table></figure>\n\n<p>观察输出结果会发现，这个this依旧是指向window。那么可以改变函数内的this指向吗？可以的，有以下几种方法。</p>\n<p><strong>1.通过函数的call方法设置</strong></p>\n<p>如下列代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> bar = &#123;<br>  <span class=\"hljs-attr\">myName</span> : <span class=\"hljs-string\">&quot; 极客邦 &quot;</span>,<br>  <span class=\"hljs-attr\">test1</span> : <span class=\"hljs-number\">1</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>  <span class=\"hljs-built_in\">this</span>.myName = <span class=\"hljs-string\">&quot; 极客时间 &quot;</span><br>&#125;<br>foo.call(bar)<br><span class=\"hljs-built_in\">console</span>.log(bar)<br><span class=\"hljs-built_in\">console</span>.log(myName)<br></code></pre></td></tr></table></figure>\n\n<p>通过<code>foo.call(bar)</code>使得foo函数执行上下文中的this指向了bar。除了<u>call方法</u>，也可以使用<u>bind和apply方法</u>来设置函数执行上下文中的this。</p>\n<p><strong>2.通过对象调用方法设置</strong></p>\n<p>如下代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myObj = &#123;<br>  <span class=\"hljs-attr\">name</span> : <span class=\"hljs-string\">&quot; 极客时间 &quot;</span>, <br>  <span class=\"hljs-attr\">showThis</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>)<br>  &#125;<br>&#125;<br>myObj.showThis()<br></code></pre></td></tr></table></figure>\n\n<p>当执行<code>myObj.showThis()</code>时就会使得<code>showThis</code>中的<code>this</code>指向<code>myObj</code>对象。</p>\n<p><strong>3.通过构造函数中设置</strong></p>\n<p>如下代码所示：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">CreateObj</span><span class=\"hljs-params\">()</span></span>&#123;<br>  <span class=\"hljs-keyword\">this</span>.name = <span class=\"hljs-string\">&quot; 极客时间 &quot;</span><br>&#125;<br><span class=\"hljs-keyword\">var</span> myObj = <span class=\"hljs-keyword\">new</span> CreateObj()<br></code></pre></td></tr></table></figure>\n\n<p>使用<code>new</code>关键字来使函数中的this指向了新对象本身。</p>\n<h3 id=\"5-3-this的涉及缺陷以及应对方案\"><a href=\"#5-3-this的涉及缺陷以及应对方案\" class=\"headerlink\" title=\"5.3 this的涉及缺陷以及应对方案\"></a>5.3 this的涉及缺陷以及应对方案</h3><p>比方说嵌套函数中的this<u>没有继承关系</u>，如段代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myObj = &#123;<br>  <span class=\"hljs-attr\">name</span> : <span class=\"hljs-string\">&quot; 极客时间 &quot;</span>, <br>  <span class=\"hljs-attr\">showThis</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>)<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\"></span>)</span>&#123;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>)&#125;<br>    bar()<br>  &#125;<br>&#125;<br>myObj.showThis()<br></code></pre></td></tr></table></figure>\n\n<p>直觉上我们会以为bar函数内部的this也是指向showThis也就是它的外部函数，但其实它指向的是window，解决方法有两种，第一种是在bar函数外使用<code>var that=this</code>，在bar函数内使用that就代指showThis中的this，如下代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myObj = &#123;<br>  <span class=\"hljs-attr\">name</span> : <span class=\"hljs-string\">&quot; 极客时间 &quot;</span>, <br>  <span class=\"hljs-attr\">showThis</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>)<br>    <span class=\"hljs-keyword\">var</span> that = <span class=\"hljs-built_in\">this</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>      that.name = <span class=\"hljs-string\">&quot; 极客邦 &quot;</span><br>    &#125;<br>    bar()<br>  &#125;<br>&#125;<br>myObj.showThis()<br><span class=\"hljs-built_in\">console</span>.log(myObj.name)<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">window</span>.name)<br></code></pre></td></tr></table></figure>\n\n<p>第二个方法是使用ES6中的<u>箭头函数</u>来声明bar函数，如下段代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myObj = &#123;<br>  <span class=\"hljs-attr\">name</span> : <span class=\"hljs-string\">&quot; 极客时间 &quot;</span>, <br>  <span class=\"hljs-attr\">showThis</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>)<br>    <span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-function\">()=&gt;</span>&#123;<br>      <span class=\"hljs-built_in\">this</span>.name = <span class=\"hljs-string\">&quot; 极客邦 &quot;</span><br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>)<br>    &#125;<br>    bar()<br>  &#125;<br>&#125;<br>myObj.showThis()<br><span class=\"hljs-built_in\">console</span>.log(myObj.name)<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">window</span>.name)<br></code></pre></td></tr></table></figure>\n\n<p>因为箭头函数不会创建自身的执行上下文。</p>\n"},{"title":"宏观视角下的浏览器","date":"2021-12-22T00:35:11.000Z","_content":"\n------\n\n*本文来源于http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。*\n\n------\n\n## 1.浏览器发展史\n\n### 1.1 单进程浏览器\n\n2007年之前，市面上的浏览器都是单进程的，单进程浏览器把需要运行的所有功能模块都放在一个进程里，而模块分为几个线程在进程里运行，这会导致如下几个问题。\n\n**不稳定问题**：一个线程崩溃就会导致整个进程崩溃，也就是整个浏览器崩溃。\n\n**不流畅问题**：单进程浏览器中，页面模块在一个线程中运行，如果该线程中有一个<u>无限循环的脚本</u>，那页面的其他模块就无法运行，会导致页面无法加载的问题。除此之外，单进程浏览器很容易出现页面<u>内存泄漏</u>从而导致计算机内存占用越来越高，浏览器运行越来越慢的问题。\n\n**不安全问题**：在单进程浏览器中很容易让一些<u>恶意插件或脚本</u>释放病毒，获得计算机重要信息。\n\n### 1.2 早期多进程浏览器\n\n2008年Chrome的发布宣告浏览器进入多进程时代，早期的浏览器多进程架构是将各个插件从浏览器主进程中分离开独立成单个的进程，也将每个页面线程从主进程分离变成独立的每个渲染进程。这些被分割的进程都运行在<u>沙箱</u>中，进程之间通过<u>IPC</u>（进程间通信）进行通信。这种多进程模块的好处是让各个功能模块相互隔离，这样一个模块的问题导致的奔溃不会导致整个浏览器崩溃，解决了不稳定性问题。并且也因为独立的进程，使得一个页面脚本出现问题时不会影响整个浏览器以及独立的其他页面的运行（每个页面都是一个渲染进程），争对内存泄漏也可以通过关闭一个页面回收内存的方式解决，这就解决了不稳定性问题。此外，因为独立出来的功能模块进程都在sandbox（沙箱）中运行，受到一定的限制，无法读取计算机敏感位置的数据，所以安全性问题也得到了解决。\n\n### 1.3 目前多进程浏览器\n\n对比于早期的多进程架构，目前的Chrome又独立于浏览器主进程之外还多出了几个进程，包括<u>GPU进程、网络服务进程、缓存服务进程、备用渲染进程</u>。\n\n打开Chrome的任务管理器，下面显示的就是chrome浏览器中运行的进程，如图所示：\n\n![](/images/react/2021122201.png)\n\n多进程模型提高了浏览器的稳定性、流畅性以及安全性，但也带来了一定的问题，比如它占用了更高的资源，因为每个进程都会包含公共基础结构的副本；以及该模型有着更复杂的体系架构，这意味着浏览器各模块之间的<u>耦合性高、扩展性差</u>等问题。面对这些问题，现在的浏览器公司一直都在寻找更好的处理方法。\n\n### 1.4 未来面向服务的架构\n\n在2016年，Chrome团队就使用<u>面向服务架构</u>（SOA）的思想设计了新的Chrome架构，也就是说未来的浏览器会朝着SOA的方向发展，原来的各个模块会被重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务就必须使用定义好的接口，这样就可以建立一个<u>更加内聚、更低的耦合度，更加易于维护和扩展</u>的系统。但这必将是一个漫长的过程。\n\n## 2.数据包从服务端完整传达给客服端浏览器的过程\n\n打开一个网页会显示各种信息，这些信息都是从这个网站的服务器端发送过来的，那么这些信息又是怎么包装完整地传达到客户端的浏览器上的呢？\n\n### 2.1 数据包从服务端送达到目的主机\n\n数据必定是先从服务器运输到客户端的主机，才能从主机上升到具体的应用程序。两个主机之间的信息通信在网络体系模型的<u>网络层</u>中实现的，其中数据的运输则依靠于网络层中的<u>IP协议</u>。网络层传输的数据是以“分组”形式存在的，每一个分组都有一个头部，头部包含了源主机和目的主机的<u>IP地址</u>，依靠IP地址就可以实现两个主机之间的通信。\n\n### 2.2 数据包从客户端主机到应用进程\n\n通过网络层的IP协议可以实现主机之间的网络通信，但是IP协议是个相对底层的协议，无法实现应用进程之间的通信，这需要通过网络层上一层的<u>传输层</u>才能实现通信。传输层通常有两个常用的协议，分别是<u>UDP协议</u>和<u>TCP协议</u>，通过两个协议在传输层产生的数据包都有一个头部，头部都包含了<u>源端口号和目的端口号</u>的信息，这个端口号就是具体的应用程序在主机上的端口号，根据端口号就可以实现数据包从客户端主机到应用进程的运输。\n\n### 2.3 数据包可靠完整地被传达\n\n上节提到的UDP协议和TCP协议都是在传输层的协议，它们之间的区别是：UDP协议追求的是<u>快速</u>地传输，而TCP协议追求的是<u>完整</u>地传输，这就会导致UDP协议传输的数据很容易丢失，而TCP协议却保护了数据的完整性。在浏览器中运用到的应用层协议，无论是http协议还是WebSocket协议都使用TCP协议传输数据，从而保证了数据的完整性。那么TCP协议是如何做到完整传输数据的呢？\n\n区别于UDP协议，基于TCP协议有更复杂更加多数据的头部，包括数据包序号、确认号、数据偏移等信息，这些信息能够将混乱的数据包组合成一个完整的文件，并且对于缺失的数据包，TCP提供了重传机制。\n\n此外，为了保证数据传输的可靠性，进行TCP协议实际数据的传输前后分别由“三次握手”和“四次挥手来进行可靠的连接建立和断开。\n\nTCP协议需要进行三次握手的原因是为了防止失效的连接请求到达服务器，让服务器错误打开连接（具体详细解析可见”计算机网络基础知识点“的7.4节）。\n\n## 3.HTTP请求流程\n\nHTTP协议是<u>应用层</u>协议，是浏览器使用最广泛的协议，通过它可以实现浏览器向服务器获取相关资源。HTTP协议建立在TCP协议基础之上，上一节已经知道通过TCP协议实现数据从服务器传输到浏览器中，那么浏览器又是怎么通过HTTP协议发送请求的呢？这节主要讲HTTP请求的具体流程。\n\n### 3.1 构建请求\n\n通常访问一个网站的第一步就是在浏览器的地址栏中输入一个网站地址并点击跳转，这时就会构建一个请求，但是这个请求还在浏览器端，并没有开始运输。\n\n### 3.2 查找缓存\n\n在发送请求之前，浏览器会根据已经构建好的请求的基本数据在<u>缓存</u>中进行查找，如果有所需的数据，则它会直接拦截结束该请求，直接使用缓存中的副本，这样就能缓解服务器压力，也加快了浏览器上资源加载速度。\n\n### 3.3 获取服务端的IP地址和端口\n\n如果缓存中没有所需的数据，则要开始发送请求，但是根据第2节可知，实现一个数据包的运输需要知道对方主机的IP地址和端口号，所以需要先获取IP地址以及端口号。如何通过一个URL网址获得IP地址就要涉及<u>DNS协议</u>，浏览器已知的URL又被称为域名，域名和IP地址呈现一对一映射关系，通过DNS协议访问<u>域名服务器</u>可以获得所需要的IP地址，或者如果之前该浏览器访问过某网页，那么缓存中可能会存有该网络的IP地址。对于端口号，如果URL中没有特别指明端口号，那么HTTP协议默认的端口号是<u>80</u> 。\n\n### 3.4 等待TCP队列，建立TCP连接\n\n浏览器一般都有一个限制，即同一域名同时只能建立一定数量的TCP连接，如果超过这个数量，只能进入队列进行等待，若未超过这个数量，则能直接建立TCP连接，TCP连接的具体方式如第2大节所示。\n\n### 3.5 发送HTTP请求\n\n建立了TCP连接，实现了TCP的三次握手，才能真正的发送HTTP请求。一个HTTP请求报文由<u>请求行、请求头部和请求体</u>组成，具体如下图所示：\n\n![](/images/react/2021122202.png)\n\n其中，请求行包括了<u>请求方法</u>（GET/POST/DELETE...）、<u>请求URL</u>以及<u>HTTP协议版本号</u>。请求头部包括了一些基础信息，比如浏览器所使用的操作系统、浏览器内核等信息。\n\n### 3.6 服务器返回请求响应\n\n服务器接收到浏览器的HTTP请求后，则会处理相应请求，如果服务器选择响应某些请求，就会发送客户端浏览器以HTTP响应数据信息，其中包括<u>响应行、响应头部和具体的响应体</u>。\n\n其中响应行包括<u>HTTP协议版本</u>和<u>状态码</u>信息，比如状态码为200则表示处理成功，状态码为404则表示没有响应页面。\n\n### 3.7 断开连接\n\n通常情况下，一旦服务器向客户端返回了请求数据，就会断开TCP协议，如果浏览器或服务器在其HTTP请求头部或者响应头部中加上了`Connection:keep-alive`，则该TCP连接就会保持打开状态。\n\n### 3.8 重定向\n\n有时候会出现这种情况：用户在浏览器的地址栏中输入的URL在网页打开后会变成另外一个，这就涉及到了重定向。比如在我的火狐浏览器的地址栏中输入`sixteentime.github.io`，但是它马上跳转成网站`sixteentime.xyz`，这就是一个重定向的过程，可以打开该网站打开时的第一个响应报文，观察其响应头信息中有这样一行信息:`Location: http://sixteentime.xyz/ `这就执行了一个重定向流程，具体如下图所示：\n\n![](/images/react/2021122203.png)\n\n### 3.9相关问题\n\n**为什么很多网站第二次打开的速度会很快？**\n\n这是上面提到的浏览器<u>缓存机制</u>的原因。当网站第一次打开网站时，浏览器里没有该网站的缓存，浏览器则会发送请求给服务端请求数据，服务端返回数据给浏览器时，浏览器也会把页面数据存入缓存，然后在缓存的<u>生命周期</u>内再次打开该页面时，浏览器就不会发送请求给服务器而是直接使用缓存资源，这样就会使网站运行速度加快；若超过了这个生命周期，那么浏览器会担心这个缓存数据可能会过期，就会发送请求给服务器，如果服务器返回该缓存数据没有过期，那么浏览器会继续使用缓存数据加载页面，这样的加载速度也会相对较快。\n\n当然，浏览器的缓存中还有域名与IP地址的映射信息，第二次打开页面不需要发送请求到域名服务器获取域名对应的IP地址，也可以加快网页的加载速度。\n\n**网站的登录状态是如何保持的？**\n\n一般而言，服务器为了防止非系统用户的恶意攻击，对系统的访问方法都需要用户登陆信息，可是在浏览器中操作的用户只在最开始的时候输入账号密码进行登陆，之后在浏览器中的相关操作产生的请求都没有输入账号密码来证明信息，那么服务器是如何知道是哪个用户在进行请求访问呢？这就涉及到了HTTP的<u>Cookie</u>功能。\n\n当用户登陆网站输入账号密码信息并发送访问请求时，服务器收到相关数据会进行验证，若身份验证成功则会在返回的响应数据的响应头中字段`Set-Cookie`添加相关内容来表示用户身份信息，浏览器收到响应数据后会把对应的Cookie信息保存在本地。当用户登陆成功后在该网页进行其他操作而产生请求时，产生的请求报文的请求头上就会有`Cookie`字段信息，服务器接收到请求报文后，当核实Cookie内的字段能够核实用户身份，并且判断该用户处于登陆状态后，就会成功返回相关的数据信息。这就是网站通过Cookie保持用户登陆状态的原因。\n\n## 4.从浏览器中输入URL到页面展示这中间发送了什么？\n\n这同时也是个常见的面试问题。\n\n上一大节中虽然详细讲述了HTTP协议请求发送和接收的流程，但是在上一节的描述中把浏览器的相关行为当成一个整体行为，从第一大节中我们可以了解到现在的浏览器是多进程模式，浏览器主进程负责其他子进程的管理、用户交互和文件储存的功能。从输入URL到页面展示的过程中主要涉及了三个进程之间的交互和运行，分别是<u>浏览器主进程、网络进程以及渲染进程</u>。\n\n具体这三个进程在这个过程中的运行和交互如下图所示：\n\n![](/images/react/2021122204.png)\n\n根据这张图引出一个新概念：导航。用户发出URL请求到页面开始解析的这个过程，就叫做导航。接下来将根据这张图，详细解析这一过程到底发生了什么。\n\n### 4.1 用户输入\n\n用户在地址栏中可能会输入一个网站地址或者只是单纯搜索一些关键词。浏览器主进程会解析用户输入的内容，如果不符合URL规范，则会使用浏览器的默认搜索引擎来合成新的带搜索内容的URL；如果符合URL规范，则会根据规则加上相关协议，比如http://或者https://，合成完整的URL。\n\n当用户输入完成并敲击回车键后，浏览器并没有直接跳转到相关页面，中间有一段过渡时期，如下图所示：\n\n![](/images/react/2021122205.png)\n\n在该图的操作中，在浏览器地址栏中已经输入新的地址并键入回车，标签栏中可以看见页面正在加载的状态，但是网页内容并没有更新，还是原网页，这是因为直到浏览器等待到确认提交文档阶段，页面内容才会被替换成新的页面。\n\n### 4.2 URL请求过程\n\n键入URL后就进入了请求过程，这也是导航流程的起始阶段。浏览器主进程通过IPC把URL请求发送至<u>网络进程</u>，在网络进程中真正的发送URL请求。\n\n首先，网络进程收到URL请求后，会先在浏览器<u>缓存</u>中查找是否有需要的资源，若有则把该资源直接返回给浏览器主进程，若没有再进行网络请求流程。\n\n在真正进入网络请求时先要进行<u>DNS解析</u>，通过浏览器缓存或者请求域名服务器获得URL的域名对应的IP地址。如果建立的是HTTPS请求，还需要先建立TLS连接。\n\n然后就是建立<u>TCP连接</u>，成功连接后，网络进程真正发送HTTP请求信息给服务器，服务器接收到请求进行对应处理后会返回响应数据给<u>网络进程</u>，网络进程收到数据后开始解析响应数据内容。\n\n如果服务器返回的响应数据的状态码是<u>301或302</u>，则表示当前的URL需要<u>重定位</u>到其他的URL，这时候网络进程根据响应数据头部的`Location`字段信息获取重定位地址，再次发送HTTP请求。\n\n如果服务器返回的响应数据的状态码是<u>200</u>，则说明服务器成功返回了相关的数据信息，浏览器可以继续处理请求。这时网络进程会分析响应数据的<u>类型</u>，一般来说接收到的响应数据有两种类型，查看响应头上的`Content-Type`字段，这个字段决定了响应数据的类型，若该字段的内容是`application/octet-stream`，则说明是字节流类型数据，这种情况下，浏览器会按照下载类型来处理，同时URL请求的导航流程也就结束了。如果收到的信息是`Content-Type: text/html `，则说明该数据是html格式数据，网络进程会通知<u>浏览器主进程</u>进行渲染准备，浏览器就会继续进行导航流程。\n\n### 4.3 准备渲染进程\n\n一般情况下浏览器会给每一张页面分配一个渲染进程，但是有些浏览器会给属于同一站点的页面，并且后一张页面是在前面那张页面内打开的这样的情况下给这些页面分配同一个渲染进程。所以如果浏览器主进程接收到了网络进程需要准备渲染的信号，则会判断是否需要新增一个渲染进程，还是使用原来已有的渲染进程。\n\n### 4.4 提交文档\n\n这里所谓的“文档”是指URL请求的<u>响应体数据</u>。由浏览器主进程向渲染进程发出<u>“提交文档”</u>消息，<u>渲染进程</u>接收到消息后会和<u>网络进程</u>建立传输数据的“管道”。等文档数据从网络进程到渲染进程传输完成后，渲染进程会返回<u>“确认提交”</u>消息给浏览器主进程，当浏览器主进程接收到这个消息后，会更新浏览器界面状态，包括<u>安全状态、地址栏URL、前进后退历史状态、并且更新Web页面</u>。\n\n### 4.5 渲染阶段\n\n当渲染进程发送“确认提交”的信息后，它便开始对收到的数据进行页面分析和资源加载，一旦页面生成完成，渲染进程会发送一个消息给浏览器主进程，浏览器主进程接收到消息后，就会停止标签栏上的<u>加载动画</u>。这样，一个完整的页面就展示完成了。\n\n### 4.6 总结\n\n简化这个过程来回答这个问题，可以这样总结回答：\n\n**第一步**是用户在地址栏中的<u>输入</u>，浏览器主进程会根据输入的消息自动完善或者转化URL地址，生成对应的<u>HTTP请求报文</u>。**第二步**浏览器主进程将请求发送给<u>网络进程</u>，网络进程先判断<u>缓存</u>中是否有需要的资源，若有则返回该资源给浏览器主进程，若无则准备发送HTTP请求。**第三步**在发送请求之前先确认服务器的<u>IP地址</u>，在缓存中寻找域名映射IP地址信息，若没有需要的数据则发送请求到域名服务器获取需要的IP地址，如果是URL中显示是HTTPS协议，则还要先建立TLS连接。**第四步**建立<u>TCP</u>连接，等待TCP连接成功后真正发送HTTP请求到服务端，并等待服务端返回响应包，若响应数据中的<u>状态码</u>是301或者302则说明需要<u>重定向</u>URL，则根据响应头里的`Locstion`的URL再次发送HTTP请求。若成功返回所需的响应包，先分析该响应数据的<u>数据格式</u>，网络进程需要解析响应头部的`Content-Type`字段，若是字节流类型，则会当作是需要下载的资源进行下载，则该流程结束；若是html类型则要通知浏览器主进程进行<u>渲染准备</u>。**第五步**浏览器主进程会检查url是否和之前打开的渲染进程有相同的根域名，若相同则复用原来的进程，不同则开启新的进程（这一步因浏览器而异，而且现在的浏览器好像只要是新的页面都会分配一个新的渲染进程）。**第六步**浏览器会发送<u>“提交文档”</u>消息给相应的渲染进程，渲染进程接收到后就会和网络进程建立传输数据的“管道”。直到它接受完数据后，渲染进程会向浏览器主进程发送<u>“确认提交”</u>消息，浏览器主进程接收到该消息后会更新浏览器界面的一些状态包括安全状态、地址栏url、前进后退的历史状态以及Web界面。到这里导航流程就结束了，直到渲染进程完全解析和加载完资源，成功渲染页面之后会发送消息通知浏览器主进程，浏览器主进程收到消息后就会停止标签栏中加载动画，这样一个页面就完成展示了。\n\n## 5.页面渲染流程\n\n上一节我们了解了从输入URL到生成一张页面的导航阶段的流程，导航阶段之后则是页面的渲染流程，此时渲染进程已经获取了生成一张页面所需要的资源包括HTML、CSS和JavaScript，那么这些文件又是如何被解析生成一张可视化页面的呢？\n\n由于渲染机制非常复杂，渲染模块会在执行的过程中被划分为很多子阶段，最后输出像素，这一过程被称为渲染流水线。按照渲染的时间顺序可以将该流水线分为这几个子阶段：<u>构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化以及合成显示</u>。值得注意的是，每个子阶段都有其<u>输入</u>和<u>输出</u>内容以及处理过程（我觉得这句话像句废话，但是看到最后我发现这句话很重要）。\n\n### 5.1 构建DOM树\n\n浏览器无法直接理解HTML文件，需要将HTML转化成其能够理解的DOM树结构，可见下图所示。\n\n![](/images/react/2021122301.png)\n\nDOM树区分于HTML的是，DOM树是保持在内存中的树状结构，可以通过JavaScipt来查询或修改其内容。\n\n可以在Chrome浏览器中打开一张页面的开发者工具，点击控制台，在控制台中输入`document`并敲击回车键，就会呈现该页面HTML对应的DOM树，也可以在控制台中通过获取DOM树的某一节点来修改它的值，如下图所示。\n\n![](/images/react/2021122302.png)\n\n### 5.2 样式计算\n\n样式计算是为了计算每一个DOM节点每个元素的具体样式。\n\n首先先要**把CSS转化为浏览器能够理解的结构**。CSS在一张网页中可能有多种呈现方式，包括引用外部css文件，在标签`<style>`中的CSS，以及在元素的`style`属性中填写的CSS。当渲染引擎接收到CSS文本时，会将其转化为浏览器可以理解的<u>styleSheets</u>结构，如下图所示，在控制台中输入`document.styleSheets`可以查看styleSheets结构。\n\n![](/images/react/2021122303.png)\n\n然后**将样式表中的属性值转化为标准形式**。比方说表达颜色可以有多种方式，例如`red`、`rgb(255,0,0)`，`#ff0000`都可以表示红色，所以为了统一展示需要将这些值标准化。\n\n最后**计算出DOM树中每个节点的具体样式**，由于CSS具有<u>继承性</u>，即子节点会继承父节点的样式，以及CSS的其他<u>层叠规则</u>，所以需要计算每个节点最后真正的样式值。这里的层叠规则是CSS的核心，之后具体复习CSS时会展开讲。\n\n### 5.3 布局阶段\n\n上面两小节以及完成了DOM树的构建以及DOM树中元素对应样式表的构建，接下来要进行布局阶段，要获得每个可见节点在页面上的具体位置。\n\n**创建布局树**：在构建DOM树中会发现有很多标签如`head`标签都是不可见的，以及在创建样式表时也发现有一些元素带有例如`display:none`的属性，也是不可见的，所以需要建立一个只包含可见元素的布局树，如下图所示，就是通过DOM树和对应的样式表创建出的布局树。\n\n![](/images/react/2021122304.png)\n\n**布局计算**：现在已有一棵布局树，然后就要进行布局计算，这一过程比较复杂，后面的章节会详细分析，总之在进行布局计算后会把运算结果重新写回布局树中。所以<u>这一阶段布局树既是输入内容又是输出结果</u>。\n\n### 5.4 分层\n\n因为页面中有很多复杂的效果，比如页面滚动、3D转换等，所以为了方便实现这些效果，渲染引擎还需要生成一棵<u>图层树（LayerTree）</u>。打开Chrome的开发者工具，选择”Layers“标签，若没有该标签，则按下图所示操作添加该标签：\n\n![](/images/react/2021122305.png)\n\n比如，下面这个页面就有5个图层，如下图所示。\n\n![](/images/react/2021122306.png)\n\n不是布局树上的每一个节点都会被分配一个图层的，如果某些节点没有被分配图层，那它就属于父节点的图层，所以最终每个布局树上的节点都会直接或间接地从属于某一图层。符合以下两个条件之一的元素可以被提升为单独一个图层。\n\n**拥有层叠上下文属性的元素**：比如定义position属性、z-index属性、filter属性以及opacity属性。\n\n**需要裁剪的元素**：当元素里的内容超出元素本身大小时就需要被裁剪。\n\n确定好哪些节点会被分配新的图层后，就会生成一个图层树。图层树不一定和布局树的节点一一对应，但是<u>布局树上的每个节点一定都属于某一个图层</u>。\n\n### 5.5 绘制\n\n渲染引擎是通过构建<u>绘制列表</u>来实现具体的图层绘制过程的。绘制列表中每一个指令都代表一个绘制操作，通常要完成绘制一个元素需要好几条指令，因为通常一个元素会有背景、前景、边框等属性都需要单独的指令来实现。\n\n### 5.6 分块\n\n绘制列表只是用来记录绘制指令的列表，实际完成绘制操作的是渲染进程中的<u>合成线程</u>。当在渲染进程的主线程上完成绘制列表后，它会把该列表提交给合成线程。\n\n这里先引入一个<u>”视口“</u>的概念。一般一些页面是超过浏览器窗口大小的，它们也许会很长，也许会很宽，而视口就是窗口上可见的页面区域。如果一张页面非常长而视口非常小，而要完整绘制该页面的所有图层内容是没必要的，这会引起很大开销。基于这个原因，合成线程将图层划分为许多<u>图块(tile)</u>，这些图块的大小通常是256x256或者512x512。\n\n### 5.7 栅格化操作\n\n渲染进程中的合成线程会将分解出来的图块发送到<u>栅格化线程池</u>中，由一系列<u>栅格化线程</u>对这些图块进行处理。<u>栅格化</u>就是指将图块转化为<u>位图</u>，图块是栅格化执行的最小操作。而通常栅格化的过程会使用<u>GPU</u>加速实现，前面第一大节提过GPU有独立的进程，所以这涉及了跨进程操作。具体的处理交互过程如图所示。\n\n![](/images/react/2021122307.png)\n\n如图可知，位图是在GPU进程中生成并且保存的。\n\n### 5.8 合成和显示\n\n当所有图块都被光栅化成位块后，渲染进程的合成线程会发生给浏览器主进程一个绘制图块命令——\"<u>DrawQuad</u>\"。浏览器主进程里有个叫viz的组件，用来接收该命令，然后根据该命令将页面内容绘制到内存中，最后将内存显示在屏幕上。\n\n### 5.9 重排、重绘与合成\n\n以上就已经讲述了渲染流水线的具体过程，接下来提出三个重要概念，这些概念在之后的<u>Web优化</u>中非常重要，也经常被面试官提及。\n\n**重排**：顾名思义，就是重新排列了元素的布局。在实际情况中就是改变了元素的样式中几何位置相关的属性，比如`weight`、`height`、`margin`等。修改了这些属性，那么渲染流水线从样式计算到后面的布局阶段、分层阶段以及绘制等都需要改变，如下图所示。\n\n![]()\n\n根据该图也可以看出重排的开销非常大。\n\n**重绘**：顾名思义是改变某些元素的某些颜色，比如背景、字体颜色等样式。因为不会引起布局的变动所以重绘之后会直接跳过布局阶段和分层阶段，但绘制列表是需要改变的，具体如下图所示。\n\n![](/images/react/2021122309.png)\n\n虽然重绘也有一定大的开销，但是相比于重排开销会有所减少。\n\n**合成**：如果改变一些既不要布局也不需要绘制的属性，比如改变translate属性，渲染引擎就会直接跳过布局和绘制，而只执行后面的合成操作，具体如下图所示：\n\n![](/images/react/2021122310.png)\n\n根据上图可以得知，合成对比于重排和重绘开销最小。\n\n### 5.10 渲染流水线总结\n\n上面已经分析了渲染流水线的每一个具体过程，现在可以根据以下这张图来概括性地说明从HTML到一张页面经历了什么。\n\n![](/images/react/2021122311.png)\n\n渲染进程获得所需的HTML、CSS、JavaScript等资源后，1.将<u>HTML内容</u>转化为可以理解的<u>DOM树</u>。2.将有关的<u>CSS内容</u>转为能够理解的styleSheets格式，对其进行标准化处理，并且计算出每个DOM节点的样式值，生成DOM树每个元素的<u>样式表</u>。3.根据<u>DOM树和对应的样式表</u>创建DOM可见节点的布局树，并且计算节点的布局信息，生成一棵<u>布局树</u>。4.对<u>布局树</u>进行分层，生成<u>图层树</u>。5.为<u>每个图层</u>生成绘制列表，并且提交<u>绘制列表</u>给渲染进程的合成线程。6.合成线程将<u>图层</u>分为<u>图块</u>。7.合成线程再将生成的<u>图块</u>在光栅化线程池中将转化成<u>位图</u>，这里会使用GPU而和GPU进程进行交互。8.完成<u>位图</u>制作后，合成线程会发送绘制图块命令DrawQuad给浏览器主进程，浏览器主进程根据消息生成<u>页面</u>，并展示到显示器上。\n\n可以看出每一个阶段都是有输入输出的，这样一张页面的渲染流程也展示完成了。","source":"_posts/浏览器相关.md","raw":"---\ntitle: 宏观视角下的浏览器\ndate: 2021-12-22 08:35:11\ntags: [前端面试,浏览器]\ncategories:\n- 浏览器\n---\n\n------\n\n*本文来源于http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。*\n\n------\n\n## 1.浏览器发展史\n\n### 1.1 单进程浏览器\n\n2007年之前，市面上的浏览器都是单进程的，单进程浏览器把需要运行的所有功能模块都放在一个进程里，而模块分为几个线程在进程里运行，这会导致如下几个问题。\n\n**不稳定问题**：一个线程崩溃就会导致整个进程崩溃，也就是整个浏览器崩溃。\n\n**不流畅问题**：单进程浏览器中，页面模块在一个线程中运行，如果该线程中有一个<u>无限循环的脚本</u>，那页面的其他模块就无法运行，会导致页面无法加载的问题。除此之外，单进程浏览器很容易出现页面<u>内存泄漏</u>从而导致计算机内存占用越来越高，浏览器运行越来越慢的问题。\n\n**不安全问题**：在单进程浏览器中很容易让一些<u>恶意插件或脚本</u>释放病毒，获得计算机重要信息。\n\n### 1.2 早期多进程浏览器\n\n2008年Chrome的发布宣告浏览器进入多进程时代，早期的浏览器多进程架构是将各个插件从浏览器主进程中分离开独立成单个的进程，也将每个页面线程从主进程分离变成独立的每个渲染进程。这些被分割的进程都运行在<u>沙箱</u>中，进程之间通过<u>IPC</u>（进程间通信）进行通信。这种多进程模块的好处是让各个功能模块相互隔离，这样一个模块的问题导致的奔溃不会导致整个浏览器崩溃，解决了不稳定性问题。并且也因为独立的进程，使得一个页面脚本出现问题时不会影响整个浏览器以及独立的其他页面的运行（每个页面都是一个渲染进程），争对内存泄漏也可以通过关闭一个页面回收内存的方式解决，这就解决了不稳定性问题。此外，因为独立出来的功能模块进程都在sandbox（沙箱）中运行，受到一定的限制，无法读取计算机敏感位置的数据，所以安全性问题也得到了解决。\n\n### 1.3 目前多进程浏览器\n\n对比于早期的多进程架构，目前的Chrome又独立于浏览器主进程之外还多出了几个进程，包括<u>GPU进程、网络服务进程、缓存服务进程、备用渲染进程</u>。\n\n打开Chrome的任务管理器，下面显示的就是chrome浏览器中运行的进程，如图所示：\n\n![](/images/react/2021122201.png)\n\n多进程模型提高了浏览器的稳定性、流畅性以及安全性，但也带来了一定的问题，比如它占用了更高的资源，因为每个进程都会包含公共基础结构的副本；以及该模型有着更复杂的体系架构，这意味着浏览器各模块之间的<u>耦合性高、扩展性差</u>等问题。面对这些问题，现在的浏览器公司一直都在寻找更好的处理方法。\n\n### 1.4 未来面向服务的架构\n\n在2016年，Chrome团队就使用<u>面向服务架构</u>（SOA）的思想设计了新的Chrome架构，也就是说未来的浏览器会朝着SOA的方向发展，原来的各个模块会被重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务就必须使用定义好的接口，这样就可以建立一个<u>更加内聚、更低的耦合度，更加易于维护和扩展</u>的系统。但这必将是一个漫长的过程。\n\n## 2.数据包从服务端完整传达给客服端浏览器的过程\n\n打开一个网页会显示各种信息，这些信息都是从这个网站的服务器端发送过来的，那么这些信息又是怎么包装完整地传达到客户端的浏览器上的呢？\n\n### 2.1 数据包从服务端送达到目的主机\n\n数据必定是先从服务器运输到客户端的主机，才能从主机上升到具体的应用程序。两个主机之间的信息通信在网络体系模型的<u>网络层</u>中实现的，其中数据的运输则依靠于网络层中的<u>IP协议</u>。网络层传输的数据是以“分组”形式存在的，每一个分组都有一个头部，头部包含了源主机和目的主机的<u>IP地址</u>，依靠IP地址就可以实现两个主机之间的通信。\n\n### 2.2 数据包从客户端主机到应用进程\n\n通过网络层的IP协议可以实现主机之间的网络通信，但是IP协议是个相对底层的协议，无法实现应用进程之间的通信，这需要通过网络层上一层的<u>传输层</u>才能实现通信。传输层通常有两个常用的协议，分别是<u>UDP协议</u>和<u>TCP协议</u>，通过两个协议在传输层产生的数据包都有一个头部，头部都包含了<u>源端口号和目的端口号</u>的信息，这个端口号就是具体的应用程序在主机上的端口号，根据端口号就可以实现数据包从客户端主机到应用进程的运输。\n\n### 2.3 数据包可靠完整地被传达\n\n上节提到的UDP协议和TCP协议都是在传输层的协议，它们之间的区别是：UDP协议追求的是<u>快速</u>地传输，而TCP协议追求的是<u>完整</u>地传输，这就会导致UDP协议传输的数据很容易丢失，而TCP协议却保护了数据的完整性。在浏览器中运用到的应用层协议，无论是http协议还是WebSocket协议都使用TCP协议传输数据，从而保证了数据的完整性。那么TCP协议是如何做到完整传输数据的呢？\n\n区别于UDP协议，基于TCP协议有更复杂更加多数据的头部，包括数据包序号、确认号、数据偏移等信息，这些信息能够将混乱的数据包组合成一个完整的文件，并且对于缺失的数据包，TCP提供了重传机制。\n\n此外，为了保证数据传输的可靠性，进行TCP协议实际数据的传输前后分别由“三次握手”和“四次挥手来进行可靠的连接建立和断开。\n\nTCP协议需要进行三次握手的原因是为了防止失效的连接请求到达服务器，让服务器错误打开连接（具体详细解析可见”计算机网络基础知识点“的7.4节）。\n\n## 3.HTTP请求流程\n\nHTTP协议是<u>应用层</u>协议，是浏览器使用最广泛的协议，通过它可以实现浏览器向服务器获取相关资源。HTTP协议建立在TCP协议基础之上，上一节已经知道通过TCP协议实现数据从服务器传输到浏览器中，那么浏览器又是怎么通过HTTP协议发送请求的呢？这节主要讲HTTP请求的具体流程。\n\n### 3.1 构建请求\n\n通常访问一个网站的第一步就是在浏览器的地址栏中输入一个网站地址并点击跳转，这时就会构建一个请求，但是这个请求还在浏览器端，并没有开始运输。\n\n### 3.2 查找缓存\n\n在发送请求之前，浏览器会根据已经构建好的请求的基本数据在<u>缓存</u>中进行查找，如果有所需的数据，则它会直接拦截结束该请求，直接使用缓存中的副本，这样就能缓解服务器压力，也加快了浏览器上资源加载速度。\n\n### 3.3 获取服务端的IP地址和端口\n\n如果缓存中没有所需的数据，则要开始发送请求，但是根据第2节可知，实现一个数据包的运输需要知道对方主机的IP地址和端口号，所以需要先获取IP地址以及端口号。如何通过一个URL网址获得IP地址就要涉及<u>DNS协议</u>，浏览器已知的URL又被称为域名，域名和IP地址呈现一对一映射关系，通过DNS协议访问<u>域名服务器</u>可以获得所需要的IP地址，或者如果之前该浏览器访问过某网页，那么缓存中可能会存有该网络的IP地址。对于端口号，如果URL中没有特别指明端口号，那么HTTP协议默认的端口号是<u>80</u> 。\n\n### 3.4 等待TCP队列，建立TCP连接\n\n浏览器一般都有一个限制，即同一域名同时只能建立一定数量的TCP连接，如果超过这个数量，只能进入队列进行等待，若未超过这个数量，则能直接建立TCP连接，TCP连接的具体方式如第2大节所示。\n\n### 3.5 发送HTTP请求\n\n建立了TCP连接，实现了TCP的三次握手，才能真正的发送HTTP请求。一个HTTP请求报文由<u>请求行、请求头部和请求体</u>组成，具体如下图所示：\n\n![](/images/react/2021122202.png)\n\n其中，请求行包括了<u>请求方法</u>（GET/POST/DELETE...）、<u>请求URL</u>以及<u>HTTP协议版本号</u>。请求头部包括了一些基础信息，比如浏览器所使用的操作系统、浏览器内核等信息。\n\n### 3.6 服务器返回请求响应\n\n服务器接收到浏览器的HTTP请求后，则会处理相应请求，如果服务器选择响应某些请求，就会发送客户端浏览器以HTTP响应数据信息，其中包括<u>响应行、响应头部和具体的响应体</u>。\n\n其中响应行包括<u>HTTP协议版本</u>和<u>状态码</u>信息，比如状态码为200则表示处理成功，状态码为404则表示没有响应页面。\n\n### 3.7 断开连接\n\n通常情况下，一旦服务器向客户端返回了请求数据，就会断开TCP协议，如果浏览器或服务器在其HTTP请求头部或者响应头部中加上了`Connection:keep-alive`，则该TCP连接就会保持打开状态。\n\n### 3.8 重定向\n\n有时候会出现这种情况：用户在浏览器的地址栏中输入的URL在网页打开后会变成另外一个，这就涉及到了重定向。比如在我的火狐浏览器的地址栏中输入`sixteentime.github.io`，但是它马上跳转成网站`sixteentime.xyz`，这就是一个重定向的过程，可以打开该网站打开时的第一个响应报文，观察其响应头信息中有这样一行信息:`Location: http://sixteentime.xyz/ `这就执行了一个重定向流程，具体如下图所示：\n\n![](/images/react/2021122203.png)\n\n### 3.9相关问题\n\n**为什么很多网站第二次打开的速度会很快？**\n\n这是上面提到的浏览器<u>缓存机制</u>的原因。当网站第一次打开网站时，浏览器里没有该网站的缓存，浏览器则会发送请求给服务端请求数据，服务端返回数据给浏览器时，浏览器也会把页面数据存入缓存，然后在缓存的<u>生命周期</u>内再次打开该页面时，浏览器就不会发送请求给服务器而是直接使用缓存资源，这样就会使网站运行速度加快；若超过了这个生命周期，那么浏览器会担心这个缓存数据可能会过期，就会发送请求给服务器，如果服务器返回该缓存数据没有过期，那么浏览器会继续使用缓存数据加载页面，这样的加载速度也会相对较快。\n\n当然，浏览器的缓存中还有域名与IP地址的映射信息，第二次打开页面不需要发送请求到域名服务器获取域名对应的IP地址，也可以加快网页的加载速度。\n\n**网站的登录状态是如何保持的？**\n\n一般而言，服务器为了防止非系统用户的恶意攻击，对系统的访问方法都需要用户登陆信息，可是在浏览器中操作的用户只在最开始的时候输入账号密码进行登陆，之后在浏览器中的相关操作产生的请求都没有输入账号密码来证明信息，那么服务器是如何知道是哪个用户在进行请求访问呢？这就涉及到了HTTP的<u>Cookie</u>功能。\n\n当用户登陆网站输入账号密码信息并发送访问请求时，服务器收到相关数据会进行验证，若身份验证成功则会在返回的响应数据的响应头中字段`Set-Cookie`添加相关内容来表示用户身份信息，浏览器收到响应数据后会把对应的Cookie信息保存在本地。当用户登陆成功后在该网页进行其他操作而产生请求时，产生的请求报文的请求头上就会有`Cookie`字段信息，服务器接收到请求报文后，当核实Cookie内的字段能够核实用户身份，并且判断该用户处于登陆状态后，就会成功返回相关的数据信息。这就是网站通过Cookie保持用户登陆状态的原因。\n\n## 4.从浏览器中输入URL到页面展示这中间发送了什么？\n\n这同时也是个常见的面试问题。\n\n上一大节中虽然详细讲述了HTTP协议请求发送和接收的流程，但是在上一节的描述中把浏览器的相关行为当成一个整体行为，从第一大节中我们可以了解到现在的浏览器是多进程模式，浏览器主进程负责其他子进程的管理、用户交互和文件储存的功能。从输入URL到页面展示的过程中主要涉及了三个进程之间的交互和运行，分别是<u>浏览器主进程、网络进程以及渲染进程</u>。\n\n具体这三个进程在这个过程中的运行和交互如下图所示：\n\n![](/images/react/2021122204.png)\n\n根据这张图引出一个新概念：导航。用户发出URL请求到页面开始解析的这个过程，就叫做导航。接下来将根据这张图，详细解析这一过程到底发生了什么。\n\n### 4.1 用户输入\n\n用户在地址栏中可能会输入一个网站地址或者只是单纯搜索一些关键词。浏览器主进程会解析用户输入的内容，如果不符合URL规范，则会使用浏览器的默认搜索引擎来合成新的带搜索内容的URL；如果符合URL规范，则会根据规则加上相关协议，比如http://或者https://，合成完整的URL。\n\n当用户输入完成并敲击回车键后，浏览器并没有直接跳转到相关页面，中间有一段过渡时期，如下图所示：\n\n![](/images/react/2021122205.png)\n\n在该图的操作中，在浏览器地址栏中已经输入新的地址并键入回车，标签栏中可以看见页面正在加载的状态，但是网页内容并没有更新，还是原网页，这是因为直到浏览器等待到确认提交文档阶段，页面内容才会被替换成新的页面。\n\n### 4.2 URL请求过程\n\n键入URL后就进入了请求过程，这也是导航流程的起始阶段。浏览器主进程通过IPC把URL请求发送至<u>网络进程</u>，在网络进程中真正的发送URL请求。\n\n首先，网络进程收到URL请求后，会先在浏览器<u>缓存</u>中查找是否有需要的资源，若有则把该资源直接返回给浏览器主进程，若没有再进行网络请求流程。\n\n在真正进入网络请求时先要进行<u>DNS解析</u>，通过浏览器缓存或者请求域名服务器获得URL的域名对应的IP地址。如果建立的是HTTPS请求，还需要先建立TLS连接。\n\n然后就是建立<u>TCP连接</u>，成功连接后，网络进程真正发送HTTP请求信息给服务器，服务器接收到请求进行对应处理后会返回响应数据给<u>网络进程</u>，网络进程收到数据后开始解析响应数据内容。\n\n如果服务器返回的响应数据的状态码是<u>301或302</u>，则表示当前的URL需要<u>重定位</u>到其他的URL，这时候网络进程根据响应数据头部的`Location`字段信息获取重定位地址，再次发送HTTP请求。\n\n如果服务器返回的响应数据的状态码是<u>200</u>，则说明服务器成功返回了相关的数据信息，浏览器可以继续处理请求。这时网络进程会分析响应数据的<u>类型</u>，一般来说接收到的响应数据有两种类型，查看响应头上的`Content-Type`字段，这个字段决定了响应数据的类型，若该字段的内容是`application/octet-stream`，则说明是字节流类型数据，这种情况下，浏览器会按照下载类型来处理，同时URL请求的导航流程也就结束了。如果收到的信息是`Content-Type: text/html `，则说明该数据是html格式数据，网络进程会通知<u>浏览器主进程</u>进行渲染准备，浏览器就会继续进行导航流程。\n\n### 4.3 准备渲染进程\n\n一般情况下浏览器会给每一张页面分配一个渲染进程，但是有些浏览器会给属于同一站点的页面，并且后一张页面是在前面那张页面内打开的这样的情况下给这些页面分配同一个渲染进程。所以如果浏览器主进程接收到了网络进程需要准备渲染的信号，则会判断是否需要新增一个渲染进程，还是使用原来已有的渲染进程。\n\n### 4.4 提交文档\n\n这里所谓的“文档”是指URL请求的<u>响应体数据</u>。由浏览器主进程向渲染进程发出<u>“提交文档”</u>消息，<u>渲染进程</u>接收到消息后会和<u>网络进程</u>建立传输数据的“管道”。等文档数据从网络进程到渲染进程传输完成后，渲染进程会返回<u>“确认提交”</u>消息给浏览器主进程，当浏览器主进程接收到这个消息后，会更新浏览器界面状态，包括<u>安全状态、地址栏URL、前进后退历史状态、并且更新Web页面</u>。\n\n### 4.5 渲染阶段\n\n当渲染进程发送“确认提交”的信息后，它便开始对收到的数据进行页面分析和资源加载，一旦页面生成完成，渲染进程会发送一个消息给浏览器主进程，浏览器主进程接收到消息后，就会停止标签栏上的<u>加载动画</u>。这样，一个完整的页面就展示完成了。\n\n### 4.6 总结\n\n简化这个过程来回答这个问题，可以这样总结回答：\n\n**第一步**是用户在地址栏中的<u>输入</u>，浏览器主进程会根据输入的消息自动完善或者转化URL地址，生成对应的<u>HTTP请求报文</u>。**第二步**浏览器主进程将请求发送给<u>网络进程</u>，网络进程先判断<u>缓存</u>中是否有需要的资源，若有则返回该资源给浏览器主进程，若无则准备发送HTTP请求。**第三步**在发送请求之前先确认服务器的<u>IP地址</u>，在缓存中寻找域名映射IP地址信息，若没有需要的数据则发送请求到域名服务器获取需要的IP地址，如果是URL中显示是HTTPS协议，则还要先建立TLS连接。**第四步**建立<u>TCP</u>连接，等待TCP连接成功后真正发送HTTP请求到服务端，并等待服务端返回响应包，若响应数据中的<u>状态码</u>是301或者302则说明需要<u>重定向</u>URL，则根据响应头里的`Locstion`的URL再次发送HTTP请求。若成功返回所需的响应包，先分析该响应数据的<u>数据格式</u>，网络进程需要解析响应头部的`Content-Type`字段，若是字节流类型，则会当作是需要下载的资源进行下载，则该流程结束；若是html类型则要通知浏览器主进程进行<u>渲染准备</u>。**第五步**浏览器主进程会检查url是否和之前打开的渲染进程有相同的根域名，若相同则复用原来的进程，不同则开启新的进程（这一步因浏览器而异，而且现在的浏览器好像只要是新的页面都会分配一个新的渲染进程）。**第六步**浏览器会发送<u>“提交文档”</u>消息给相应的渲染进程，渲染进程接收到后就会和网络进程建立传输数据的“管道”。直到它接受完数据后，渲染进程会向浏览器主进程发送<u>“确认提交”</u>消息，浏览器主进程接收到该消息后会更新浏览器界面的一些状态包括安全状态、地址栏url、前进后退的历史状态以及Web界面。到这里导航流程就结束了，直到渲染进程完全解析和加载完资源，成功渲染页面之后会发送消息通知浏览器主进程，浏览器主进程收到消息后就会停止标签栏中加载动画，这样一个页面就完成展示了。\n\n## 5.页面渲染流程\n\n上一节我们了解了从输入URL到生成一张页面的导航阶段的流程，导航阶段之后则是页面的渲染流程，此时渲染进程已经获取了生成一张页面所需要的资源包括HTML、CSS和JavaScript，那么这些文件又是如何被解析生成一张可视化页面的呢？\n\n由于渲染机制非常复杂，渲染模块会在执行的过程中被划分为很多子阶段，最后输出像素，这一过程被称为渲染流水线。按照渲染的时间顺序可以将该流水线分为这几个子阶段：<u>构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化以及合成显示</u>。值得注意的是，每个子阶段都有其<u>输入</u>和<u>输出</u>内容以及处理过程（我觉得这句话像句废话，但是看到最后我发现这句话很重要）。\n\n### 5.1 构建DOM树\n\n浏览器无法直接理解HTML文件，需要将HTML转化成其能够理解的DOM树结构，可见下图所示。\n\n![](/images/react/2021122301.png)\n\nDOM树区分于HTML的是，DOM树是保持在内存中的树状结构，可以通过JavaScipt来查询或修改其内容。\n\n可以在Chrome浏览器中打开一张页面的开发者工具，点击控制台，在控制台中输入`document`并敲击回车键，就会呈现该页面HTML对应的DOM树，也可以在控制台中通过获取DOM树的某一节点来修改它的值，如下图所示。\n\n![](/images/react/2021122302.png)\n\n### 5.2 样式计算\n\n样式计算是为了计算每一个DOM节点每个元素的具体样式。\n\n首先先要**把CSS转化为浏览器能够理解的结构**。CSS在一张网页中可能有多种呈现方式，包括引用外部css文件，在标签`<style>`中的CSS，以及在元素的`style`属性中填写的CSS。当渲染引擎接收到CSS文本时，会将其转化为浏览器可以理解的<u>styleSheets</u>结构，如下图所示，在控制台中输入`document.styleSheets`可以查看styleSheets结构。\n\n![](/images/react/2021122303.png)\n\n然后**将样式表中的属性值转化为标准形式**。比方说表达颜色可以有多种方式，例如`red`、`rgb(255,0,0)`，`#ff0000`都可以表示红色，所以为了统一展示需要将这些值标准化。\n\n最后**计算出DOM树中每个节点的具体样式**，由于CSS具有<u>继承性</u>，即子节点会继承父节点的样式，以及CSS的其他<u>层叠规则</u>，所以需要计算每个节点最后真正的样式值。这里的层叠规则是CSS的核心，之后具体复习CSS时会展开讲。\n\n### 5.3 布局阶段\n\n上面两小节以及完成了DOM树的构建以及DOM树中元素对应样式表的构建，接下来要进行布局阶段，要获得每个可见节点在页面上的具体位置。\n\n**创建布局树**：在构建DOM树中会发现有很多标签如`head`标签都是不可见的，以及在创建样式表时也发现有一些元素带有例如`display:none`的属性，也是不可见的，所以需要建立一个只包含可见元素的布局树，如下图所示，就是通过DOM树和对应的样式表创建出的布局树。\n\n![](/images/react/2021122304.png)\n\n**布局计算**：现在已有一棵布局树，然后就要进行布局计算，这一过程比较复杂，后面的章节会详细分析，总之在进行布局计算后会把运算结果重新写回布局树中。所以<u>这一阶段布局树既是输入内容又是输出结果</u>。\n\n### 5.4 分层\n\n因为页面中有很多复杂的效果，比如页面滚动、3D转换等，所以为了方便实现这些效果，渲染引擎还需要生成一棵<u>图层树（LayerTree）</u>。打开Chrome的开发者工具，选择”Layers“标签，若没有该标签，则按下图所示操作添加该标签：\n\n![](/images/react/2021122305.png)\n\n比如，下面这个页面就有5个图层，如下图所示。\n\n![](/images/react/2021122306.png)\n\n不是布局树上的每一个节点都会被分配一个图层的，如果某些节点没有被分配图层，那它就属于父节点的图层，所以最终每个布局树上的节点都会直接或间接地从属于某一图层。符合以下两个条件之一的元素可以被提升为单独一个图层。\n\n**拥有层叠上下文属性的元素**：比如定义position属性、z-index属性、filter属性以及opacity属性。\n\n**需要裁剪的元素**：当元素里的内容超出元素本身大小时就需要被裁剪。\n\n确定好哪些节点会被分配新的图层后，就会生成一个图层树。图层树不一定和布局树的节点一一对应，但是<u>布局树上的每个节点一定都属于某一个图层</u>。\n\n### 5.5 绘制\n\n渲染引擎是通过构建<u>绘制列表</u>来实现具体的图层绘制过程的。绘制列表中每一个指令都代表一个绘制操作，通常要完成绘制一个元素需要好几条指令，因为通常一个元素会有背景、前景、边框等属性都需要单独的指令来实现。\n\n### 5.6 分块\n\n绘制列表只是用来记录绘制指令的列表，实际完成绘制操作的是渲染进程中的<u>合成线程</u>。当在渲染进程的主线程上完成绘制列表后，它会把该列表提交给合成线程。\n\n这里先引入一个<u>”视口“</u>的概念。一般一些页面是超过浏览器窗口大小的，它们也许会很长，也许会很宽，而视口就是窗口上可见的页面区域。如果一张页面非常长而视口非常小，而要完整绘制该页面的所有图层内容是没必要的，这会引起很大开销。基于这个原因，合成线程将图层划分为许多<u>图块(tile)</u>，这些图块的大小通常是256x256或者512x512。\n\n### 5.7 栅格化操作\n\n渲染进程中的合成线程会将分解出来的图块发送到<u>栅格化线程池</u>中，由一系列<u>栅格化线程</u>对这些图块进行处理。<u>栅格化</u>就是指将图块转化为<u>位图</u>，图块是栅格化执行的最小操作。而通常栅格化的过程会使用<u>GPU</u>加速实现，前面第一大节提过GPU有独立的进程，所以这涉及了跨进程操作。具体的处理交互过程如图所示。\n\n![](/images/react/2021122307.png)\n\n如图可知，位图是在GPU进程中生成并且保存的。\n\n### 5.8 合成和显示\n\n当所有图块都被光栅化成位块后，渲染进程的合成线程会发生给浏览器主进程一个绘制图块命令——\"<u>DrawQuad</u>\"。浏览器主进程里有个叫viz的组件，用来接收该命令，然后根据该命令将页面内容绘制到内存中，最后将内存显示在屏幕上。\n\n### 5.9 重排、重绘与合成\n\n以上就已经讲述了渲染流水线的具体过程，接下来提出三个重要概念，这些概念在之后的<u>Web优化</u>中非常重要，也经常被面试官提及。\n\n**重排**：顾名思义，就是重新排列了元素的布局。在实际情况中就是改变了元素的样式中几何位置相关的属性，比如`weight`、`height`、`margin`等。修改了这些属性，那么渲染流水线从样式计算到后面的布局阶段、分层阶段以及绘制等都需要改变，如下图所示。\n\n![]()\n\n根据该图也可以看出重排的开销非常大。\n\n**重绘**：顾名思义是改变某些元素的某些颜色，比如背景、字体颜色等样式。因为不会引起布局的变动所以重绘之后会直接跳过布局阶段和分层阶段，但绘制列表是需要改变的，具体如下图所示。\n\n![](/images/react/2021122309.png)\n\n虽然重绘也有一定大的开销，但是相比于重排开销会有所减少。\n\n**合成**：如果改变一些既不要布局也不需要绘制的属性，比如改变translate属性，渲染引擎就会直接跳过布局和绘制，而只执行后面的合成操作，具体如下图所示：\n\n![](/images/react/2021122310.png)\n\n根据上图可以得知，合成对比于重排和重绘开销最小。\n\n### 5.10 渲染流水线总结\n\n上面已经分析了渲染流水线的每一个具体过程，现在可以根据以下这张图来概括性地说明从HTML到一张页面经历了什么。\n\n![](/images/react/2021122311.png)\n\n渲染进程获得所需的HTML、CSS、JavaScript等资源后，1.将<u>HTML内容</u>转化为可以理解的<u>DOM树</u>。2.将有关的<u>CSS内容</u>转为能够理解的styleSheets格式，对其进行标准化处理，并且计算出每个DOM节点的样式值，生成DOM树每个元素的<u>样式表</u>。3.根据<u>DOM树和对应的样式表</u>创建DOM可见节点的布局树，并且计算节点的布局信息，生成一棵<u>布局树</u>。4.对<u>布局树</u>进行分层，生成<u>图层树</u>。5.为<u>每个图层</u>生成绘制列表，并且提交<u>绘制列表</u>给渲染进程的合成线程。6.合成线程将<u>图层</u>分为<u>图块</u>。7.合成线程再将生成的<u>图块</u>在光栅化线程池中将转化成<u>位图</u>，这里会使用GPU而和GPU进程进行交互。8.完成<u>位图</u>制作后，合成线程会发送绘制图块命令DrawQuad给浏览器主进程，浏览器主进程根据消息生成<u>页面</u>，并展示到显示器上。\n\n可以看出每一个阶段都是有输入输出的，这样一张页面的渲染流程也展示完成了。","slug":"浏览器相关","published":1,"updated":"2021-12-27T01:18:12.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh3d003k6wtvfsr8gxzy","content":"<hr>\n<p><em>本文来源于<a href=\"http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。\">http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。</a></em></p>\n<hr>\n<h2 id=\"1-浏览器发展史\"><a href=\"#1-浏览器发展史\" class=\"headerlink\" title=\"1.浏览器发展史\"></a>1.浏览器发展史</h2><h3 id=\"1-1-单进程浏览器\"><a href=\"#1-1-单进程浏览器\" class=\"headerlink\" title=\"1.1 单进程浏览器\"></a>1.1 单进程浏览器</h3><p>2007年之前，市面上的浏览器都是单进程的，单进程浏览器把需要运行的所有功能模块都放在一个进程里，而模块分为几个线程在进程里运行，这会导致如下几个问题。</p>\n<p><strong>不稳定问题</strong>：一个线程崩溃就会导致整个进程崩溃，也就是整个浏览器崩溃。</p>\n<p><strong>不流畅问题</strong>：单进程浏览器中，页面模块在一个线程中运行，如果该线程中有一个<u>无限循环的脚本</u>，那页面的其他模块就无法运行，会导致页面无法加载的问题。除此之外，单进程浏览器很容易出现页面<u>内存泄漏</u>从而导致计算机内存占用越来越高，浏览器运行越来越慢的问题。</p>\n<p><strong>不安全问题</strong>：在单进程浏览器中很容易让一些<u>恶意插件或脚本</u>释放病毒，获得计算机重要信息。</p>\n<h3 id=\"1-2-早期多进程浏览器\"><a href=\"#1-2-早期多进程浏览器\" class=\"headerlink\" title=\"1.2 早期多进程浏览器\"></a>1.2 早期多进程浏览器</h3><p>2008年Chrome的发布宣告浏览器进入多进程时代，早期的浏览器多进程架构是将各个插件从浏览器主进程中分离开独立成单个的进程，也将每个页面线程从主进程分离变成独立的每个渲染进程。这些被分割的进程都运行在<u>沙箱</u>中，进程之间通过<u>IPC</u>（进程间通信）进行通信。这种多进程模块的好处是让各个功能模块相互隔离，这样一个模块的问题导致的奔溃不会导致整个浏览器崩溃，解决了不稳定性问题。并且也因为独立的进程，使得一个页面脚本出现问题时不会影响整个浏览器以及独立的其他页面的运行（每个页面都是一个渲染进程），争对内存泄漏也可以通过关闭一个页面回收内存的方式解决，这就解决了不稳定性问题。此外，因为独立出来的功能模块进程都在sandbox（沙箱）中运行，受到一定的限制，无法读取计算机敏感位置的数据，所以安全性问题也得到了解决。</p>\n<h3 id=\"1-3-目前多进程浏览器\"><a href=\"#1-3-目前多进程浏览器\" class=\"headerlink\" title=\"1.3 目前多进程浏览器\"></a>1.3 目前多进程浏览器</h3><p>对比于早期的多进程架构，目前的Chrome又独立于浏览器主进程之外还多出了几个进程，包括<u>GPU进程、网络服务进程、缓存服务进程、备用渲染进程</u>。</p>\n<p>打开Chrome的任务管理器，下面显示的就是chrome浏览器中运行的进程，如图所示：</p>\n<p><img src=\"/images/react/2021122201.png\"></p>\n<p>多进程模型提高了浏览器的稳定性、流畅性以及安全性，但也带来了一定的问题，比如它占用了更高的资源，因为每个进程都会包含公共基础结构的副本；以及该模型有着更复杂的体系架构，这意味着浏览器各模块之间的<u>耦合性高、扩展性差</u>等问题。面对这些问题，现在的浏览器公司一直都在寻找更好的处理方法。</p>\n<h3 id=\"1-4-未来面向服务的架构\"><a href=\"#1-4-未来面向服务的架构\" class=\"headerlink\" title=\"1.4 未来面向服务的架构\"></a>1.4 未来面向服务的架构</h3><p>在2016年，Chrome团队就使用<u>面向服务架构</u>（SOA）的思想设计了新的Chrome架构，也就是说未来的浏览器会朝着SOA的方向发展，原来的各个模块会被重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务就必须使用定义好的接口，这样就可以建立一个<u>更加内聚、更低的耦合度，更加易于维护和扩展</u>的系统。但这必将是一个漫长的过程。</p>\n<h2 id=\"2-数据包从服务端完整传达给客服端浏览器的过程\"><a href=\"#2-数据包从服务端完整传达给客服端浏览器的过程\" class=\"headerlink\" title=\"2.数据包从服务端完整传达给客服端浏览器的过程\"></a>2.数据包从服务端完整传达给客服端浏览器的过程</h2><p>打开一个网页会显示各种信息，这些信息都是从这个网站的服务器端发送过来的，那么这些信息又是怎么包装完整地传达到客户端的浏览器上的呢？</p>\n<h3 id=\"2-1-数据包从服务端送达到目的主机\"><a href=\"#2-1-数据包从服务端送达到目的主机\" class=\"headerlink\" title=\"2.1 数据包从服务端送达到目的主机\"></a>2.1 数据包从服务端送达到目的主机</h3><p>数据必定是先从服务器运输到客户端的主机，才能从主机上升到具体的应用程序。两个主机之间的信息通信在网络体系模型的<u>网络层</u>中实现的，其中数据的运输则依靠于网络层中的<u>IP协议</u>。网络层传输的数据是以“分组”形式存在的，每一个分组都有一个头部，头部包含了源主机和目的主机的<u>IP地址</u>，依靠IP地址就可以实现两个主机之间的通信。</p>\n<h3 id=\"2-2-数据包从客户端主机到应用进程\"><a href=\"#2-2-数据包从客户端主机到应用进程\" class=\"headerlink\" title=\"2.2 数据包从客户端主机到应用进程\"></a>2.2 数据包从客户端主机到应用进程</h3><p>通过网络层的IP协议可以实现主机之间的网络通信，但是IP协议是个相对底层的协议，无法实现应用进程之间的通信，这需要通过网络层上一层的<u>传输层</u>才能实现通信。传输层通常有两个常用的协议，分别是<u>UDP协议</u>和<u>TCP协议</u>，通过两个协议在传输层产生的数据包都有一个头部，头部都包含了<u>源端口号和目的端口号</u>的信息，这个端口号就是具体的应用程序在主机上的端口号，根据端口号就可以实现数据包从客户端主机到应用进程的运输。</p>\n<h3 id=\"2-3-数据包可靠完整地被传达\"><a href=\"#2-3-数据包可靠完整地被传达\" class=\"headerlink\" title=\"2.3 数据包可靠完整地被传达\"></a>2.3 数据包可靠完整地被传达</h3><p>上节提到的UDP协议和TCP协议都是在传输层的协议，它们之间的区别是：UDP协议追求的是<u>快速</u>地传输，而TCP协议追求的是<u>完整</u>地传输，这就会导致UDP协议传输的数据很容易丢失，而TCP协议却保护了数据的完整性。在浏览器中运用到的应用层协议，无论是http协议还是WebSocket协议都使用TCP协议传输数据，从而保证了数据的完整性。那么TCP协议是如何做到完整传输数据的呢？</p>\n<p>区别于UDP协议，基于TCP协议有更复杂更加多数据的头部，包括数据包序号、确认号、数据偏移等信息，这些信息能够将混乱的数据包组合成一个完整的文件，并且对于缺失的数据包，TCP提供了重传机制。</p>\n<p>此外，为了保证数据传输的可靠性，进行TCP协议实际数据的传输前后分别由“三次握手”和“四次挥手来进行可靠的连接建立和断开。</p>\n<p>TCP协议需要进行三次握手的原因是为了防止失效的连接请求到达服务器，让服务器错误打开连接（具体详细解析可见”计算机网络基础知识点“的7.4节）。</p>\n<h2 id=\"3-HTTP请求流程\"><a href=\"#3-HTTP请求流程\" class=\"headerlink\" title=\"3.HTTP请求流程\"></a>3.HTTP请求流程</h2><p>HTTP协议是<u>应用层</u>协议，是浏览器使用最广泛的协议，通过它可以实现浏览器向服务器获取相关资源。HTTP协议建立在TCP协议基础之上，上一节已经知道通过TCP协议实现数据从服务器传输到浏览器中，那么浏览器又是怎么通过HTTP协议发送请求的呢？这节主要讲HTTP请求的具体流程。</p>\n<h3 id=\"3-1-构建请求\"><a href=\"#3-1-构建请求\" class=\"headerlink\" title=\"3.1 构建请求\"></a>3.1 构建请求</h3><p>通常访问一个网站的第一步就是在浏览器的地址栏中输入一个网站地址并点击跳转，这时就会构建一个请求，但是这个请求还在浏览器端，并没有开始运输。</p>\n<h3 id=\"3-2-查找缓存\"><a href=\"#3-2-查找缓存\" class=\"headerlink\" title=\"3.2 查找缓存\"></a>3.2 查找缓存</h3><p>在发送请求之前，浏览器会根据已经构建好的请求的基本数据在<u>缓存</u>中进行查找，如果有所需的数据，则它会直接拦截结束该请求，直接使用缓存中的副本，这样就能缓解服务器压力，也加快了浏览器上资源加载速度。</p>\n<h3 id=\"3-3-获取服务端的IP地址和端口\"><a href=\"#3-3-获取服务端的IP地址和端口\" class=\"headerlink\" title=\"3.3 获取服务端的IP地址和端口\"></a>3.3 获取服务端的IP地址和端口</h3><p>如果缓存中没有所需的数据，则要开始发送请求，但是根据第2节可知，实现一个数据包的运输需要知道对方主机的IP地址和端口号，所以需要先获取IP地址以及端口号。如何通过一个URL网址获得IP地址就要涉及<u>DNS协议</u>，浏览器已知的URL又被称为域名，域名和IP地址呈现一对一映射关系，通过DNS协议访问<u>域名服务器</u>可以获得所需要的IP地址，或者如果之前该浏览器访问过某网页，那么缓存中可能会存有该网络的IP地址。对于端口号，如果URL中没有特别指明端口号，那么HTTP协议默认的端口号是<u>80</u> 。</p>\n<h3 id=\"3-4-等待TCP队列，建立TCP连接\"><a href=\"#3-4-等待TCP队列，建立TCP连接\" class=\"headerlink\" title=\"3.4 等待TCP队列，建立TCP连接\"></a>3.4 等待TCP队列，建立TCP连接</h3><p>浏览器一般都有一个限制，即同一域名同时只能建立一定数量的TCP连接，如果超过这个数量，只能进入队列进行等待，若未超过这个数量，则能直接建立TCP连接，TCP连接的具体方式如第2大节所示。</p>\n<h3 id=\"3-5-发送HTTP请求\"><a href=\"#3-5-发送HTTP请求\" class=\"headerlink\" title=\"3.5 发送HTTP请求\"></a>3.5 发送HTTP请求</h3><p>建立了TCP连接，实现了TCP的三次握手，才能真正的发送HTTP请求。一个HTTP请求报文由<u>请求行、请求头部和请求体</u>组成，具体如下图所示：</p>\n<p><img src=\"/images/react/2021122202.png\"></p>\n<p>其中，请求行包括了<u>请求方法</u>（GET/POST/DELETE…）、<u>请求URL</u>以及<u>HTTP协议版本号</u>。请求头部包括了一些基础信息，比如浏览器所使用的操作系统、浏览器内核等信息。</p>\n<h3 id=\"3-6-服务器返回请求响应\"><a href=\"#3-6-服务器返回请求响应\" class=\"headerlink\" title=\"3.6 服务器返回请求响应\"></a>3.6 服务器返回请求响应</h3><p>服务器接收到浏览器的HTTP请求后，则会处理相应请求，如果服务器选择响应某些请求，就会发送客户端浏览器以HTTP响应数据信息，其中包括<u>响应行、响应头部和具体的响应体</u>。</p>\n<p>其中响应行包括<u>HTTP协议版本</u>和<u>状态码</u>信息，比如状态码为200则表示处理成功，状态码为404则表示没有响应页面。</p>\n<h3 id=\"3-7-断开连接\"><a href=\"#3-7-断开连接\" class=\"headerlink\" title=\"3.7 断开连接\"></a>3.7 断开连接</h3><p>通常情况下，一旦服务器向客户端返回了请求数据，就会断开TCP协议，如果浏览器或服务器在其HTTP请求头部或者响应头部中加上了<code>Connection:keep-alive</code>，则该TCP连接就会保持打开状态。</p>\n<h3 id=\"3-8-重定向\"><a href=\"#3-8-重定向\" class=\"headerlink\" title=\"3.8 重定向\"></a>3.8 重定向</h3><p>有时候会出现这种情况：用户在浏览器的地址栏中输入的URL在网页打开后会变成另外一个，这就涉及到了重定向。比如在我的火狐浏览器的地址栏中输入<code>sixteentime.github.io</code>，但是它马上跳转成网站<code>sixteentime.xyz</code>，这就是一个重定向的过程，可以打开该网站打开时的第一个响应报文，观察其响应头信息中有这样一行信息:<code>Location: http://sixteentime.xyz/ </code>这就执行了一个重定向流程，具体如下图所示：</p>\n<p><img src=\"/images/react/2021122203.png\"></p>\n<h3 id=\"3-9相关问题\"><a href=\"#3-9相关问题\" class=\"headerlink\" title=\"3.9相关问题\"></a>3.9相关问题</h3><p><strong>为什么很多网站第二次打开的速度会很快？</strong></p>\n<p>这是上面提到的浏览器<u>缓存机制</u>的原因。当网站第一次打开网站时，浏览器里没有该网站的缓存，浏览器则会发送请求给服务端请求数据，服务端返回数据给浏览器时，浏览器也会把页面数据存入缓存，然后在缓存的<u>生命周期</u>内再次打开该页面时，浏览器就不会发送请求给服务器而是直接使用缓存资源，这样就会使网站运行速度加快；若超过了这个生命周期，那么浏览器会担心这个缓存数据可能会过期，就会发送请求给服务器，如果服务器返回该缓存数据没有过期，那么浏览器会继续使用缓存数据加载页面，这样的加载速度也会相对较快。</p>\n<p>当然，浏览器的缓存中还有域名与IP地址的映射信息，第二次打开页面不需要发送请求到域名服务器获取域名对应的IP地址，也可以加快网页的加载速度。</p>\n<p><strong>网站的登录状态是如何保持的？</strong></p>\n<p>一般而言，服务器为了防止非系统用户的恶意攻击，对系统的访问方法都需要用户登陆信息，可是在浏览器中操作的用户只在最开始的时候输入账号密码进行登陆，之后在浏览器中的相关操作产生的请求都没有输入账号密码来证明信息，那么服务器是如何知道是哪个用户在进行请求访问呢？这就涉及到了HTTP的<u>Cookie</u>功能。</p>\n<p>当用户登陆网站输入账号密码信息并发送访问请求时，服务器收到相关数据会进行验证，若身份验证成功则会在返回的响应数据的响应头中字段<code>Set-Cookie</code>添加相关内容来表示用户身份信息，浏览器收到响应数据后会把对应的Cookie信息保存在本地。当用户登陆成功后在该网页进行其他操作而产生请求时，产生的请求报文的请求头上就会有<code>Cookie</code>字段信息，服务器接收到请求报文后，当核实Cookie内的字段能够核实用户身份，并且判断该用户处于登陆状态后，就会成功返回相关的数据信息。这就是网站通过Cookie保持用户登陆状态的原因。</p>\n<h2 id=\"4-从浏览器中输入URL到页面展示这中间发送了什么？\"><a href=\"#4-从浏览器中输入URL到页面展示这中间发送了什么？\" class=\"headerlink\" title=\"4.从浏览器中输入URL到页面展示这中间发送了什么？\"></a>4.从浏览器中输入URL到页面展示这中间发送了什么？</h2><p>这同时也是个常见的面试问题。</p>\n<p>上一大节中虽然详细讲述了HTTP协议请求发送和接收的流程，但是在上一节的描述中把浏览器的相关行为当成一个整体行为，从第一大节中我们可以了解到现在的浏览器是多进程模式，浏览器主进程负责其他子进程的管理、用户交互和文件储存的功能。从输入URL到页面展示的过程中主要涉及了三个进程之间的交互和运行，分别是<u>浏览器主进程、网络进程以及渲染进程</u>。</p>\n<p>具体这三个进程在这个过程中的运行和交互如下图所示：</p>\n<p><img src=\"/images/react/2021122204.png\"></p>\n<p>根据这张图引出一个新概念：导航。用户发出URL请求到页面开始解析的这个过程，就叫做导航。接下来将根据这张图，详细解析这一过程到底发生了什么。</p>\n<h3 id=\"4-1-用户输入\"><a href=\"#4-1-用户输入\" class=\"headerlink\" title=\"4.1 用户输入\"></a>4.1 用户输入</h3><p>用户在地址栏中可能会输入一个网站地址或者只是单纯搜索一些关键词。浏览器主进程会解析用户输入的内容，如果不符合URL规范，则会使用浏览器的默认搜索引擎来合成新的带搜索内容的URL；如果符合URL规范，则会根据规则加上相关协议，比如http://或者https://，合成完整的URL。</p>\n<p>当用户输入完成并敲击回车键后，浏览器并没有直接跳转到相关页面，中间有一段过渡时期，如下图所示：</p>\n<p><img src=\"/images/react/2021122205.png\"></p>\n<p>在该图的操作中，在浏览器地址栏中已经输入新的地址并键入回车，标签栏中可以看见页面正在加载的状态，但是网页内容并没有更新，还是原网页，这是因为直到浏览器等待到确认提交文档阶段，页面内容才会被替换成新的页面。</p>\n<h3 id=\"4-2-URL请求过程\"><a href=\"#4-2-URL请求过程\" class=\"headerlink\" title=\"4.2 URL请求过程\"></a>4.2 URL请求过程</h3><p>键入URL后就进入了请求过程，这也是导航流程的起始阶段。浏览器主进程通过IPC把URL请求发送至<u>网络进程</u>，在网络进程中真正的发送URL请求。</p>\n<p>首先，网络进程收到URL请求后，会先在浏览器<u>缓存</u>中查找是否有需要的资源，若有则把该资源直接返回给浏览器主进程，若没有再进行网络请求流程。</p>\n<p>在真正进入网络请求时先要进行<u>DNS解析</u>，通过浏览器缓存或者请求域名服务器获得URL的域名对应的IP地址。如果建立的是HTTPS请求，还需要先建立TLS连接。</p>\n<p>然后就是建立<u>TCP连接</u>，成功连接后，网络进程真正发送HTTP请求信息给服务器，服务器接收到请求进行对应处理后会返回响应数据给<u>网络进程</u>，网络进程收到数据后开始解析响应数据内容。</p>\n<p>如果服务器返回的响应数据的状态码是<u>301或302</u>，则表示当前的URL需要<u>重定位</u>到其他的URL，这时候网络进程根据响应数据头部的<code>Location</code>字段信息获取重定位地址，再次发送HTTP请求。</p>\n<p>如果服务器返回的响应数据的状态码是<u>200</u>，则说明服务器成功返回了相关的数据信息，浏览器可以继续处理请求。这时网络进程会分析响应数据的<u>类型</u>，一般来说接收到的响应数据有两种类型，查看响应头上的<code>Content-Type</code>字段，这个字段决定了响应数据的类型，若该字段的内容是<code>application/octet-stream</code>，则说明是字节流类型数据，这种情况下，浏览器会按照下载类型来处理，同时URL请求的导航流程也就结束了。如果收到的信息是<code>Content-Type: text/html </code>，则说明该数据是html格式数据，网络进程会通知<u>浏览器主进程</u>进行渲染准备，浏览器就会继续进行导航流程。</p>\n<h3 id=\"4-3-准备渲染进程\"><a href=\"#4-3-准备渲染进程\" class=\"headerlink\" title=\"4.3 准备渲染进程\"></a>4.3 准备渲染进程</h3><p>一般情况下浏览器会给每一张页面分配一个渲染进程，但是有些浏览器会给属于同一站点的页面，并且后一张页面是在前面那张页面内打开的这样的情况下给这些页面分配同一个渲染进程。所以如果浏览器主进程接收到了网络进程需要准备渲染的信号，则会判断是否需要新增一个渲染进程，还是使用原来已有的渲染进程。</p>\n<h3 id=\"4-4-提交文档\"><a href=\"#4-4-提交文档\" class=\"headerlink\" title=\"4.4 提交文档\"></a>4.4 提交文档</h3><p>这里所谓的“文档”是指URL请求的<u>响应体数据</u>。由浏览器主进程向渲染进程发出<u>“提交文档”</u>消息，<u>渲染进程</u>接收到消息后会和<u>网络进程</u>建立传输数据的“管道”。等文档数据从网络进程到渲染进程传输完成后，渲染进程会返回<u>“确认提交”</u>消息给浏览器主进程，当浏览器主进程接收到这个消息后，会更新浏览器界面状态，包括<u>安全状态、地址栏URL、前进后退历史状态、并且更新Web页面</u>。</p>\n<h3 id=\"4-5-渲染阶段\"><a href=\"#4-5-渲染阶段\" class=\"headerlink\" title=\"4.5 渲染阶段\"></a>4.5 渲染阶段</h3><p>当渲染进程发送“确认提交”的信息后，它便开始对收到的数据进行页面分析和资源加载，一旦页面生成完成，渲染进程会发送一个消息给浏览器主进程，浏览器主进程接收到消息后，就会停止标签栏上的<u>加载动画</u>。这样，一个完整的页面就展示完成了。</p>\n<h3 id=\"4-6-总结\"><a href=\"#4-6-总结\" class=\"headerlink\" title=\"4.6 总结\"></a>4.6 总结</h3><p>简化这个过程来回答这个问题，可以这样总结回答：</p>\n<p><strong>第一步</strong>是用户在地址栏中的<u>输入</u>，浏览器主进程会根据输入的消息自动完善或者转化URL地址，生成对应的<u>HTTP请求报文</u>。<strong>第二步</strong>浏览器主进程将请求发送给<u>网络进程</u>，网络进程先判断<u>缓存</u>中是否有需要的资源，若有则返回该资源给浏览器主进程，若无则准备发送HTTP请求。<strong>第三步</strong>在发送请求之前先确认服务器的<u>IP地址</u>，在缓存中寻找域名映射IP地址信息，若没有需要的数据则发送请求到域名服务器获取需要的IP地址，如果是URL中显示是HTTPS协议，则还要先建立TLS连接。<strong>第四步</strong>建立<u>TCP</u>连接，等待TCP连接成功后真正发送HTTP请求到服务端，并等待服务端返回响应包，若响应数据中的<u>状态码</u>是301或者302则说明需要<u>重定向</u>URL，则根据响应头里的<code>Locstion</code>的URL再次发送HTTP请求。若成功返回所需的响应包，先分析该响应数据的<u>数据格式</u>，网络进程需要解析响应头部的<code>Content-Type</code>字段，若是字节流类型，则会当作是需要下载的资源进行下载，则该流程结束；若是html类型则要通知浏览器主进程进行<u>渲染准备</u>。<strong>第五步</strong>浏览器主进程会检查url是否和之前打开的渲染进程有相同的根域名，若相同则复用原来的进程，不同则开启新的进程（这一步因浏览器而异，而且现在的浏览器好像只要是新的页面都会分配一个新的渲染进程）。<strong>第六步</strong>浏览器会发送<u>“提交文档”</u>消息给相应的渲染进程，渲染进程接收到后就会和网络进程建立传输数据的“管道”。直到它接受完数据后，渲染进程会向浏览器主进程发送<u>“确认提交”</u>消息，浏览器主进程接收到该消息后会更新浏览器界面的一些状态包括安全状态、地址栏url、前进后退的历史状态以及Web界面。到这里导航流程就结束了，直到渲染进程完全解析和加载完资源，成功渲染页面之后会发送消息通知浏览器主进程，浏览器主进程收到消息后就会停止标签栏中加载动画，这样一个页面就完成展示了。</p>\n<h2 id=\"5-页面渲染流程\"><a href=\"#5-页面渲染流程\" class=\"headerlink\" title=\"5.页面渲染流程\"></a>5.页面渲染流程</h2><p>上一节我们了解了从输入URL到生成一张页面的导航阶段的流程，导航阶段之后则是页面的渲染流程，此时渲染进程已经获取了生成一张页面所需要的资源包括HTML、CSS和JavaScript，那么这些文件又是如何被解析生成一张可视化页面的呢？</p>\n<p>由于渲染机制非常复杂，渲染模块会在执行的过程中被划分为很多子阶段，最后输出像素，这一过程被称为渲染流水线。按照渲染的时间顺序可以将该流水线分为这几个子阶段：<u>构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化以及合成显示</u>。值得注意的是，每个子阶段都有其<u>输入</u>和<u>输出</u>内容以及处理过程（我觉得这句话像句废话，但是看到最后我发现这句话很重要）。</p>\n<h3 id=\"5-1-构建DOM树\"><a href=\"#5-1-构建DOM树\" class=\"headerlink\" title=\"5.1 构建DOM树\"></a>5.1 构建DOM树</h3><p>浏览器无法直接理解HTML文件，需要将HTML转化成其能够理解的DOM树结构，可见下图所示。</p>\n<p><img src=\"/images/react/2021122301.png\"></p>\n<p>DOM树区分于HTML的是，DOM树是保持在内存中的树状结构，可以通过JavaScipt来查询或修改其内容。</p>\n<p>可以在Chrome浏览器中打开一张页面的开发者工具，点击控制台，在控制台中输入<code>document</code>并敲击回车键，就会呈现该页面HTML对应的DOM树，也可以在控制台中通过获取DOM树的某一节点来修改它的值，如下图所示。</p>\n<p><img src=\"/images/react/2021122302.png\"></p>\n<h3 id=\"5-2-样式计算\"><a href=\"#5-2-样式计算\" class=\"headerlink\" title=\"5.2 样式计算\"></a>5.2 样式计算</h3><p>样式计算是为了计算每一个DOM节点每个元素的具体样式。</p>\n<p>首先先要<strong>把CSS转化为浏览器能够理解的结构</strong>。CSS在一张网页中可能有多种呈现方式，包括引用外部css文件，在标签<code>&lt;style&gt;</code>中的CSS，以及在元素的<code>style</code>属性中填写的CSS。当渲染引擎接收到CSS文本时，会将其转化为浏览器可以理解的<u>styleSheets</u>结构，如下图所示，在控制台中输入<code>document.styleSheets</code>可以查看styleSheets结构。</p>\n<p><img src=\"/images/react/2021122303.png\"></p>\n<p>然后<strong>将样式表中的属性值转化为标准形式</strong>。比方说表达颜色可以有多种方式，例如<code>red</code>、<code>rgb(255,0,0)</code>，<code>#ff0000</code>都可以表示红色，所以为了统一展示需要将这些值标准化。</p>\n<p>最后<strong>计算出DOM树中每个节点的具体样式</strong>，由于CSS具有<u>继承性</u>，即子节点会继承父节点的样式，以及CSS的其他<u>层叠规则</u>，所以需要计算每个节点最后真正的样式值。这里的层叠规则是CSS的核心，之后具体复习CSS时会展开讲。</p>\n<h3 id=\"5-3-布局阶段\"><a href=\"#5-3-布局阶段\" class=\"headerlink\" title=\"5.3 布局阶段\"></a>5.3 布局阶段</h3><p>上面两小节以及完成了DOM树的构建以及DOM树中元素对应样式表的构建，接下来要进行布局阶段，要获得每个可见节点在页面上的具体位置。</p>\n<p><strong>创建布局树</strong>：在构建DOM树中会发现有很多标签如<code>head</code>标签都是不可见的，以及在创建样式表时也发现有一些元素带有例如<code>display:none</code>的属性，也是不可见的，所以需要建立一个只包含可见元素的布局树，如下图所示，就是通过DOM树和对应的样式表创建出的布局树。</p>\n<p><img src=\"/images/react/2021122304.png\"></p>\n<p><strong>布局计算</strong>：现在已有一棵布局树，然后就要进行布局计算，这一过程比较复杂，后面的章节会详细分析，总之在进行布局计算后会把运算结果重新写回布局树中。所以<u>这一阶段布局树既是输入内容又是输出结果</u>。</p>\n<h3 id=\"5-4-分层\"><a href=\"#5-4-分层\" class=\"headerlink\" title=\"5.4 分层\"></a>5.4 分层</h3><p>因为页面中有很多复杂的效果，比如页面滚动、3D转换等，所以为了方便实现这些效果，渲染引擎还需要生成一棵<u>图层树（LayerTree）</u>。打开Chrome的开发者工具，选择”Layers“标签，若没有该标签，则按下图所示操作添加该标签：</p>\n<p><img src=\"/images/react/2021122305.png\"></p>\n<p>比如，下面这个页面就有5个图层，如下图所示。</p>\n<p><img src=\"/images/react/2021122306.png\"></p>\n<p>不是布局树上的每一个节点都会被分配一个图层的，如果某些节点没有被分配图层，那它就属于父节点的图层，所以最终每个布局树上的节点都会直接或间接地从属于某一图层。符合以下两个条件之一的元素可以被提升为单独一个图层。</p>\n<p><strong>拥有层叠上下文属性的元素</strong>：比如定义position属性、z-index属性、filter属性以及opacity属性。</p>\n<p><strong>需要裁剪的元素</strong>：当元素里的内容超出元素本身大小时就需要被裁剪。</p>\n<p>确定好哪些节点会被分配新的图层后，就会生成一个图层树。图层树不一定和布局树的节点一一对应，但是<u>布局树上的每个节点一定都属于某一个图层</u>。</p>\n<h3 id=\"5-5-绘制\"><a href=\"#5-5-绘制\" class=\"headerlink\" title=\"5.5 绘制\"></a>5.5 绘制</h3><p>渲染引擎是通过构建<u>绘制列表</u>来实现具体的图层绘制过程的。绘制列表中每一个指令都代表一个绘制操作，通常要完成绘制一个元素需要好几条指令，因为通常一个元素会有背景、前景、边框等属性都需要单独的指令来实现。</p>\n<h3 id=\"5-6-分块\"><a href=\"#5-6-分块\" class=\"headerlink\" title=\"5.6 分块\"></a>5.6 分块</h3><p>绘制列表只是用来记录绘制指令的列表，实际完成绘制操作的是渲染进程中的<u>合成线程</u>。当在渲染进程的主线程上完成绘制列表后，它会把该列表提交给合成线程。</p>\n<p>这里先引入一个<u>”视口“</u>的概念。一般一些页面是超过浏览器窗口大小的，它们也许会很长，也许会很宽，而视口就是窗口上可见的页面区域。如果一张页面非常长而视口非常小，而要完整绘制该页面的所有图层内容是没必要的，这会引起很大开销。基于这个原因，合成线程将图层划分为许多<u>图块(tile)</u>，这些图块的大小通常是256x256或者512x512。</p>\n<h3 id=\"5-7-栅格化操作\"><a href=\"#5-7-栅格化操作\" class=\"headerlink\" title=\"5.7 栅格化操作\"></a>5.7 栅格化操作</h3><p>渲染进程中的合成线程会将分解出来的图块发送到<u>栅格化线程池</u>中，由一系列<u>栅格化线程</u>对这些图块进行处理。<u>栅格化</u>就是指将图块转化为<u>位图</u>，图块是栅格化执行的最小操作。而通常栅格化的过程会使用<u>GPU</u>加速实现，前面第一大节提过GPU有独立的进程，所以这涉及了跨进程操作。具体的处理交互过程如图所示。</p>\n<p><img src=\"/images/react/2021122307.png\"></p>\n<p>如图可知，位图是在GPU进程中生成并且保存的。</p>\n<h3 id=\"5-8-合成和显示\"><a href=\"#5-8-合成和显示\" class=\"headerlink\" title=\"5.8 合成和显示\"></a>5.8 合成和显示</h3><p>当所有图块都被光栅化成位块后，渲染进程的合成线程会发生给浏览器主进程一个绘制图块命令——“<u>DrawQuad</u>“。浏览器主进程里有个叫viz的组件，用来接收该命令，然后根据该命令将页面内容绘制到内存中，最后将内存显示在屏幕上。</p>\n<h3 id=\"5-9-重排、重绘与合成\"><a href=\"#5-9-重排、重绘与合成\" class=\"headerlink\" title=\"5.9 重排、重绘与合成\"></a>5.9 重排、重绘与合成</h3><p>以上就已经讲述了渲染流水线的具体过程，接下来提出三个重要概念，这些概念在之后的<u>Web优化</u>中非常重要，也经常被面试官提及。</p>\n<p><strong>重排</strong>：顾名思义，就是重新排列了元素的布局。在实际情况中就是改变了元素的样式中几何位置相关的属性，比如<code>weight</code>、<code>height</code>、<code>margin</code>等。修改了这些属性，那么渲染流水线从样式计算到后面的布局阶段、分层阶段以及绘制等都需要改变，如下图所示。</p>\n<p><img src=\"\"></p>\n<p>根据该图也可以看出重排的开销非常大。</p>\n<p><strong>重绘</strong>：顾名思义是改变某些元素的某些颜色，比如背景、字体颜色等样式。因为不会引起布局的变动所以重绘之后会直接跳过布局阶段和分层阶段，但绘制列表是需要改变的，具体如下图所示。</p>\n<p><img src=\"/images/react/2021122309.png\"></p>\n<p>虽然重绘也有一定大的开销，但是相比于重排开销会有所减少。</p>\n<p><strong>合成</strong>：如果改变一些既不要布局也不需要绘制的属性，比如改变translate属性，渲染引擎就会直接跳过布局和绘制，而只执行后面的合成操作，具体如下图所示：</p>\n<p><img src=\"/images/react/2021122310.png\"></p>\n<p>根据上图可以得知，合成对比于重排和重绘开销最小。</p>\n<h3 id=\"5-10-渲染流水线总结\"><a href=\"#5-10-渲染流水线总结\" class=\"headerlink\" title=\"5.10 渲染流水线总结\"></a>5.10 渲染流水线总结</h3><p>上面已经分析了渲染流水线的每一个具体过程，现在可以根据以下这张图来概括性地说明从HTML到一张页面经历了什么。</p>\n<p><img src=\"/images/react/2021122311.png\"></p>\n<p>渲染进程获得所需的HTML、CSS、JavaScript等资源后，1.将<u>HTML内容</u>转化为可以理解的<u>DOM树</u>。2.将有关的<u>CSS内容</u>转为能够理解的styleSheets格式，对其进行标准化处理，并且计算出每个DOM节点的样式值，生成DOM树每个元素的<u>样式表</u>。3.根据<u>DOM树和对应的样式表</u>创建DOM可见节点的布局树，并且计算节点的布局信息，生成一棵<u>布局树</u>。4.对<u>布局树</u>进行分层，生成<u>图层树</u>。5.为<u>每个图层</u>生成绘制列表，并且提交<u>绘制列表</u>给渲染进程的合成线程。6.合成线程将<u>图层</u>分为<u>图块</u>。7.合成线程再将生成的<u>图块</u>在光栅化线程池中将转化成<u>位图</u>，这里会使用GPU而和GPU进程进行交互。8.完成<u>位图</u>制作后，合成线程会发送绘制图块命令DrawQuad给浏览器主进程，浏览器主进程根据消息生成<u>页面</u>，并展示到显示器上。</p>\n<p>可以看出每一个阶段都是有输入输出的，这样一张页面的渲染流程也展示完成了。</p>\n","site":{"data":{"galleries":[{"name":"她们","cover":"/images/beauty/02.jfif","description":"好喜欢她们啊。","photos":["/images/beauty/01.png","/images/beauty/02.jfif","/images/beauty/03.jfif","/images/beauty/05.JPG","/images/beauty/06.JPG","/images/beauty/07.PNG","/images/beauty/08.PNG","/images/beauty/12.png","/images/beauty/13.png","/images/beauty/14.png","/images/beauty/15.png","/images/beauty/16.png"]},{"name":"书摘","cover":"/images/book/01.jpg","description":"这些文字是不能被遗忘的。","photos":["/images/book/01.jpg"]},{"name":"Alex","cover":"/images/Alex/01.png","description":"有一个人爱上了你，如果你也喜欢那个人，那你就对她说：天空是白色的。如果我是那个人，那我会说：但云朵是黑的，这样我们就相爱了。Alex不只是一个人名。","photos":["/images/Alex/01.png","/images/Alex/02.png","/images/Alex/03.png","/images/Alex/05.png","/images/Alex/04.png","/images/Alex/06.png","/images/Alex/07.png","/images/Alex/08.png","/images/Alex/09.png","/images/Alex/10.png"]}]}},"excerpt":"","more":"<hr>\n<p><em>本文来源于<a href=\"http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。\">http://interview.poetries.top，然后在阅读过程中发现这是出于极光课程[《浏览器工作原理与实践》_-极客时间](https://time.geekbang.org/column/intro/216)。本文章是在阅读该资料时的笔记整理，有部分直接搬运原文，侵删。</a></em></p>\n<hr>\n<h2 id=\"1-浏览器发展史\"><a href=\"#1-浏览器发展史\" class=\"headerlink\" title=\"1.浏览器发展史\"></a>1.浏览器发展史</h2><h3 id=\"1-1-单进程浏览器\"><a href=\"#1-1-单进程浏览器\" class=\"headerlink\" title=\"1.1 单进程浏览器\"></a>1.1 单进程浏览器</h3><p>2007年之前，市面上的浏览器都是单进程的，单进程浏览器把需要运行的所有功能模块都放在一个进程里，而模块分为几个线程在进程里运行，这会导致如下几个问题。</p>\n<p><strong>不稳定问题</strong>：一个线程崩溃就会导致整个进程崩溃，也就是整个浏览器崩溃。</p>\n<p><strong>不流畅问题</strong>：单进程浏览器中，页面模块在一个线程中运行，如果该线程中有一个<u>无限循环的脚本</u>，那页面的其他模块就无法运行，会导致页面无法加载的问题。除此之外，单进程浏览器很容易出现页面<u>内存泄漏</u>从而导致计算机内存占用越来越高，浏览器运行越来越慢的问题。</p>\n<p><strong>不安全问题</strong>：在单进程浏览器中很容易让一些<u>恶意插件或脚本</u>释放病毒，获得计算机重要信息。</p>\n<h3 id=\"1-2-早期多进程浏览器\"><a href=\"#1-2-早期多进程浏览器\" class=\"headerlink\" title=\"1.2 早期多进程浏览器\"></a>1.2 早期多进程浏览器</h3><p>2008年Chrome的发布宣告浏览器进入多进程时代，早期的浏览器多进程架构是将各个插件从浏览器主进程中分离开独立成单个的进程，也将每个页面线程从主进程分离变成独立的每个渲染进程。这些被分割的进程都运行在<u>沙箱</u>中，进程之间通过<u>IPC</u>（进程间通信）进行通信。这种多进程模块的好处是让各个功能模块相互隔离，这样一个模块的问题导致的奔溃不会导致整个浏览器崩溃，解决了不稳定性问题。并且也因为独立的进程，使得一个页面脚本出现问题时不会影响整个浏览器以及独立的其他页面的运行（每个页面都是一个渲染进程），争对内存泄漏也可以通过关闭一个页面回收内存的方式解决，这就解决了不稳定性问题。此外，因为独立出来的功能模块进程都在sandbox（沙箱）中运行，受到一定的限制，无法读取计算机敏感位置的数据，所以安全性问题也得到了解决。</p>\n<h3 id=\"1-3-目前多进程浏览器\"><a href=\"#1-3-目前多进程浏览器\" class=\"headerlink\" title=\"1.3 目前多进程浏览器\"></a>1.3 目前多进程浏览器</h3><p>对比于早期的多进程架构，目前的Chrome又独立于浏览器主进程之外还多出了几个进程，包括<u>GPU进程、网络服务进程、缓存服务进程、备用渲染进程</u>。</p>\n<p>打开Chrome的任务管理器，下面显示的就是chrome浏览器中运行的进程，如图所示：</p>\n<p><img src=\"/images/react/2021122201.png\"></p>\n<p>多进程模型提高了浏览器的稳定性、流畅性以及安全性，但也带来了一定的问题，比如它占用了更高的资源，因为每个进程都会包含公共基础结构的副本；以及该模型有着更复杂的体系架构，这意味着浏览器各模块之间的<u>耦合性高、扩展性差</u>等问题。面对这些问题，现在的浏览器公司一直都在寻找更好的处理方法。</p>\n<h3 id=\"1-4-未来面向服务的架构\"><a href=\"#1-4-未来面向服务的架构\" class=\"headerlink\" title=\"1.4 未来面向服务的架构\"></a>1.4 未来面向服务的架构</h3><p>在2016年，Chrome团队就使用<u>面向服务架构</u>（SOA）的思想设计了新的Chrome架构，也就是说未来的浏览器会朝着SOA的方向发展，原来的各个模块会被重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务就必须使用定义好的接口，这样就可以建立一个<u>更加内聚、更低的耦合度，更加易于维护和扩展</u>的系统。但这必将是一个漫长的过程。</p>\n<h2 id=\"2-数据包从服务端完整传达给客服端浏览器的过程\"><a href=\"#2-数据包从服务端完整传达给客服端浏览器的过程\" class=\"headerlink\" title=\"2.数据包从服务端完整传达给客服端浏览器的过程\"></a>2.数据包从服务端完整传达给客服端浏览器的过程</h2><p>打开一个网页会显示各种信息，这些信息都是从这个网站的服务器端发送过来的，那么这些信息又是怎么包装完整地传达到客户端的浏览器上的呢？</p>\n<h3 id=\"2-1-数据包从服务端送达到目的主机\"><a href=\"#2-1-数据包从服务端送达到目的主机\" class=\"headerlink\" title=\"2.1 数据包从服务端送达到目的主机\"></a>2.1 数据包从服务端送达到目的主机</h3><p>数据必定是先从服务器运输到客户端的主机，才能从主机上升到具体的应用程序。两个主机之间的信息通信在网络体系模型的<u>网络层</u>中实现的，其中数据的运输则依靠于网络层中的<u>IP协议</u>。网络层传输的数据是以“分组”形式存在的，每一个分组都有一个头部，头部包含了源主机和目的主机的<u>IP地址</u>，依靠IP地址就可以实现两个主机之间的通信。</p>\n<h3 id=\"2-2-数据包从客户端主机到应用进程\"><a href=\"#2-2-数据包从客户端主机到应用进程\" class=\"headerlink\" title=\"2.2 数据包从客户端主机到应用进程\"></a>2.2 数据包从客户端主机到应用进程</h3><p>通过网络层的IP协议可以实现主机之间的网络通信，但是IP协议是个相对底层的协议，无法实现应用进程之间的通信，这需要通过网络层上一层的<u>传输层</u>才能实现通信。传输层通常有两个常用的协议，分别是<u>UDP协议</u>和<u>TCP协议</u>，通过两个协议在传输层产生的数据包都有一个头部，头部都包含了<u>源端口号和目的端口号</u>的信息，这个端口号就是具体的应用程序在主机上的端口号，根据端口号就可以实现数据包从客户端主机到应用进程的运输。</p>\n<h3 id=\"2-3-数据包可靠完整地被传达\"><a href=\"#2-3-数据包可靠完整地被传达\" class=\"headerlink\" title=\"2.3 数据包可靠完整地被传达\"></a>2.3 数据包可靠完整地被传达</h3><p>上节提到的UDP协议和TCP协议都是在传输层的协议，它们之间的区别是：UDP协议追求的是<u>快速</u>地传输，而TCP协议追求的是<u>完整</u>地传输，这就会导致UDP协议传输的数据很容易丢失，而TCP协议却保护了数据的完整性。在浏览器中运用到的应用层协议，无论是http协议还是WebSocket协议都使用TCP协议传输数据，从而保证了数据的完整性。那么TCP协议是如何做到完整传输数据的呢？</p>\n<p>区别于UDP协议，基于TCP协议有更复杂更加多数据的头部，包括数据包序号、确认号、数据偏移等信息，这些信息能够将混乱的数据包组合成一个完整的文件，并且对于缺失的数据包，TCP提供了重传机制。</p>\n<p>此外，为了保证数据传输的可靠性，进行TCP协议实际数据的传输前后分别由“三次握手”和“四次挥手来进行可靠的连接建立和断开。</p>\n<p>TCP协议需要进行三次握手的原因是为了防止失效的连接请求到达服务器，让服务器错误打开连接（具体详细解析可见”计算机网络基础知识点“的7.4节）。</p>\n<h2 id=\"3-HTTP请求流程\"><a href=\"#3-HTTP请求流程\" class=\"headerlink\" title=\"3.HTTP请求流程\"></a>3.HTTP请求流程</h2><p>HTTP协议是<u>应用层</u>协议，是浏览器使用最广泛的协议，通过它可以实现浏览器向服务器获取相关资源。HTTP协议建立在TCP协议基础之上，上一节已经知道通过TCP协议实现数据从服务器传输到浏览器中，那么浏览器又是怎么通过HTTP协议发送请求的呢？这节主要讲HTTP请求的具体流程。</p>\n<h3 id=\"3-1-构建请求\"><a href=\"#3-1-构建请求\" class=\"headerlink\" title=\"3.1 构建请求\"></a>3.1 构建请求</h3><p>通常访问一个网站的第一步就是在浏览器的地址栏中输入一个网站地址并点击跳转，这时就会构建一个请求，但是这个请求还在浏览器端，并没有开始运输。</p>\n<h3 id=\"3-2-查找缓存\"><a href=\"#3-2-查找缓存\" class=\"headerlink\" title=\"3.2 查找缓存\"></a>3.2 查找缓存</h3><p>在发送请求之前，浏览器会根据已经构建好的请求的基本数据在<u>缓存</u>中进行查找，如果有所需的数据，则它会直接拦截结束该请求，直接使用缓存中的副本，这样就能缓解服务器压力，也加快了浏览器上资源加载速度。</p>\n<h3 id=\"3-3-获取服务端的IP地址和端口\"><a href=\"#3-3-获取服务端的IP地址和端口\" class=\"headerlink\" title=\"3.3 获取服务端的IP地址和端口\"></a>3.3 获取服务端的IP地址和端口</h3><p>如果缓存中没有所需的数据，则要开始发送请求，但是根据第2节可知，实现一个数据包的运输需要知道对方主机的IP地址和端口号，所以需要先获取IP地址以及端口号。如何通过一个URL网址获得IP地址就要涉及<u>DNS协议</u>，浏览器已知的URL又被称为域名，域名和IP地址呈现一对一映射关系，通过DNS协议访问<u>域名服务器</u>可以获得所需要的IP地址，或者如果之前该浏览器访问过某网页，那么缓存中可能会存有该网络的IP地址。对于端口号，如果URL中没有特别指明端口号，那么HTTP协议默认的端口号是<u>80</u> 。</p>\n<h3 id=\"3-4-等待TCP队列，建立TCP连接\"><a href=\"#3-4-等待TCP队列，建立TCP连接\" class=\"headerlink\" title=\"3.4 等待TCP队列，建立TCP连接\"></a>3.4 等待TCP队列，建立TCP连接</h3><p>浏览器一般都有一个限制，即同一域名同时只能建立一定数量的TCP连接，如果超过这个数量，只能进入队列进行等待，若未超过这个数量，则能直接建立TCP连接，TCP连接的具体方式如第2大节所示。</p>\n<h3 id=\"3-5-发送HTTP请求\"><a href=\"#3-5-发送HTTP请求\" class=\"headerlink\" title=\"3.5 发送HTTP请求\"></a>3.5 发送HTTP请求</h3><p>建立了TCP连接，实现了TCP的三次握手，才能真正的发送HTTP请求。一个HTTP请求报文由<u>请求行、请求头部和请求体</u>组成，具体如下图所示：</p>\n<p><img src=\"/images/react/2021122202.png\"></p>\n<p>其中，请求行包括了<u>请求方法</u>（GET/POST/DELETE…）、<u>请求URL</u>以及<u>HTTP协议版本号</u>。请求头部包括了一些基础信息，比如浏览器所使用的操作系统、浏览器内核等信息。</p>\n<h3 id=\"3-6-服务器返回请求响应\"><a href=\"#3-6-服务器返回请求响应\" class=\"headerlink\" title=\"3.6 服务器返回请求响应\"></a>3.6 服务器返回请求响应</h3><p>服务器接收到浏览器的HTTP请求后，则会处理相应请求，如果服务器选择响应某些请求，就会发送客户端浏览器以HTTP响应数据信息，其中包括<u>响应行、响应头部和具体的响应体</u>。</p>\n<p>其中响应行包括<u>HTTP协议版本</u>和<u>状态码</u>信息，比如状态码为200则表示处理成功，状态码为404则表示没有响应页面。</p>\n<h3 id=\"3-7-断开连接\"><a href=\"#3-7-断开连接\" class=\"headerlink\" title=\"3.7 断开连接\"></a>3.7 断开连接</h3><p>通常情况下，一旦服务器向客户端返回了请求数据，就会断开TCP协议，如果浏览器或服务器在其HTTP请求头部或者响应头部中加上了<code>Connection:keep-alive</code>，则该TCP连接就会保持打开状态。</p>\n<h3 id=\"3-8-重定向\"><a href=\"#3-8-重定向\" class=\"headerlink\" title=\"3.8 重定向\"></a>3.8 重定向</h3><p>有时候会出现这种情况：用户在浏览器的地址栏中输入的URL在网页打开后会变成另外一个，这就涉及到了重定向。比如在我的火狐浏览器的地址栏中输入<code>sixteentime.github.io</code>，但是它马上跳转成网站<code>sixteentime.xyz</code>，这就是一个重定向的过程，可以打开该网站打开时的第一个响应报文，观察其响应头信息中有这样一行信息:<code>Location: http://sixteentime.xyz/ </code>这就执行了一个重定向流程，具体如下图所示：</p>\n<p><img src=\"/images/react/2021122203.png\"></p>\n<h3 id=\"3-9相关问题\"><a href=\"#3-9相关问题\" class=\"headerlink\" title=\"3.9相关问题\"></a>3.9相关问题</h3><p><strong>为什么很多网站第二次打开的速度会很快？</strong></p>\n<p>这是上面提到的浏览器<u>缓存机制</u>的原因。当网站第一次打开网站时，浏览器里没有该网站的缓存，浏览器则会发送请求给服务端请求数据，服务端返回数据给浏览器时，浏览器也会把页面数据存入缓存，然后在缓存的<u>生命周期</u>内再次打开该页面时，浏览器就不会发送请求给服务器而是直接使用缓存资源，这样就会使网站运行速度加快；若超过了这个生命周期，那么浏览器会担心这个缓存数据可能会过期，就会发送请求给服务器，如果服务器返回该缓存数据没有过期，那么浏览器会继续使用缓存数据加载页面，这样的加载速度也会相对较快。</p>\n<p>当然，浏览器的缓存中还有域名与IP地址的映射信息，第二次打开页面不需要发送请求到域名服务器获取域名对应的IP地址，也可以加快网页的加载速度。</p>\n<p><strong>网站的登录状态是如何保持的？</strong></p>\n<p>一般而言，服务器为了防止非系统用户的恶意攻击，对系统的访问方法都需要用户登陆信息，可是在浏览器中操作的用户只在最开始的时候输入账号密码进行登陆，之后在浏览器中的相关操作产生的请求都没有输入账号密码来证明信息，那么服务器是如何知道是哪个用户在进行请求访问呢？这就涉及到了HTTP的<u>Cookie</u>功能。</p>\n<p>当用户登陆网站输入账号密码信息并发送访问请求时，服务器收到相关数据会进行验证，若身份验证成功则会在返回的响应数据的响应头中字段<code>Set-Cookie</code>添加相关内容来表示用户身份信息，浏览器收到响应数据后会把对应的Cookie信息保存在本地。当用户登陆成功后在该网页进行其他操作而产生请求时，产生的请求报文的请求头上就会有<code>Cookie</code>字段信息，服务器接收到请求报文后，当核实Cookie内的字段能够核实用户身份，并且判断该用户处于登陆状态后，就会成功返回相关的数据信息。这就是网站通过Cookie保持用户登陆状态的原因。</p>\n<h2 id=\"4-从浏览器中输入URL到页面展示这中间发送了什么？\"><a href=\"#4-从浏览器中输入URL到页面展示这中间发送了什么？\" class=\"headerlink\" title=\"4.从浏览器中输入URL到页面展示这中间发送了什么？\"></a>4.从浏览器中输入URL到页面展示这中间发送了什么？</h2><p>这同时也是个常见的面试问题。</p>\n<p>上一大节中虽然详细讲述了HTTP协议请求发送和接收的流程，但是在上一节的描述中把浏览器的相关行为当成一个整体行为，从第一大节中我们可以了解到现在的浏览器是多进程模式，浏览器主进程负责其他子进程的管理、用户交互和文件储存的功能。从输入URL到页面展示的过程中主要涉及了三个进程之间的交互和运行，分别是<u>浏览器主进程、网络进程以及渲染进程</u>。</p>\n<p>具体这三个进程在这个过程中的运行和交互如下图所示：</p>\n<p><img src=\"/images/react/2021122204.png\"></p>\n<p>根据这张图引出一个新概念：导航。用户发出URL请求到页面开始解析的这个过程，就叫做导航。接下来将根据这张图，详细解析这一过程到底发生了什么。</p>\n<h3 id=\"4-1-用户输入\"><a href=\"#4-1-用户输入\" class=\"headerlink\" title=\"4.1 用户输入\"></a>4.1 用户输入</h3><p>用户在地址栏中可能会输入一个网站地址或者只是单纯搜索一些关键词。浏览器主进程会解析用户输入的内容，如果不符合URL规范，则会使用浏览器的默认搜索引擎来合成新的带搜索内容的URL；如果符合URL规范，则会根据规则加上相关协议，比如http://或者https://，合成完整的URL。</p>\n<p>当用户输入完成并敲击回车键后，浏览器并没有直接跳转到相关页面，中间有一段过渡时期，如下图所示：</p>\n<p><img src=\"/images/react/2021122205.png\"></p>\n<p>在该图的操作中，在浏览器地址栏中已经输入新的地址并键入回车，标签栏中可以看见页面正在加载的状态，但是网页内容并没有更新，还是原网页，这是因为直到浏览器等待到确认提交文档阶段，页面内容才会被替换成新的页面。</p>\n<h3 id=\"4-2-URL请求过程\"><a href=\"#4-2-URL请求过程\" class=\"headerlink\" title=\"4.2 URL请求过程\"></a>4.2 URL请求过程</h3><p>键入URL后就进入了请求过程，这也是导航流程的起始阶段。浏览器主进程通过IPC把URL请求发送至<u>网络进程</u>，在网络进程中真正的发送URL请求。</p>\n<p>首先，网络进程收到URL请求后，会先在浏览器<u>缓存</u>中查找是否有需要的资源，若有则把该资源直接返回给浏览器主进程，若没有再进行网络请求流程。</p>\n<p>在真正进入网络请求时先要进行<u>DNS解析</u>，通过浏览器缓存或者请求域名服务器获得URL的域名对应的IP地址。如果建立的是HTTPS请求，还需要先建立TLS连接。</p>\n<p>然后就是建立<u>TCP连接</u>，成功连接后，网络进程真正发送HTTP请求信息给服务器，服务器接收到请求进行对应处理后会返回响应数据给<u>网络进程</u>，网络进程收到数据后开始解析响应数据内容。</p>\n<p>如果服务器返回的响应数据的状态码是<u>301或302</u>，则表示当前的URL需要<u>重定位</u>到其他的URL，这时候网络进程根据响应数据头部的<code>Location</code>字段信息获取重定位地址，再次发送HTTP请求。</p>\n<p>如果服务器返回的响应数据的状态码是<u>200</u>，则说明服务器成功返回了相关的数据信息，浏览器可以继续处理请求。这时网络进程会分析响应数据的<u>类型</u>，一般来说接收到的响应数据有两种类型，查看响应头上的<code>Content-Type</code>字段，这个字段决定了响应数据的类型，若该字段的内容是<code>application/octet-stream</code>，则说明是字节流类型数据，这种情况下，浏览器会按照下载类型来处理，同时URL请求的导航流程也就结束了。如果收到的信息是<code>Content-Type: text/html </code>，则说明该数据是html格式数据，网络进程会通知<u>浏览器主进程</u>进行渲染准备，浏览器就会继续进行导航流程。</p>\n<h3 id=\"4-3-准备渲染进程\"><a href=\"#4-3-准备渲染进程\" class=\"headerlink\" title=\"4.3 准备渲染进程\"></a>4.3 准备渲染进程</h3><p>一般情况下浏览器会给每一张页面分配一个渲染进程，但是有些浏览器会给属于同一站点的页面，并且后一张页面是在前面那张页面内打开的这样的情况下给这些页面分配同一个渲染进程。所以如果浏览器主进程接收到了网络进程需要准备渲染的信号，则会判断是否需要新增一个渲染进程，还是使用原来已有的渲染进程。</p>\n<h3 id=\"4-4-提交文档\"><a href=\"#4-4-提交文档\" class=\"headerlink\" title=\"4.4 提交文档\"></a>4.4 提交文档</h3><p>这里所谓的“文档”是指URL请求的<u>响应体数据</u>。由浏览器主进程向渲染进程发出<u>“提交文档”</u>消息，<u>渲染进程</u>接收到消息后会和<u>网络进程</u>建立传输数据的“管道”。等文档数据从网络进程到渲染进程传输完成后，渲染进程会返回<u>“确认提交”</u>消息给浏览器主进程，当浏览器主进程接收到这个消息后，会更新浏览器界面状态，包括<u>安全状态、地址栏URL、前进后退历史状态、并且更新Web页面</u>。</p>\n<h3 id=\"4-5-渲染阶段\"><a href=\"#4-5-渲染阶段\" class=\"headerlink\" title=\"4.5 渲染阶段\"></a>4.5 渲染阶段</h3><p>当渲染进程发送“确认提交”的信息后，它便开始对收到的数据进行页面分析和资源加载，一旦页面生成完成，渲染进程会发送一个消息给浏览器主进程，浏览器主进程接收到消息后，就会停止标签栏上的<u>加载动画</u>。这样，一个完整的页面就展示完成了。</p>\n<h3 id=\"4-6-总结\"><a href=\"#4-6-总结\" class=\"headerlink\" title=\"4.6 总结\"></a>4.6 总结</h3><p>简化这个过程来回答这个问题，可以这样总结回答：</p>\n<p><strong>第一步</strong>是用户在地址栏中的<u>输入</u>，浏览器主进程会根据输入的消息自动完善或者转化URL地址，生成对应的<u>HTTP请求报文</u>。<strong>第二步</strong>浏览器主进程将请求发送给<u>网络进程</u>，网络进程先判断<u>缓存</u>中是否有需要的资源，若有则返回该资源给浏览器主进程，若无则准备发送HTTP请求。<strong>第三步</strong>在发送请求之前先确认服务器的<u>IP地址</u>，在缓存中寻找域名映射IP地址信息，若没有需要的数据则发送请求到域名服务器获取需要的IP地址，如果是URL中显示是HTTPS协议，则还要先建立TLS连接。<strong>第四步</strong>建立<u>TCP</u>连接，等待TCP连接成功后真正发送HTTP请求到服务端，并等待服务端返回响应包，若响应数据中的<u>状态码</u>是301或者302则说明需要<u>重定向</u>URL，则根据响应头里的<code>Locstion</code>的URL再次发送HTTP请求。若成功返回所需的响应包，先分析该响应数据的<u>数据格式</u>，网络进程需要解析响应头部的<code>Content-Type</code>字段，若是字节流类型，则会当作是需要下载的资源进行下载，则该流程结束；若是html类型则要通知浏览器主进程进行<u>渲染准备</u>。<strong>第五步</strong>浏览器主进程会检查url是否和之前打开的渲染进程有相同的根域名，若相同则复用原来的进程，不同则开启新的进程（这一步因浏览器而异，而且现在的浏览器好像只要是新的页面都会分配一个新的渲染进程）。<strong>第六步</strong>浏览器会发送<u>“提交文档”</u>消息给相应的渲染进程，渲染进程接收到后就会和网络进程建立传输数据的“管道”。直到它接受完数据后，渲染进程会向浏览器主进程发送<u>“确认提交”</u>消息，浏览器主进程接收到该消息后会更新浏览器界面的一些状态包括安全状态、地址栏url、前进后退的历史状态以及Web界面。到这里导航流程就结束了，直到渲染进程完全解析和加载完资源，成功渲染页面之后会发送消息通知浏览器主进程，浏览器主进程收到消息后就会停止标签栏中加载动画，这样一个页面就完成展示了。</p>\n<h2 id=\"5-页面渲染流程\"><a href=\"#5-页面渲染流程\" class=\"headerlink\" title=\"5.页面渲染流程\"></a>5.页面渲染流程</h2><p>上一节我们了解了从输入URL到生成一张页面的导航阶段的流程，导航阶段之后则是页面的渲染流程，此时渲染进程已经获取了生成一张页面所需要的资源包括HTML、CSS和JavaScript，那么这些文件又是如何被解析生成一张可视化页面的呢？</p>\n<p>由于渲染机制非常复杂，渲染模块会在执行的过程中被划分为很多子阶段，最后输出像素，这一过程被称为渲染流水线。按照渲染的时间顺序可以将该流水线分为这几个子阶段：<u>构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化以及合成显示</u>。值得注意的是，每个子阶段都有其<u>输入</u>和<u>输出</u>内容以及处理过程（我觉得这句话像句废话，但是看到最后我发现这句话很重要）。</p>\n<h3 id=\"5-1-构建DOM树\"><a href=\"#5-1-构建DOM树\" class=\"headerlink\" title=\"5.1 构建DOM树\"></a>5.1 构建DOM树</h3><p>浏览器无法直接理解HTML文件，需要将HTML转化成其能够理解的DOM树结构，可见下图所示。</p>\n<p><img src=\"/images/react/2021122301.png\"></p>\n<p>DOM树区分于HTML的是，DOM树是保持在内存中的树状结构，可以通过JavaScipt来查询或修改其内容。</p>\n<p>可以在Chrome浏览器中打开一张页面的开发者工具，点击控制台，在控制台中输入<code>document</code>并敲击回车键，就会呈现该页面HTML对应的DOM树，也可以在控制台中通过获取DOM树的某一节点来修改它的值，如下图所示。</p>\n<p><img src=\"/images/react/2021122302.png\"></p>\n<h3 id=\"5-2-样式计算\"><a href=\"#5-2-样式计算\" class=\"headerlink\" title=\"5.2 样式计算\"></a>5.2 样式计算</h3><p>样式计算是为了计算每一个DOM节点每个元素的具体样式。</p>\n<p>首先先要<strong>把CSS转化为浏览器能够理解的结构</strong>。CSS在一张网页中可能有多种呈现方式，包括引用外部css文件，在标签<code>&lt;style&gt;</code>中的CSS，以及在元素的<code>style</code>属性中填写的CSS。当渲染引擎接收到CSS文本时，会将其转化为浏览器可以理解的<u>styleSheets</u>结构，如下图所示，在控制台中输入<code>document.styleSheets</code>可以查看styleSheets结构。</p>\n<p><img src=\"/images/react/2021122303.png\"></p>\n<p>然后<strong>将样式表中的属性值转化为标准形式</strong>。比方说表达颜色可以有多种方式，例如<code>red</code>、<code>rgb(255,0,0)</code>，<code>#ff0000</code>都可以表示红色，所以为了统一展示需要将这些值标准化。</p>\n<p>最后<strong>计算出DOM树中每个节点的具体样式</strong>，由于CSS具有<u>继承性</u>，即子节点会继承父节点的样式，以及CSS的其他<u>层叠规则</u>，所以需要计算每个节点最后真正的样式值。这里的层叠规则是CSS的核心，之后具体复习CSS时会展开讲。</p>\n<h3 id=\"5-3-布局阶段\"><a href=\"#5-3-布局阶段\" class=\"headerlink\" title=\"5.3 布局阶段\"></a>5.3 布局阶段</h3><p>上面两小节以及完成了DOM树的构建以及DOM树中元素对应样式表的构建，接下来要进行布局阶段，要获得每个可见节点在页面上的具体位置。</p>\n<p><strong>创建布局树</strong>：在构建DOM树中会发现有很多标签如<code>head</code>标签都是不可见的，以及在创建样式表时也发现有一些元素带有例如<code>display:none</code>的属性，也是不可见的，所以需要建立一个只包含可见元素的布局树，如下图所示，就是通过DOM树和对应的样式表创建出的布局树。</p>\n<p><img src=\"/images/react/2021122304.png\"></p>\n<p><strong>布局计算</strong>：现在已有一棵布局树，然后就要进行布局计算，这一过程比较复杂，后面的章节会详细分析，总之在进行布局计算后会把运算结果重新写回布局树中。所以<u>这一阶段布局树既是输入内容又是输出结果</u>。</p>\n<h3 id=\"5-4-分层\"><a href=\"#5-4-分层\" class=\"headerlink\" title=\"5.4 分层\"></a>5.4 分层</h3><p>因为页面中有很多复杂的效果，比如页面滚动、3D转换等，所以为了方便实现这些效果，渲染引擎还需要生成一棵<u>图层树（LayerTree）</u>。打开Chrome的开发者工具，选择”Layers“标签，若没有该标签，则按下图所示操作添加该标签：</p>\n<p><img src=\"/images/react/2021122305.png\"></p>\n<p>比如，下面这个页面就有5个图层，如下图所示。</p>\n<p><img src=\"/images/react/2021122306.png\"></p>\n<p>不是布局树上的每一个节点都会被分配一个图层的，如果某些节点没有被分配图层，那它就属于父节点的图层，所以最终每个布局树上的节点都会直接或间接地从属于某一图层。符合以下两个条件之一的元素可以被提升为单独一个图层。</p>\n<p><strong>拥有层叠上下文属性的元素</strong>：比如定义position属性、z-index属性、filter属性以及opacity属性。</p>\n<p><strong>需要裁剪的元素</strong>：当元素里的内容超出元素本身大小时就需要被裁剪。</p>\n<p>确定好哪些节点会被分配新的图层后，就会生成一个图层树。图层树不一定和布局树的节点一一对应，但是<u>布局树上的每个节点一定都属于某一个图层</u>。</p>\n<h3 id=\"5-5-绘制\"><a href=\"#5-5-绘制\" class=\"headerlink\" title=\"5.5 绘制\"></a>5.5 绘制</h3><p>渲染引擎是通过构建<u>绘制列表</u>来实现具体的图层绘制过程的。绘制列表中每一个指令都代表一个绘制操作，通常要完成绘制一个元素需要好几条指令，因为通常一个元素会有背景、前景、边框等属性都需要单独的指令来实现。</p>\n<h3 id=\"5-6-分块\"><a href=\"#5-6-分块\" class=\"headerlink\" title=\"5.6 分块\"></a>5.6 分块</h3><p>绘制列表只是用来记录绘制指令的列表，实际完成绘制操作的是渲染进程中的<u>合成线程</u>。当在渲染进程的主线程上完成绘制列表后，它会把该列表提交给合成线程。</p>\n<p>这里先引入一个<u>”视口“</u>的概念。一般一些页面是超过浏览器窗口大小的，它们也许会很长，也许会很宽，而视口就是窗口上可见的页面区域。如果一张页面非常长而视口非常小，而要完整绘制该页面的所有图层内容是没必要的，这会引起很大开销。基于这个原因，合成线程将图层划分为许多<u>图块(tile)</u>，这些图块的大小通常是256x256或者512x512。</p>\n<h3 id=\"5-7-栅格化操作\"><a href=\"#5-7-栅格化操作\" class=\"headerlink\" title=\"5.7 栅格化操作\"></a>5.7 栅格化操作</h3><p>渲染进程中的合成线程会将分解出来的图块发送到<u>栅格化线程池</u>中，由一系列<u>栅格化线程</u>对这些图块进行处理。<u>栅格化</u>就是指将图块转化为<u>位图</u>，图块是栅格化执行的最小操作。而通常栅格化的过程会使用<u>GPU</u>加速实现，前面第一大节提过GPU有独立的进程，所以这涉及了跨进程操作。具体的处理交互过程如图所示。</p>\n<p><img src=\"/images/react/2021122307.png\"></p>\n<p>如图可知，位图是在GPU进程中生成并且保存的。</p>\n<h3 id=\"5-8-合成和显示\"><a href=\"#5-8-合成和显示\" class=\"headerlink\" title=\"5.8 合成和显示\"></a>5.8 合成和显示</h3><p>当所有图块都被光栅化成位块后，渲染进程的合成线程会发生给浏览器主进程一个绘制图块命令——“<u>DrawQuad</u>“。浏览器主进程里有个叫viz的组件，用来接收该命令，然后根据该命令将页面内容绘制到内存中，最后将内存显示在屏幕上。</p>\n<h3 id=\"5-9-重排、重绘与合成\"><a href=\"#5-9-重排、重绘与合成\" class=\"headerlink\" title=\"5.9 重排、重绘与合成\"></a>5.9 重排、重绘与合成</h3><p>以上就已经讲述了渲染流水线的具体过程，接下来提出三个重要概念，这些概念在之后的<u>Web优化</u>中非常重要，也经常被面试官提及。</p>\n<p><strong>重排</strong>：顾名思义，就是重新排列了元素的布局。在实际情况中就是改变了元素的样式中几何位置相关的属性，比如<code>weight</code>、<code>height</code>、<code>margin</code>等。修改了这些属性，那么渲染流水线从样式计算到后面的布局阶段、分层阶段以及绘制等都需要改变，如下图所示。</p>\n<p><img src=\"\"></p>\n<p>根据该图也可以看出重排的开销非常大。</p>\n<p><strong>重绘</strong>：顾名思义是改变某些元素的某些颜色，比如背景、字体颜色等样式。因为不会引起布局的变动所以重绘之后会直接跳过布局阶段和分层阶段，但绘制列表是需要改变的，具体如下图所示。</p>\n<p><img src=\"/images/react/2021122309.png\"></p>\n<p>虽然重绘也有一定大的开销，但是相比于重排开销会有所减少。</p>\n<p><strong>合成</strong>：如果改变一些既不要布局也不需要绘制的属性，比如改变translate属性，渲染引擎就会直接跳过布局和绘制，而只执行后面的合成操作，具体如下图所示：</p>\n<p><img src=\"/images/react/2021122310.png\"></p>\n<p>根据上图可以得知，合成对比于重排和重绘开销最小。</p>\n<h3 id=\"5-10-渲染流水线总结\"><a href=\"#5-10-渲染流水线总结\" class=\"headerlink\" title=\"5.10 渲染流水线总结\"></a>5.10 渲染流水线总结</h3><p>上面已经分析了渲染流水线的每一个具体过程，现在可以根据以下这张图来概括性地说明从HTML到一张页面经历了什么。</p>\n<p><img src=\"/images/react/2021122311.png\"></p>\n<p>渲染进程获得所需的HTML、CSS、JavaScript等资源后，1.将<u>HTML内容</u>转化为可以理解的<u>DOM树</u>。2.将有关的<u>CSS内容</u>转为能够理解的styleSheets格式，对其进行标准化处理，并且计算出每个DOM节点的样式值，生成DOM树每个元素的<u>样式表</u>。3.根据<u>DOM树和对应的样式表</u>创建DOM可见节点的布局树，并且计算节点的布局信息，生成一棵<u>布局树</u>。4.对<u>布局树</u>进行分层，生成<u>图层树</u>。5.为<u>每个图层</u>生成绘制列表，并且提交<u>绘制列表</u>给渲染进程的合成线程。6.合成线程将<u>图层</u>分为<u>图块</u>。7.合成线程再将生成的<u>图块</u>在光栅化线程池中将转化成<u>位图</u>，这里会使用GPU而和GPU进程进行交互。8.完成<u>位图</u>制作后，合成线程会发送绘制图块命令DrawQuad给浏览器主进程，浏览器主进程根据消息生成<u>页面</u>，并展示到显示器上。</p>\n<p>可以看出每一个阶段都是有输入输出的，这样一张页面的渲染流程也展示完成了。</p>\n"},{"_content":"---\n\n---\n\n# 前端相关问题\n\n## HTML\n\n### SEO（搜索引擎优化，Search Engine Optimization）相关方法\n\n- 语义化的HTML代码\n\n- 重要内容不要用js输出，爬虫不会执行js获取内容\n\n- 非装饰性图片必须加上alt,alt是图像替代文本。\n\n### html5有哪些新特性\n\n- 新增了媒体播放的video和audio\n\n- 新增了本地存储localStorage和sessionStorage\n\n- 新增了绘画canvas功能\n\n### 行内元素有哪些、块级元素有哪些、空元素有哪些\n\n- 行内元素有 `a span img input  select strong`，行内元素不可以设置宽高，不独占一行。\n\n- 块级元素有` div ul li dl h1 h2 h3 p`，块级元素可以设置宽高，独占一行。\n\n- 空元素有` br hr img input link meta`。\n\n### meta标签\n\n- meta标签可以实现自动跳转功能，如下代码所示：\n\n- ```\n  <meta http-equiv=\"Refresh\" content=\"5;URL=page2.html\">\n  ```\n\n- 去掉URL可以实现自动刷新功能。\n\n### HTML全局属性有哪些\n\n- class 、data-*、id、style等\n\n### 语义化相关问题\n\n- 语义化就是让标签有含义，使得代码结构清晰、可读性好、无障碍阅读、便于开发和维护、有利于搜索引擎\n\n- img的alt就是图片的替代文字，当不能显示图片的情况就会显示alt的内容，有助于搜索引擎；title只是图片的补充说明文字，当鼠标移动到图片上时会显示。\n\n- strong粗体强调标签，有语义化作用，b只是加粗效果。\n\n- em斜体强调标签，有语义化作用，i只是斜体展示。\n\n- h1表示标题样式，有语义化作用，title没有明确意义只表示是个标题。\n\n## CSS问题\n\n### CSS Sprite是什么，有什么优缺点\n\n- 雪碧图，就是一张大图是由很多小图合成，通过`background-position`和元素尺寸调节需要显示的背景图案。\n\n- 优点是减少了http请求次数，只需要请求一张图片。\n\n- 缺点是图片合成麻烦，图片维护麻烦。\n\n### `display: none;`与`visibility: hidden;`的区别\n\n- 两者都能让元素不可见。\n\n- display:none;改变的是布局，它能让元素从渲染树上消失，需要重新布局，会导致文档重排，是非继承属性。\n\n- visibility:hidden;不会改变布局，元素依旧存在渲染树上，只是重绘的效果，是可继承属性。\n\n### link和@import的区别\n\n- link是html的元素来引用外部资源，@import是在css文件中引用外部资源。\n\n- link最大限度支持并行下载，而@import过多嵌套导致串行下载。\n\n### 什么时候FOUC?如何避免\n\n- `flash of unstyled content` ： 用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再重新显示文档，造成页面闪烁。\n\n### 如何创建会块级格式上下文（BFC）\n\n- BFC是一个独立的渲染区域，让处于BFC内部的元素和外部的元素相互隔离，使得内外元素的定位不会相互影响。\n\n- 触发条件：`float`的值不为`none;` `overflow`的值不为`visible;` `display`的值不为`inline-block`或`table-xxx;` `position`的值不为`static`或`relative`。\n\n### 清除浮动的几种方式\n\n- 父级`div`定义`height`\n\n- 父级`div`定义伪类 `:after`和`zoom`\n\n- 父级`div`定义`overflow:hidden`\n\n### 初始化CSS样式\n\n- 为什么要初始化CSS样式：因为不同的浏览器对标签的默认值是不同的，初始化CSS可以使得任意浏览器显示的页面样式相同。\n\n### CSS3的新特性\n\n- 弹性盒子 `dispaly:flex;`\n\n- 颜色透明度 `color:rgba(0,0,0,0.5);`\n\n- 圆角 `border-radius:5px；`\n\n- 文字溢出 `text-overflow:ellipsis;`\n\n### display有哪些值\n\n- 设置元素浮动后，元素的display自动会变成block\n- block 转化为块状元素\n- inline 转化为行内元素\n- none 设置元素为不可见\n- inline-block 转化为行内块状元素\n- table 块级表格元素\n- inherit 继承父元素display属性值\n\n### position的值\n\n- static 默认值，没有定位，元素出现在正常流中。\n\n- absolute 绝对定位元素，相对于父元素定位\n\n- fixed 相对于窗口进行绝对定位\n\n- relative 相对于当前位置的相对定位\n\n- inherit 继承父级属性值。\n\n### 标准的CSS盒子模型和低版本IE盒子模型\n\n- 盒子模型都是由content内容，padding内边距,border边框，margin外边距组成，标准盒子模型内容不包括内边距，IE盒子模型内容包括外边距。对于标准盒子模型的元素总宽度是：width+padding+border+margin。\n\n### CSS优先级算法计算\n\n- 优先级：imortant>Html行内样式>id样式>类\\伪类样式>元素样式\n\n- 权重相同的元素后面定义的覆盖前面定义的\n\n### PNG/GIF/JPG区别和选择\n\n- GIF是动画，PNG和JPG是静态图片，JPG有损压缩，PNG适合小图标。\n\n### ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用\n\n- 单冒号表示伪类，双冒号表示伪元素\n\n- 伪元素，在内容元素的前后插入额外的元素或样式，但这些元素实际上并不在文档中生成，只在外部显示可见，有content的用法。\n\n- 伪类，将特殊效果添加到特定选择器上，是已有元素上添加类别，不会产生新的元素。\n\n### 可以改变页面布局的属性\n\n- position、display、float、width、height等（这个可能可以联系到之前学过的渲染原理篇）\n\n### CSS性能优化方法\n\n- CSS文件放在head里，不要用！import。\n\n- 多个css合并，尽量减少http请求\n\n- 选择器优化嵌套，尽量避免层次过深\n\n- 属性为0时不加单位\n\n### CSS3动画相关属性\n\n- transition\n\n- transform\n\n- animation\n\n### base64的原理及优缺点\n\n- 优点：加密，减少了http请求；缺点是需要消耗cpu进行编解码。\n\n- 适用于小图片，base64的体积约为原图4/3\n\n### 几种常见的CSS布局\n\n- 浮动布局，使用float\n\n- 圣杯布局，三列布局，中间主体内容。\n\n- flex布局\n\n### 外边距重叠\n\n- 两个外边距的单位相同（都是正或负），取绝对值的最大值，反之则相加。\n\n### rgba()和opacity的透明效果区别\n\n- 两者皆能透明，但是前者只作用于元素的颜色或背景色，没有继承性，后者作用于元素本身，其子元素也会透明。\n\n### px和em的区别\n\n- 都是长度单位\n\n- px的值是固定的，指定是多少就是多少，计算比较容易，相对于显示器屏幕分辨率。\n\n- em的值不是固定的，会继承父级元素的字体大小。em = 像素值 / 父级font-size\n\n- 浏览器的默认字体高是16px，所以未经调整的浏览器都符合1em=16px。\n\n### Sass和LESS\n\n- 它们是CSS预处理器，是CSS上的一种抽象层，它们是一种特俗的语法/语言编译成CSS。\n\n### 水平居中的方法\n\n- 元素为行内元素，设置父元素 text-align:center\n\n- 元素宽度固定，设置左右margin为auto\n\n- 采用flex-box布局，justify-content为center\n\n### 垂直居中的方法\n\n- 采用flex-box布局，align-item:center\n\n- 绝对定位中设置bottom:0;top:0，设置marhin:auto\n\n- 绝对定位中设置高度为top:50%,margin-top为自身高度的一半的负值。\n\n### 重绘与回流（重排）\n\n- 重绘：当渲染树中的元素外观改变时但不影响布局时，产生重绘。\n\n- 重排（回流）：当渲染树中的元素布局改变（比如位置、尺寸、隐藏/显示状态），产生重排，重排必然导致重绘。\n\n### 如何实现小于12px的字体效果\n\n- transform:scale()\n\n### CSS有哪些继承属性\n\n- 文本相关的属性，比如font-size,text-align等。颜色相关属性比如color。\n\n### 用纯CSS创建一个三角形\n\n```\n#demo{\n    width:0;\n    height:0;\n    border-width:20px;\n    border-style:solid;\n    border-color:transparent transparent red transparent;\n}\n```\n\n### 隐藏元素的方法\n\n- visibility:hidden;\n\n- opacity:0设置一个元素完全透明\n\n- display:none\n\n- height:0;border:0;\n\n### 什么是响应式设计？响应式设计的基本原理是？如何兼容低版本IE？\n\n- 响应式设计就是网站能够兼容多个终端\n\n- 基本原理是利用CSS3媒体查询，为不同尺寸设备适配不同版本\n\n- 对于低版本IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容。\n\n### a标签上四个伪类的执行顺序是什么？\n\n- link>visited>hover>active\n\n## JavaScript部分\n\n### 闭包\n\n- 闭包指有权访问另一个函数作用域中变量的函数，创建闭包最常见的方式就是一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用链域。\n\n- 闭包的特性：函数内再嵌套函数，内部函数可以引用外层的参数和变量；参数和变量不会被垃圾回收机制回收。\n\n### 作用域链\n\n- 作用域就是变量和函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期\n\n- 作用域链的作用是抱着执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止。\n\n### JavaScript原型、原型链\n\n- 每个对象都会在其内部初始化一个属性，就是prototype（原型），当我们访问一个对象的某个属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，这样一直找下去就形成了原型链的概念。\n\n### 事件代理\n\n- 事件代理指把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。\n\n### JavaScript继承\n\n- 构造继承\n\n- ```\n  function Parent(value){\n      this.val=value\n  }\n  Parent.prototype.getValue=function(){\n      console.log(this.val)\n  }\n  function Child(value){\n      Parent.call(this,value)\n  }\n  Child.prototype=new Parent()\n  const child=new Child(1)\n  child.getValue()//1\n  child instanceof Parent //true\n  ```\n\n- 原型继承\n\n### This对象的理解\n\n- 再函数定义中，this的指向是无法确定的，只有再函数执行时才能确定，this往往指向那个调用它的对象。\n\n- 对于匿名函数或者直接调用函数来说，this指向全局上下文（window）。\n\n- 对于es6的箭头函数，this的指向取决于该箭头函数声明的位置，在那里声明就指向谁。\n\n- 如果有new关键字，this被永远绑定在new出来的那个对象。\n\n- call、apply、bind中的this被强绑定在指定的那个对象上。\n\n### call、apply、bind方法对比分析\n\n- 这三个方法都是挂在function对象上的方法，都可以强行改变function中this的指向。\n\n- ```\n  func.call(thisArg,param1,param2,...)\n  //call方法直接执行\n  func.apply(thisArg,[param1,param2,...])\n  //apply方法直接执行\n  func.bind(thisArg,param1,param2,...)()\n  //bind方法返回待执行函数\n  ```\n\n### new操作符\n\n- 创建一个空对象，并且this变量引用该对象，同时继承了该函数的原型，属性和方法被加入到this引用的对象中，新创建的对象由this所引用，斌且最后隐式返回this。\n\n### Ajax原理\n\n- Ajax的原理就是在用户和服务器之间加一个中间层，通过XMLHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面，使得用户操作和服务器响应异步化。\n\n### 如何解决跨域问题\n\n- nginx代理跨域\n\n- nodejs中间件代理跨域\n\n### 异步加载JS的方式\n\n- 设置<script>属性 async=\"async\"\n\n- XmlHttpRequest脚本注入\n\n### 哪些操作会造成内存泄漏\n\n- 内存泄漏指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收\n\n- 不正确引用闭包函数\n\n- 未使用var声明的全局变量\n\n### XML和JSON的区别\n\n- 数据体积方面，JSON相对于XML来讲，数据的体积小，传递的速度更快些。\n\n- 数据交互方面，JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。\n\n- 传输速度方面，JSON的速度要远快于XML。\n\n- JSON是一种轻量级的数据交换格式，是基于JavaScript的一个子集。\n\n### webpack的看法\n\n- webpack是一个模块打包工具，可以使用webpack管理你的模块以来、并编译输出模块所需的静态文件。能够很好的管理、打包web开发中所用到的HTML、JavaScript、CSS以及各种静态文件，让开发过程更加高效。\n\n### 常见的Web安全及防护原理\n\n- 不要信任用户输入，用户的输入需要校验\n\n- 永远不要使用管理员权限的数据库连接，未每个应用使用单独的权限有限的数据库连接\n\n- 不要把机密信息明文存放，请加密或hash掉密码和敏感信息\n\n### 为什么会有同源限制\n\n- 同源策略是指协议、域名、端口相同，同源策略是一种安全协议，如果没有该策略黑客就可以轻易将病毒脚本插入到你的网站上盗取重要信息或者改变页面骗取用户\n\n### JavaScript有哪些方法定义（创建）对象\n\n- 使用var obj={};\n\n- 使用 var obj = new Object();\n\n- 使用var obj = Object.create(Object.prototype)；\n\n### 对promise的理解\n\n- Promise对象代表未来将要发生的事件，用来传递异步操作的消息。\n\n- 有了Promise对象，就可以将异步操作以同步操作的流程表现出来，避免了层层嵌套的回调函数（解决了回调地狱的问题）。\n\n- Promise对象的状态不受外界影响，有三种状态：Pending初始状态；fulfilled意味着操作成功完成状态；rejected意味着操作失败状态。一旦执行Promise就无法中途取消。\n\n### async/await\n\n- await相比promise来说，优势在于处理then的调用链，能够清晰准确写出代码。缺点在于滥用await会导致性能问题，因为await会阻塞代码。\n\n- 一个函数如果加上async，那么该函数就会返回一个Promise。\n\n- 清楚以下代码的执行顺序\n\n- ```\n  var a = 0\n  var b = async () => {\n    a = a + await 10\n    console.log('2', a) // -> '2' 10\n    a = (await 10) + a\n    console.log('3', a) // -> '3' 20\n  }\n  b()\n  a++\n  console.log('1', a) // -> '1' 1\n  ```\n\n### Node的应用场景\n\n- Node是一个JavaScript运行环境，依赖于Chrome V8引擎进行代码解释。它的优点是高并发，缺点是只支持单核CPU，不能充分利用CPU。\n\n### JS的基本数据类型和引用数据类型\n\n- 基本数据类型：underfined、null、boolean、number、string、symbol（存放在栈stack里）\n\n- 引用数据类型：object（存放在堆heap里）\n\n### JS数据类型检测\n\n- typeof对于原始数据来说，对于null返回的是object，其他都能显示正确的类型。对于引用数据来说，除了函数都会显示object。\n\n- instanceof可以正确判断对象类型，作用是检测当前实例是否属于某个类，但是它不能精准判断基础数据类型。\n\n### ==和===的应用实例\n\n- 只能转化为布尔值/数字/字符串\n\n- 其他规则见原文档\n\n### 四则运算\n\n- 运算中其中一方为字符串，那么就会把另一方也转换为字符串\n\n- 如果一方不是字符串或数字，那么会将它转换为数字或字符串\n\n- 对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。\n\n### 强制类型转换\n\n- Number()\n\n- parseInt()\n\n- parseFloat()\n\n- toString()\n\n- String()\n\n- Boolean()\n\n### js里有哪些内置对象\n\n- Object是所有对象的父对象\n\n- 数据封装类对象：Object、Array、Boolean、Number等。\n\n- 其他对象：Function\n\n### JavaScript的基本规范\n\n- 不要在同一行声明多个变量\n\n- 请使用===/!==来比较true/false或者数值。==，当等号两边的类型相同时直接比较是否相等，若类型不相同则先转化为类型相同的值再进行比较（规则：null和undefined相等，等号两边一个是数值，则把其他类型转化为数字再进步比较，NaN和任何值包括NaN都不想动）。\n\n- if语句必须使用大括号\n\n### null和undefined的区别\n\n- undefined表示不存在这个值，是一个表示“缺省值”的原始值，表示没有定义。如果变量被声明但是没有赋值时就等于undefined。\n\n- null表示一个对象被定义为“空值”，它是一个对象，在验证null时需要用===而不是==。\n\n### 同步和异步的区别\n\n- 同步：浏览器访问服务器请求，用户看得见页面刷新，重新发请求，等请求完，页面刷新，新内容出现，用户看得见新内容，进行下一步操作。同步就是必须先完成前意见事情才能按照顺序完成后一件顺序。\n\n- 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新新内容也会出现，用户能看到新的内容。异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。\n\n### defer和async\n\n- defer并行加载js文件，会按照页面上的script标签的顺序执行。\n\n- async并行加载js文件，下载完成立即执行，不会按照页面上script标签顺序执行。\n\n### Ajax\n\n- 它是一种异步通信的方法，通过直接由js脚本向服务器发起http通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。\n\n### ES6相关\n\n- 新增箭头函数\n\n- ES6将promise对象纳入规范，提供原生promise对象\n\n- 增加let和const命令用来声明变量（let变量增加了块级作用域）\n\n### 面向过程编程和面向对象编程\n\n- 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。\n\n- 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事务在整个解决问题的步骤中的行为。面向对象是以功能来划分问题，而不是步骤。\n\n- 面向对象的编程思想：基本思想是使用了对象、类、继承、封装等基本概念来进行程序设计。\n\n### 事件机制\n\n- 问题：事件的触发过程是怎么样的？知道什么是事件代理嘛？\n\n- 事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在DOM中两种不同的传播方法。事件流有三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。\n\n- 事件捕获就是当鼠标点击或者触发DOM事件时，浏览器会从根节点开始由外向内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定事件。\n\n- 事件冒泡的顺序是由内到外直到根节点的传播。\n\n### 如何通过js判断一个数组\n\n```\n//instanceof方法\nvar arr=[];\nreturn arr instanceof Array==true\n\n//constructor方法\nreturn arr.constructor == Array\n\n\n//isArray()方法\nreturn Array.isArray(arr) == true\n```\n\n### let、var、const\n\n- let和var都可以定义变量，const定义常量\n\n- let和const是在es6中推出的\n\n- let命令不存在变量提升，使用let和const命令会形成封闭作用域。\n\n- let和const不允许重复声明\n\n### map和forEach的区别\n\n- forEach方法是最基本的遍历循环方法，map方法和forEach一致但是它会返回一个新的数组，所以在callback需要有return值，如果没有，会返回undefined。\n\n### 箭头函数和普通函数的区别\n\n- 箭头函数体内的this对象指向定义时所在的对象而不是使用时所在的对象\n\n- 箭头函数不可以当作构造函数，不能使用new命令\n\n### 异步编程实现方法\n\n- 回调函数\n\n- 事件监听\n\n- 发布/订阅（观察者模式）\n\n- Promise对象\n\n- async对象\n\n### js动画和css动画的区别及相应实现\n\n- CSS3的动画在性能上会稍微好一点，代码相对简单，但是在动画控制上不够灵活。JavaScript的动画控制能力强大。\n\n### JS数组和对象的遍历方式\n\n- for循环、for in循环、forEach循环\n\n### Vue的双向绑定数据的原理\n\n- Vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter,getter，在数据变动时发布消息给订阅者，触发响应的监听回调。\n\n### 快速让一个数组乱序\n\n```\nvar arr=[1,2,3,4,5];\narr.sort(function(){\n    return Math.random()-0.5;\n})\nconsole.log(arr);\n```\n\n### 数组去重方法\n\n```\n//1\nfunction unique(arr){\n    return Array.from(new Set(arr))\n}\n//2\nfunction unique(arr){\n    for(var i=0;i<arr.length;i++){\n        for(var j=i+1;j<arr.length;j++){\n        if(arr[i]===arr[j]){\n            arr.splice(j,1)\n            }\n        }\n    }\n}\n//利用sort先排序后比较\n```\n\n### JS中的全局变量和全局函数\n\n- 全局变量：NaN\\undefined等\n\n- 全局函数：isNaN()、Number()、parseFloat()等\n\n### 项目性能优化方法\n\n- 减少HTTP请求数\n\n- 避免重定向\n\n- 压缩JavaScript、CSS、图片等\n\n- 把JavaScript放在页面底部\n\n### 浏览器缓存\n\n- 浏览器缓存分为强缓存和协商缓存，当客户端请求某个资源时，获取缓存的流程如下为先根据这个资源的一些http header判断它是否命中强缓存，如果命中则直接从本地获取缓存资源，如果没有命中，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，如果命中，服务器会返回请求但不反悔资源来告诉客户端直接从缓存中获取。\n\n### WebSocket\n\n- 由于http存在一个明显的弊端（消息只能有客户端推送到服务端），导致服务器如果有连续变化就只能使用轮询，轮询效率过低，并不适合。所以WebSocket被发明出来。\n\n- 对比HTTP，它支持双向通信，实时性强，可以发送文本和二进制文件。无跨域问题。\n\n### 深浅拷贝\n\n```\nlet a={ age:1 }\nlet b=a\na.age=2\nconsole.log(b.age)//2\n```\n\n- 在上面这个例子中，给一个变量赋值一个对象，那么两者引用的就是同一个值，一方改变另一方也会改变。面对上面这个简单的情况，即只有一层对象可以用浅拷贝来解决问题。\n\n- 浅拷贝用Object.assign来解决。\n\n- ```\n  let b=Object.assign({},a)\n  \n  //也可以用展开运算符来解决\n  let b={...a}\n  ```\n\n- 如果是多层对象则需要用深拷贝来解决。\n\n- ```\n  let a={age:1,\n         jobs:{first:'FE'}  \n        }\n  let b=JSON.parse(JSON.stringify(a))\n  //JSON.stringify()将js转json\n  //JSON.parse()将json转js\n  ```\n\n- 但是这个方法也是有局限的，它会忽略undefined，不能序列化函数，不能解决循环引用对象。\n\n### 防抖/节流\n\n- 防抖动是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行\n\n### 作用域和变量提升\n\n- 除了全局执行环境外，每当执行一个函数时也会创建一个新的执行环境，在生成新的执行环境时，会有两个阶段，第一个阶段就是创建的阶段，JS解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存，变量只声明并且赋值underfined，第二个阶段才是代码执行阶段。在变量提升过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升。\n\n### MVVM模型\n\n- MVVM是Model-View-ViewModel的缩写，也就是把MVC的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定倒ViewModel层并自动将数据渲染倒页面中，视图变化的时候会通知ViewModel层更新数据。\n\n- Model:代表数据模型，数据层，它仅仅关注数据本身而不关心任何行为。\n\n- View：用户操作界面，当ViewModel对Model进行更新时，会通过数据绑定更新到View。\n\n- ViewModel：业务逻辑层，View需要什么数据，ViewModel要提供这个数据，View有某些操作，ViewModel就要响应这些操作。\n\n### 请简单实现双向数据绑定\n\n```\n<input id=\"input\"/>\n```\n\n```\nconst data={};\nconst input = document.getElementById('input');\nObject.defineProperty(data, 'text', {\n    set(value){\n    input.value = value;\n    this.value = value;\n}\n});\ninput.onChange = function(e){\n    data.text = e.target.value;\n}\n```\n\n### 微任务和宏任务\n\n- JavaScript是单线程，为了协调任务有条不紊的运行页面进程引入了消息队列和事件循环机制，在主线程的消息队列中的任务叫做宏任务。比如 script、setTimeout、I/0\n- 在当前宏任务执行结束之前执行的任务一般都是微任务。比如process.nextTick、promise\n\n### JavaScript的组成\n\n- ECMAScript（核心）：JavaScript语言基础\n\n- DOM（文档对象模型）：规定了访问HTML和XML的接口\n\n- BOM(浏览器对象模型)：提供了浏览器窗口之间进行交互的对象和方法。\n\n### script的位置是否会影响首屏显示时间\n\n- 在解析HTML生成DOM过程中，js文件的下载是并行的，不需要DOM处理到script节点。因此，script的位置不影响首屏显示的开始时间。\n\n- 浏览器解析HTML是自上而下线性过程，script作为HTML的一部分同样遵循这个原则，因此，script会延迟DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间。\n\n### 介绍DOM的发展\n\n- DOM：文档对象模型，定义了访问HTML和XML文档的标准，与编程语言及平台无关。\n\n- DOM0：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。\n\n- DOM1：W3C提供标准。\n\n### key属性的作用\n\n- 由于在浏览器中操作DOM是很昂贵的，频繁操作DOM，会产生一定的性能问题，Key是元素的唯一标识符，设置key是未来尽可能复用DOM，从而高效更新虚拟DOM。\n\n### 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”\n\n- 客户区坐标：鼠标指针在可视区中水平坐标（clientX）和垂直坐标（clientY）。\n\n- 页面坐标：鼠标指针在页面布局中的水平坐标（pageX）和垂直坐标（pageY）。\n\n- 屏幕坐标：设备物理屏幕的水平坐标（screenX）和垂直坐标（screenY）。\n\n### JavaScript垃圾回收方法\n\n- 标记清除：这是JavaScript最常见的垃圾回收方式，当变量进入执行环境时，垃圾回收器会将其标记为“进入环境”，当变量离开环境时将其标记为“离开环境”。垃圾回收器会去除已经离开环境的变量。\n\n- 引用计数：跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收。\n\n### 如何删除一个cookie\n\n- 将时间设为当前时间往前一点。\n\n### JavaScript数组和对象有哪些原生的方法\n\n- 数组：`arr.concat(arr1,arr2,arr3)`合并几个数组返回一个新的数组。  `arr.join(\",\")`将数组作为字符串返回，中间以都好分隔。`arr.sort(func) `以func的方式进行数组排序。`arr.pop()`删除数组最后一个元素。 `arr.shift()`删除数组第一个元素。`arr.push(e1,e2)`从数组的末尾添加元素。`arr.unshift(e1,e2)`从数组的开头添加元素。`arr.reverse()`反转数组元素顺序。`arr.slice(start,end) `返回选定的元素组成的数组。`arr.splice(index,count,e1,e2,en)`改变原始数组，用于添加或删除数组元素，从下标Index开始数count个元素替换为e1,e2,en，返回的是被删除的数组。`arr.indexOf(el)`返回元素所在的下标。`arr.includes(el)`判断数组是否包含该元素，返回true/false。\n\n- 对象：`object.hasOwnProperty(prop)`判断该对象是否含有对应属性。`object.valueOf()`返回该对象的原始值。`object.toString()`返回一个表示该对象的字符串。\n\n## 微信小程序\n\n### 微信小程序有几个文件\n\n- 包括app.js、app.json、app.wxss以及关于页面的文件是WXML+WXSS+JS+JSON。\n\n### 微信小程序怎么样实现事件传值\n\n- 给WXML元素添加`data-*`属性来传递需要的值，然后通过e.currentTarget.dataset或者onload的param参数获取。\n\n### 小程序的wxss和css有什么区别\n\n- wxss的图片引入需使用外链地址。\n\n- 没有Body；样式可直接使用import导入。\n\n### 微信小程序与vue的区别\n\n- 生命周期不一样，微信小程序生命周期比较简单\n\n- 数据绑定不一样，微信小程序数据绑定直接使用{{}}，vue直接使用:就可以。\n\n- 显示和隐藏元素，vue中，使用v-if和v-show控制元素的显示和隐藏。小程序中使用wx-if和hidden控制元素的显示和隐藏。\n\n- 数据处理不同，小程序中，全用bindtap或者catchtap绑定事件。vue中使用von或@event绑定事件。\n\n### 微信小程序的生命周期\n\n- onLoad：首次进入页面加载时触发，一张页面只进行一次。\n\n- onShow：加载完成后、后台切到前台或者重新进入页面时触发。\n\n- onReady：页面首次渲染完成时触发。\n\n- onHide：从前台切换到后台或者进入其他页面时触发\n\n- onUnload“页面卸载时触发。\n\n## Vue\n\n### Vue响应式原理（双向数据绑定）\n\n- Vue的响应式原理的核心是通过Object.defindeProperty中访问器属性的get和set方法，data中声明的属性都被添加了访问器属性，当读取data中数据时自动调用get方法，修改data的数据时自动调用set方法。检测到数据的变化，会通知观察者Wacher，观察者自动触发重新render（粉刷、渲染）当前组件，生成新的虚拟DOM书，Vue框架会便利并对比新的虚拟DOM书和旧的虚拟DOM书中每个节点的差别，并记录下来。最后加载操作，将所有记录的不同点、局部修改到真实的DOM树上。\n\n- Object.denfineProperty()可以检测到对象中数据发生修改，但是无法深度监听复杂的对象。\n\n- Vue3.x中改用Proxy替代Object。defineProperty。因为Proxy可以直接监听对象和数组的变化。不需要深度遍历监听。Proxy是ES6中新增的功能，可以用来自定义对象的操作。\n\n- Vue采用数据劫持结合发布-订阅模式的方法来实现数据响应。数据劫持就是Object.defineProperty()来劫持各个属性的setter,getter。\n\n### 发布订阅模式和观察者模式\n\n- 发布/订阅模式：假设有一个信号中心。当某个任务执行完成就向信号中心发布（Publish）一个信号，其他任务可以向信号中心定和约（subscribe）这个信号，从而知道什么时候自己可以开始执行。发布/订阅模式由统一调度中心调用，因此发布者和订阅者不需要知道对方存在。\n\n- 观察者模式：当事件发生时，发布者通知自己所有的观察者，观察者获得信号就做需要做的事情。观察者模式是由具体的目标调度，比如当事件触发，Dep就会去调用观察者的方法，所以观察者模式的订阅者和发布者之间是存在依赖的。\n\n### 虚拟DOM\n\n- 虚拟DOM是用js对象模拟的，保存当前视图内所有DOM节点对象基本描述属性和节点间关系的树结构。\n\n- 虚拟DOM的好处是当状态改变时不需要立即更新DOM，只需要创建一个虚拟树来描述DOM，虚拟DOM可以维护程序状态，跟踪上一次的状态，最后通过前后两个虚拟DOM的对比差异来更新真实DOM。\n\n### Vue VS React\n\n- 相同点：数据驱动页面都提供响应式的视图组件；都有virtual DOM,组件化的开发；数据流动单向，都支持服务器的渲染SSR，都有支持native的方法。\n\n- 不同点：数据绑定上Vue实现双向数据绑定，React数据流动是单向的；对于大规模的数据渲染React要更快；在使用场景上React配合Redux架构适合大规模多人协作复杂项目，Vue适合小块的项目。开发风格上React推荐做法jsx+inline style把html和css都写在js了。vue是采用webpack+vue-loader单文件组件格式，html,js,css同一个文件。\n\n### Vue的生命周期\n\n- Vue2的生命周期函数顺序：beforeCreate（实例刚创建）、created（实例创建完成，属性已经绑定，但未生成真实DOM）、beforeMount（模板编译/挂载之前）、mounted（生成真实的DOM并替换到DOM Tree中，组件已挂载）、beforeUpdate（通知所有依赖项更新UI）、updated（组件已更新）、beforeDestroy（销毁开始）、destroyed（完成销毁）。\n\n- Vue3的生命周期函数顺序：onBeforeMount、onMounted、onBeforeUpdate、onUpdated、onBeforeUnmount、onUnmounted。\n\n### vue-router\n\n- 路由就是指向的意思，对应页面中点击图标跳转页面的作用。路由有三个基本概念：route,routes,router。route是一条路由，routes是一组路由，router是一个机制，相当于一个管理者，它用来管理路由。\n\n- 在vue中实现路由很简单，因为所有页面内容都是组件化的，所以只需要把路径和组件对应起来就行了，然后把组件渲染出来。\n\n- 先使用`<router-view>`标签来定义显示部分，再用`<router-link>`来对应点击本分，再js中配置路由，首先可以定义所有的单条路由route，再组合成路由组routes，最后创建router来对路由组进行管理。\n\n### VueX\n\n- Vuex是一个专为Vue.js应用程序开发的状态管理模式+库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n### Vue3\n\n- Vue3带来的新特性：压缩包体积更小；object.defineProperty改成Proxy等；重构Virtual DOM。\n\n### computed的理解\n\n- computed本质是一个惰性求值的观察者computed watcher。其内部通过this.dirty属性标记计算属性是否需要重新求值。\n\n- computed有缓存性，在computed中定义的变量会判断它是否和之前的值有变化，若发生改变则会重新渲染，若没有改变则调用上一次计算缓存的数据，对比methods每调用一次就会重新计算而言提高了程序的性能。\n\n### watch的理解\n\n- watch没有缓存性，更多的是观察的作用，只有当监听的数据产生变化时才会执行对应的程序。\n\n### keep-alive的理解\n\n- keep-alive是Vue提供的一个抽象组件，用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在v页面渲染完毕后不会被渲染成一个DOM元素。\n\n### Diff算法\n\n- 在新老虚拟DOM对比时使用Diff算法\n\n- 搜先对比节点本身，判断是否为同一节点，如果不为相同节点就删除该节点重新创建节点进行替换。\n\n- 若为相同节点就判断如何对该节点的子节点进行处理，先判断一方有子节点一方无子节点的情况，再判断两方都有子节点的情况。\n\n- 在diff中，只对同层子节点进行比较放弃跨级的节点比较，使得时间复杂度从O(N^3)转化为O(N)。\n\n## React\n\n### 对React的理解\n\n- React是一个网页UI框架，通过组件化方式解决视图层开发复用问题，本质上是一个组件化框架，它的核心设计思路分别是声明式、组件化和通用性。声明式优势在于直观与组合，组件化的优势在于视图的拆分与模块复用，可以更容易做到高内聚低耦合，通用性在于一次学习随处编写。\n\n## Http和浏览器\n\n### 浏览器架构演变\n\n- 一开始浏览器是单进程的，里面有很多线程比如说网络线程、页面线程等\n\n- 后来变成了多进程浏览器，进程之间相互隔离提高了性能。Chrome浏览器有一个浏览器主进程、一个GPU进程、一个网络进程、多个渲染进程和多个插件进程。\n\n### 进程和线程\n\n- 进程（process）是CPU资源分配的最小单位（是能拥有资源和独立运行的最小单位）\n\n- 线程（thread）是CPU调度的最小单位（是建立在进程基础的一次程序运行单位）\n\n### HTTP的几种请求\n\n- GET方法：发送请求获取服务器资源\n\n- POST方法：提交服务器某数据\n\n- PUT方法：PUT和POST不同的是，它制定了资源在服务器上的位置。\n\n- DELETE方法：删除服务器上某数据\n\n- OPTIONS方法，获取当前URL支持的所有方法。\n\n### HTTP状态码及其含义\n\n- 1XX：信息状态码。比如100表示继续，一般发送post请求时回返回该码。\n\n- 2XX：成功状态码。\n\n- 3XX：重定向。\n\n- 4XX：客户端错误。\n\n- 5XX：服务端错误。\n\n### HTTP版本\n\n- HTTP/0.9是个简单的文本协议，只能获取文本资源。只有一个命令GET。\n\n- HTTP/1.0确定了大部分现在的实用技术，设立请求/响应报文的头部字段，但它不是正是标准。除了GET命令外还引入了POST和HEAD命令。请求消息中URL并没有传递主机名。\n\n- HTTP/1.1是目前互联网上使用最广泛的协议，功能也非常完善，建立了长连接进行服用，对于TCP和HTTP的长连接。引入管道机制，即在同一个TCP连接中，客户端可以同时发送多个请求。HTTP请求头部信息增加了很多字段。新增了很多请求方法比如PUT、DELETE等。\n\n- HTTP/2基于Google的SPDY协议，注重性能改善，但未普及。头部压缩、多路复用等。\n\n- HTTP/3基于Google的QUIC协议，是将来的发展方向。\n\n### HTTP之URL\n\n- URL是用来唯一标记服务器上资源的一个字符串。\n\n- scheme :// host:port path ?query\n\n- scheme是协议名\n\n- host:port是资源所在服务器主机号和端口号\n\n- path标记资源所在的位置/\n\n- query为对资源附加额外要求\n\n### HTTP分层\n\n- OSI分为七层，分别是物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。\n\n- TCP/IP分为四层，分别是链接层，网络层，传输层和应用层。\n\n- 在网络层实现IP协议，在传输层实现TCP/UDP协议，在应用层实现HTTP等协议。\n\n### HTTP优缺点\n\n- 优点：灵活可扩展、请求-应答模式、可靠传输。\n\n- 缺点：无状态、明文传输、队头阻塞：当http开启长连接时，公用一个TCP连接，当某个请求时间过长，其他的请求只能处于阻塞状态。\n\n### HTTP和HTTPS的区别\n\n- HTTPS就是HTTP加上一个SSL或TLS，SSL/TLS协议是TCP和HTTP之间的协议。\n\n- SSL:安全套接层\n\n- TLS:传输层安全\n\n### 从浏览器地址栏输入URL到显示页面的步骤\n\n- 在地址栏中输入URL，首先会在浏览器的缓存中查找是否有对应资源，若有则直接返回给用户，若无则继续发送新的请求。\n\n- 若继续发送新的请求，则根据URL获取对应的域名，端口号等信息，并且组装一个HTTP(GET)请求报文。\n\n- 还需要获取服务端的IP地址，可以依次从浏览器的缓存、本机缓存、hosts文件、路由器缓存、DNS缓存中查找，若缓存中都没有就会从DNS服务器查找ip地址。\n\n- 此时先建立TCP连接，需要实现三次握手。\n\n- TCP链接建立后就发送之前已经组装的HTTP请求报文给服务器。\n\n- 服务器受到请求后会返回对应的数据给客户端，会按情况将资源存进缓存。\n\n- 可以根据情况关闭TCP连接，这时会有四次握手。\n\n- 浏览器收到资源会先进行解码。\n\n- 获得解析资源后第一步先根据html文件构建DOM树，根据CSS文件构建CSSOM树，两个数结合构建渲染树。\n\n- 解析中途遇到其他资源比如js等可以进行下载，之后进行js解析，最后生成页面，并显示在浏览器上。\n\n### DNS\n\n- DNS的工作就是通过域名查询到具体的IP。DNS协议提供的是一种主机名到IP地址的转换服务，通常该协议运行在UDP协议上使用的端口是53端口号。\n\n- 客户端先从浏览器缓存中查找对应IP，若无再查操作系统缓存，若无再找Host文件缓存，若无会直接去DNS跟服务器查询，然后依次传递查询一级域名服务器、二级域名服务器，三级域名服务器最后返回对应的查询结果。递归查询。\n\n### TCP建立连接的三次握手\n\n- 第一次握手：客服端向服务端发送请求报文，其中ACK=0,SYN=1。握手成功服务端知道了客户端具有发送能力。不懈怠数据。\n\n- 第二次握手：服务端返回客服端一个响应报文，其中SYN=1,ACK=1。握手成功客户端直到服务端具有接收和发送能力。不懈怠数据。\n\n- 第三次握手：客服端向服务端发送确认报文，其中SYN=0,ACK=1。握手成功，服务端知道客户端具有接受能力，已经准备好了。可以携带数据。\n\n- 三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。如果没有三次握手，会出现这种现象，客户端发送请求访问报文给服务端，但是这个报文在网络中受阻延迟没有及时传达到，而超时后客户端会再次发送请求报文给服务端，此时服务端就会收到并且要处理先后两条请求报文，有了三次握手，客户端会忽略服务器发送的第二条响应请求报文，不会进行第三次握手。三次握手的主要目的是为了确认双方发送和接受能力是否正常。三次握手是因为二次握手后，服务器还没有确定客户端是否准备好。\n\n### TCP释放连接的四次挥手\n\n- 第一次挥手：客户端向服务端发送释放请求报文，其中FIN=1\n\n- 第二次挥手：TCP处于半关闭状态，客户端无法再发送报文给服务端，服务端可以向客户端发送服务器端发送还未传送完毕的数据。\n\n- 第三次挥手：服务端向客户端发送释放报文，FIN=1\n\n- 第四次挥手：客户端向服务端发送确认报文，等待2MSL后释放应用。服务端收到确认报文后释放应用。\n\n- 客户端发送释放报文后，TCP处于半关闭状态，这个状态能让服务端继续发送未传送完毕的数据，数据传完后，服务器会发送释放报文。\n\n### UDP和TCP的区别\n\n- TCP协议再传送数据段时要给段标号，UDP不用。\n\n- TCP可靠，UDP不可靠。\n\n- TCP速度慢，UDP速度快。\n\n- TCP面向连接，UDP面向非连接。\n\n- TCP应用于传输大量数据，UDP应用于传输少量数据。\n\n### 如何进行网站性能优化\n\n- 减少http请求，对资源进行压缩，使用link代替@import，删除不必要的代码等。\n\n### 对于浏览器内核的理解\n\n- 浏览器主要分为两个部分，渲染引擎和JS引擎，前者主要负责网页内容的渲染工作，后者主要负责解析和指向js文件。浏览器内核主要倾向于指渲染引擎\n\n- Trident内核（IE、360、搜狗等浏览器）\n\n- Webkit内核（Safari、Chrome浏览器等）\n\n### 请描述cookies、sessionStorage和localStorage的区别\n\n- cookie是网站为了标示用户身份而存储在客户端上的数据，cookie数据始终在同源的http请求中携带，会在浏览器和服务器中来回传递。\n\n- sessionStorage和localStorage不会自动把数据发给服务器，仅保存在本地。\n\n- 在存储大小上：cookie数据大小不超过4K，sessionStorage和localStorage可以达到5M或更大。\n\n- 在有效时间上，localStorage存储持久数据，浏览器关闭后数据不会丢失除非主动删除，sessionStorage在浏览器窗口关闭就会自动删除，cookie数据在其设置的过期时间之前一直有效，即使浏览器关闭。\n\n### 渲染优化\n\n- 少使用gif图片实现loading效果（降低CPU消耗）、使用CSS3代码代替JS动画（尽量避免重绘重排）、对于一些小图标，使用base64编码代替网络连接以减少网络请求等。\n\n### 为什么利用多个域名来存储网站资源会更有效\n\n- 节约主域名的连接数，优化页面响应速度\n\n### 优化图片加载的方法\n\n- 如果是幻灯片、相册等可以使用图片预加载技术，优先下载当前图片前后的图片；如果图片是css图片可以采用CSSsprite以减少网络请求\n\n### web开发中会话跟踪的方法\n\n- 使用cookie\n\n- url重写\n\n### HTTP request报文结构是怎样的\n\n- 首行是Request-Line包括请求方法、请求URL、协议版本。之后是请求头，包括很多词组信息、之后是请求体。\n\n### HTTPresponse报文结构是怎样的\n\n- 首行是状态行包括HTTP版本、状态码、状态描述。之后是响应头，再之后是响应体。\n\n### git fetch和git pull的区别\n\n- git pull相当于是从远程获取最新版本并merge到本地，`git fetch`相当于是从远程获取最新版本到本地，不会自动Merge。\n\n### 跨域方案\n\n- 所有方案都是为了搞定同源政策，比如ifram、script、图片ping\n\n### XSS和CSRF\n\n- CSS攻击就是攻击者想尽一切办法将可以执行的代码注入到网页中。可以分为持久型和非持久型，前者是攻击的代码被服务器端写入数据库，后者是通过修改URL参数的方式加入攻击代码。防范方法是不该信任任何用户的输入，对用户输入进行排查筛选。\n\n- CSRF攻击是跨站请求伪造，简单说就是诱惑用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。防范方法是组织第三方网站请求接口，不让第三方网站访问到用户Cookie。\n\n## 算法和编程\n\n### 数组\n\n- 初始化数组 `const arr= new Array(7)`；简单填充数组 `const arr=(new Array(7)).fill(1)`。\n\n- 数组的遍历 for方法、forEach方法、map方法\n\n### 二叉树\n\n- 二叉树的遍历：先序遍历（根左右）、中序遍历（左根右）、后序遍历（左右根）\n\n## 综合\n\n### WebPack\n\n- 一个模块打包器，能将多个js文件合成一个，增加文档解析效率。\n\n### 重构\n\n- 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，也就是说在不改变UI的情况下对网站进行优化。\n\n- 比如针对SEO进行优化、表格table布局改DIV+CSS、升级第三方依赖、加入响应式布局、使用HTML5、CSS3、ES6新特性等。\n\n### 什么样的前端代码是好的\n\n- 高复用低耦合、遵循设计模式六大原则等。\n\n### 前端工程师这个职业\n\n- 前端是最贴近用户的程序员，比后端、数据库、产品经历、运营都要近。\n\n- 前端工程的价值体现在为简化用户使用提供技术支持、为多个浏览器兼容性提供支持、为提高用户浏览速度提供支持等。\n\n### 平时如何管理你的项目\n\n- 先确定好全局样式、公共脚本\n\n- 杨哥要求代码注释\n\n- 严格要求静态资源存放路径\n\n- Git提交必须填写说明\n\n### web前端开发注意事项\n\n- 多机型、多尺寸、多系统覆盖测试\n\n## 人文相关\n\n### 如何简单全面自我介绍\n\n- 我叫邵美芝，来自浙大城市学院软件工程专业。虽然我主修的方向是大数据和人工智能方向，但是一直以来对软件开发也有浓厚的兴趣。大二的暑假我开始自学微信小程序的前端开发，并且和同学一起申请了一个创新创业项目，我们开发的产品名称叫做“基于传感器技术的智能植物养护系统”，我主要负责的是前端微信小程序开发以及AI花卉识别技术的实现。该项目最后也获得了省级创新创业大赛铜奖，之后我负责编写软著申请材料并且成功申请到了两篇软著，并且也成功发表了两篇论文，其中我为第一作者发表的技术类论文发表在了《计算机时代》这个期刊中。在之后在大三暑假需要实习的时候，我被老师介绍进她的合办公司进行前端开发工作，也因此学习到了除了微信小程序之外的技术，包括vue、un-app技术，并且都运用在了实际开发中。在今年的寒假我也在主动学习React技术。\n\n### 对未来三到五年的规划\n\n- 我知道自己现在的能力相对比较薄弱，所以在未来的一到二年中，我觉得以学习为主是最重要的，我希望在前两年里能够在团队里\n\n### 你的优缺点是什么\n\n- 关于优点，我曾经在学校项目和课程中多次担任小组组长，自认为具有担当力和执行力，有较好的任务规划能力，也能努力脚踏实地地完成自己的任务。\n\n- 关于缺点，我不是一个活泼好动的人，做事比较内敛，很多事情喜欢自己先去琢磨和专研，直到实在无能为力才会寻求他人帮助，这样使得自己有时候会缺少和别人及时沟通而减缓了工作的效率。\n\n### 这份工作能带给你什么\n\n微信小程序复习\n\nwx:if view bindtap image src data-* {{}} wx.showToast this.setData\n\nwx.navigateTo({url:'...'}) wx.reLauch({}) 为什么要有key wx.request\n\nkey有什么作用\n\n账号加密处理  使用MD5加密\n\n网络请求包装\n\n```\nvar util=require('../utils/util.js')\nvar requestHandler={\nurl:'',\nmethod:'',\nparams:{},\nsuccess:function(res){\n},\nfail:function(res){\n},\n}\nvar app=getApp()\nfunction GET(requestHandler){\nrequest(\"GET\",requestHandler)}\nfunction POST(requestHandler){\nrequest(\"POST\",requestHandler)}\nfunction request(method,requestHandler){\nvar ARI_URL=requestHandler.url;\nvar params=requestHandler.params;\nwx.request({\nurl:API_URL,\ndata:params,\nmethod:method,\nheader:{},\nsuccess:function(res){\nrequestHandler.success(res)\n}\nfail:function(res){\nrequestHandler.fail(res)\n}\n})\n}\nmodule.exports={\nGET:GET,\nPOST:POST}\n```\n\n“一耕 GAP”农事记载平台2.0\n\n这是一款面向农户的良好农产品认证以及农产品管理平台。它有两大模块，面向农户的用户模式和面向农科院相关人员的管理员模式。\n\n用户模式主要有两大功能，第一就是农户为自己的产品申请良好农产品认证，需要用户填写包括自己的基本信息，生存产品的基本信息以及相关证明材料。第二就是当认证通过后用户能够为自己申请的产品进行相关管理，总共分为好几大模块，包括种植管理、农场基础信息管理、环境管理、畜牧管理、员工管理等。拥有不同产品的不同农户的农事管理页面也不相同，会根据农户的产品进行对应调配。\n\n管理员模式其实主要是在web端进行的，主要进行的是对农户申请认证信息的审核、以及农户管理产品信息等情况，但是根据甲方需求需要在移动端也增加一个简易版本的管理模块，所以微信小程序上也有了管理员模块。主要有主体信息管理和农事记录管理模块，主体信息管理就是争对每个农户以及他的整体产业的管理、农事记录管理是针对每一次农户记录在案的农事操作比如灌溉、播种等操作记录的管理。具体包括搜索、筛选、查看详情等操作。\n\n遇到过哪些问题\n\n原生组件不能满足需求，只能自己创建组件（picker组件只能支持三列选择，自己创建了五列选择）\n\n以及甲方一些需求，比如说管理端和用户端使用同一个微信小程序但是两个界面的底部导航条就是不一样的，所以就只能将四张页面集中写在一个page上来解决问题。\n\nvue\n\nelement-ui v-if v-model @click : v-for=\"(item,index) in list\"\n\n浙江省农科院样品管理系统\n\n这是一款面对浙江省农科院成员的平台，主要作用是线上管理农科院里的样品。主要包括三大模块，分别是被试物管理、对照物管理、参照物和标准物管理，其实这三个管理的流程是基本一致的。用户成员主要分为普通成员和样品管理员，当有新的样品进入农科院时，样品管理员就能在该平台上登记添加新的样品信息并依次分批使其入库，普通成员能够申请库中还有的样品，当样品管理员通过申请时普通成员就能使用该样品，最后使用完后普通成员需要申请样品归还，样品管理员审核归还的样品信息后会将归还的样品再次入库，最后样品管理员有权利作废样品。\n\n遇到过哪些问题\n\n这个项目只需要清楚业务逻辑就没有很大的问题，所以没有遇到什么比较困难的问题，一直都是根据甲方的需求更改一些功能和细节。比方说甲方希望能够有缓存功能就不用每次都输入很长的样品名称于是就设置了localStorage，甲方说直接在申请页面就能归还就在申请页面也增加了归还的接口等一些小细节问题。\n","source":"_posts/前端相关问题.md","raw":"---\n\n---\n\n# 前端相关问题\n\n## HTML\n\n### SEO（搜索引擎优化，Search Engine Optimization）相关方法\n\n- 语义化的HTML代码\n\n- 重要内容不要用js输出，爬虫不会执行js获取内容\n\n- 非装饰性图片必须加上alt,alt是图像替代文本。\n\n### html5有哪些新特性\n\n- 新增了媒体播放的video和audio\n\n- 新增了本地存储localStorage和sessionStorage\n\n- 新增了绘画canvas功能\n\n### 行内元素有哪些、块级元素有哪些、空元素有哪些\n\n- 行内元素有 `a span img input  select strong`，行内元素不可以设置宽高，不独占一行。\n\n- 块级元素有` div ul li dl h1 h2 h3 p`，块级元素可以设置宽高，独占一行。\n\n- 空元素有` br hr img input link meta`。\n\n### meta标签\n\n- meta标签可以实现自动跳转功能，如下代码所示：\n\n- ```\n  <meta http-equiv=\"Refresh\" content=\"5;URL=page2.html\">\n  ```\n\n- 去掉URL可以实现自动刷新功能。\n\n### HTML全局属性有哪些\n\n- class 、data-*、id、style等\n\n### 语义化相关问题\n\n- 语义化就是让标签有含义，使得代码结构清晰、可读性好、无障碍阅读、便于开发和维护、有利于搜索引擎\n\n- img的alt就是图片的替代文字，当不能显示图片的情况就会显示alt的内容，有助于搜索引擎；title只是图片的补充说明文字，当鼠标移动到图片上时会显示。\n\n- strong粗体强调标签，有语义化作用，b只是加粗效果。\n\n- em斜体强调标签，有语义化作用，i只是斜体展示。\n\n- h1表示标题样式，有语义化作用，title没有明确意义只表示是个标题。\n\n## CSS问题\n\n### CSS Sprite是什么，有什么优缺点\n\n- 雪碧图，就是一张大图是由很多小图合成，通过`background-position`和元素尺寸调节需要显示的背景图案。\n\n- 优点是减少了http请求次数，只需要请求一张图片。\n\n- 缺点是图片合成麻烦，图片维护麻烦。\n\n### `display: none;`与`visibility: hidden;`的区别\n\n- 两者都能让元素不可见。\n\n- display:none;改变的是布局，它能让元素从渲染树上消失，需要重新布局，会导致文档重排，是非继承属性。\n\n- visibility:hidden;不会改变布局，元素依旧存在渲染树上，只是重绘的效果，是可继承属性。\n\n### link和@import的区别\n\n- link是html的元素来引用外部资源，@import是在css文件中引用外部资源。\n\n- link最大限度支持并行下载，而@import过多嵌套导致串行下载。\n\n### 什么时候FOUC?如何避免\n\n- `flash of unstyled content` ： 用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再重新显示文档，造成页面闪烁。\n\n### 如何创建会块级格式上下文（BFC）\n\n- BFC是一个独立的渲染区域，让处于BFC内部的元素和外部的元素相互隔离，使得内外元素的定位不会相互影响。\n\n- 触发条件：`float`的值不为`none;` `overflow`的值不为`visible;` `display`的值不为`inline-block`或`table-xxx;` `position`的值不为`static`或`relative`。\n\n### 清除浮动的几种方式\n\n- 父级`div`定义`height`\n\n- 父级`div`定义伪类 `:after`和`zoom`\n\n- 父级`div`定义`overflow:hidden`\n\n### 初始化CSS样式\n\n- 为什么要初始化CSS样式：因为不同的浏览器对标签的默认值是不同的，初始化CSS可以使得任意浏览器显示的页面样式相同。\n\n### CSS3的新特性\n\n- 弹性盒子 `dispaly:flex;`\n\n- 颜色透明度 `color:rgba(0,0,0,0.5);`\n\n- 圆角 `border-radius:5px；`\n\n- 文字溢出 `text-overflow:ellipsis;`\n\n### display有哪些值\n\n- 设置元素浮动后，元素的display自动会变成block\n- block 转化为块状元素\n- inline 转化为行内元素\n- none 设置元素为不可见\n- inline-block 转化为行内块状元素\n- table 块级表格元素\n- inherit 继承父元素display属性值\n\n### position的值\n\n- static 默认值，没有定位，元素出现在正常流中。\n\n- absolute 绝对定位元素，相对于父元素定位\n\n- fixed 相对于窗口进行绝对定位\n\n- relative 相对于当前位置的相对定位\n\n- inherit 继承父级属性值。\n\n### 标准的CSS盒子模型和低版本IE盒子模型\n\n- 盒子模型都是由content内容，padding内边距,border边框，margin外边距组成，标准盒子模型内容不包括内边距，IE盒子模型内容包括外边距。对于标准盒子模型的元素总宽度是：width+padding+border+margin。\n\n### CSS优先级算法计算\n\n- 优先级：imortant>Html行内样式>id样式>类\\伪类样式>元素样式\n\n- 权重相同的元素后面定义的覆盖前面定义的\n\n### PNG/GIF/JPG区别和选择\n\n- GIF是动画，PNG和JPG是静态图片，JPG有损压缩，PNG适合小图标。\n\n### ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用\n\n- 单冒号表示伪类，双冒号表示伪元素\n\n- 伪元素，在内容元素的前后插入额外的元素或样式，但这些元素实际上并不在文档中生成，只在外部显示可见，有content的用法。\n\n- 伪类，将特殊效果添加到特定选择器上，是已有元素上添加类别，不会产生新的元素。\n\n### 可以改变页面布局的属性\n\n- position、display、float、width、height等（这个可能可以联系到之前学过的渲染原理篇）\n\n### CSS性能优化方法\n\n- CSS文件放在head里，不要用！import。\n\n- 多个css合并，尽量减少http请求\n\n- 选择器优化嵌套，尽量避免层次过深\n\n- 属性为0时不加单位\n\n### CSS3动画相关属性\n\n- transition\n\n- transform\n\n- animation\n\n### base64的原理及优缺点\n\n- 优点：加密，减少了http请求；缺点是需要消耗cpu进行编解码。\n\n- 适用于小图片，base64的体积约为原图4/3\n\n### 几种常见的CSS布局\n\n- 浮动布局，使用float\n\n- 圣杯布局，三列布局，中间主体内容。\n\n- flex布局\n\n### 外边距重叠\n\n- 两个外边距的单位相同（都是正或负），取绝对值的最大值，反之则相加。\n\n### rgba()和opacity的透明效果区别\n\n- 两者皆能透明，但是前者只作用于元素的颜色或背景色，没有继承性，后者作用于元素本身，其子元素也会透明。\n\n### px和em的区别\n\n- 都是长度单位\n\n- px的值是固定的，指定是多少就是多少，计算比较容易，相对于显示器屏幕分辨率。\n\n- em的值不是固定的，会继承父级元素的字体大小。em = 像素值 / 父级font-size\n\n- 浏览器的默认字体高是16px，所以未经调整的浏览器都符合1em=16px。\n\n### Sass和LESS\n\n- 它们是CSS预处理器，是CSS上的一种抽象层，它们是一种特俗的语法/语言编译成CSS。\n\n### 水平居中的方法\n\n- 元素为行内元素，设置父元素 text-align:center\n\n- 元素宽度固定，设置左右margin为auto\n\n- 采用flex-box布局，justify-content为center\n\n### 垂直居中的方法\n\n- 采用flex-box布局，align-item:center\n\n- 绝对定位中设置bottom:0;top:0，设置marhin:auto\n\n- 绝对定位中设置高度为top:50%,margin-top为自身高度的一半的负值。\n\n### 重绘与回流（重排）\n\n- 重绘：当渲染树中的元素外观改变时但不影响布局时，产生重绘。\n\n- 重排（回流）：当渲染树中的元素布局改变（比如位置、尺寸、隐藏/显示状态），产生重排，重排必然导致重绘。\n\n### 如何实现小于12px的字体效果\n\n- transform:scale()\n\n### CSS有哪些继承属性\n\n- 文本相关的属性，比如font-size,text-align等。颜色相关属性比如color。\n\n### 用纯CSS创建一个三角形\n\n```\n#demo{\n    width:0;\n    height:0;\n    border-width:20px;\n    border-style:solid;\n    border-color:transparent transparent red transparent;\n}\n```\n\n### 隐藏元素的方法\n\n- visibility:hidden;\n\n- opacity:0设置一个元素完全透明\n\n- display:none\n\n- height:0;border:0;\n\n### 什么是响应式设计？响应式设计的基本原理是？如何兼容低版本IE？\n\n- 响应式设计就是网站能够兼容多个终端\n\n- 基本原理是利用CSS3媒体查询，为不同尺寸设备适配不同版本\n\n- 对于低版本IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容。\n\n### a标签上四个伪类的执行顺序是什么？\n\n- link>visited>hover>active\n\n## JavaScript部分\n\n### 闭包\n\n- 闭包指有权访问另一个函数作用域中变量的函数，创建闭包最常见的方式就是一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用链域。\n\n- 闭包的特性：函数内再嵌套函数，内部函数可以引用外层的参数和变量；参数和变量不会被垃圾回收机制回收。\n\n### 作用域链\n\n- 作用域就是变量和函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期\n\n- 作用域链的作用是抱着执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止。\n\n### JavaScript原型、原型链\n\n- 每个对象都会在其内部初始化一个属性，就是prototype（原型），当我们访问一个对象的某个属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，这样一直找下去就形成了原型链的概念。\n\n### 事件代理\n\n- 事件代理指把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。\n\n### JavaScript继承\n\n- 构造继承\n\n- ```\n  function Parent(value){\n      this.val=value\n  }\n  Parent.prototype.getValue=function(){\n      console.log(this.val)\n  }\n  function Child(value){\n      Parent.call(this,value)\n  }\n  Child.prototype=new Parent()\n  const child=new Child(1)\n  child.getValue()//1\n  child instanceof Parent //true\n  ```\n\n- 原型继承\n\n### This对象的理解\n\n- 再函数定义中，this的指向是无法确定的，只有再函数执行时才能确定，this往往指向那个调用它的对象。\n\n- 对于匿名函数或者直接调用函数来说，this指向全局上下文（window）。\n\n- 对于es6的箭头函数，this的指向取决于该箭头函数声明的位置，在那里声明就指向谁。\n\n- 如果有new关键字，this被永远绑定在new出来的那个对象。\n\n- call、apply、bind中的this被强绑定在指定的那个对象上。\n\n### call、apply、bind方法对比分析\n\n- 这三个方法都是挂在function对象上的方法，都可以强行改变function中this的指向。\n\n- ```\n  func.call(thisArg,param1,param2,...)\n  //call方法直接执行\n  func.apply(thisArg,[param1,param2,...])\n  //apply方法直接执行\n  func.bind(thisArg,param1,param2,...)()\n  //bind方法返回待执行函数\n  ```\n\n### new操作符\n\n- 创建一个空对象，并且this变量引用该对象，同时继承了该函数的原型，属性和方法被加入到this引用的对象中，新创建的对象由this所引用，斌且最后隐式返回this。\n\n### Ajax原理\n\n- Ajax的原理就是在用户和服务器之间加一个中间层，通过XMLHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面，使得用户操作和服务器响应异步化。\n\n### 如何解决跨域问题\n\n- nginx代理跨域\n\n- nodejs中间件代理跨域\n\n### 异步加载JS的方式\n\n- 设置<script>属性 async=\"async\"\n\n- XmlHttpRequest脚本注入\n\n### 哪些操作会造成内存泄漏\n\n- 内存泄漏指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收\n\n- 不正确引用闭包函数\n\n- 未使用var声明的全局变量\n\n### XML和JSON的区别\n\n- 数据体积方面，JSON相对于XML来讲，数据的体积小，传递的速度更快些。\n\n- 数据交互方面，JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。\n\n- 传输速度方面，JSON的速度要远快于XML。\n\n- JSON是一种轻量级的数据交换格式，是基于JavaScript的一个子集。\n\n### webpack的看法\n\n- webpack是一个模块打包工具，可以使用webpack管理你的模块以来、并编译输出模块所需的静态文件。能够很好的管理、打包web开发中所用到的HTML、JavaScript、CSS以及各种静态文件，让开发过程更加高效。\n\n### 常见的Web安全及防护原理\n\n- 不要信任用户输入，用户的输入需要校验\n\n- 永远不要使用管理员权限的数据库连接，未每个应用使用单独的权限有限的数据库连接\n\n- 不要把机密信息明文存放，请加密或hash掉密码和敏感信息\n\n### 为什么会有同源限制\n\n- 同源策略是指协议、域名、端口相同，同源策略是一种安全协议，如果没有该策略黑客就可以轻易将病毒脚本插入到你的网站上盗取重要信息或者改变页面骗取用户\n\n### JavaScript有哪些方法定义（创建）对象\n\n- 使用var obj={};\n\n- 使用 var obj = new Object();\n\n- 使用var obj = Object.create(Object.prototype)；\n\n### 对promise的理解\n\n- Promise对象代表未来将要发生的事件，用来传递异步操作的消息。\n\n- 有了Promise对象，就可以将异步操作以同步操作的流程表现出来，避免了层层嵌套的回调函数（解决了回调地狱的问题）。\n\n- Promise对象的状态不受外界影响，有三种状态：Pending初始状态；fulfilled意味着操作成功完成状态；rejected意味着操作失败状态。一旦执行Promise就无法中途取消。\n\n### async/await\n\n- await相比promise来说，优势在于处理then的调用链，能够清晰准确写出代码。缺点在于滥用await会导致性能问题，因为await会阻塞代码。\n\n- 一个函数如果加上async，那么该函数就会返回一个Promise。\n\n- 清楚以下代码的执行顺序\n\n- ```\n  var a = 0\n  var b = async () => {\n    a = a + await 10\n    console.log('2', a) // -> '2' 10\n    a = (await 10) + a\n    console.log('3', a) // -> '3' 20\n  }\n  b()\n  a++\n  console.log('1', a) // -> '1' 1\n  ```\n\n### Node的应用场景\n\n- Node是一个JavaScript运行环境，依赖于Chrome V8引擎进行代码解释。它的优点是高并发，缺点是只支持单核CPU，不能充分利用CPU。\n\n### JS的基本数据类型和引用数据类型\n\n- 基本数据类型：underfined、null、boolean、number、string、symbol（存放在栈stack里）\n\n- 引用数据类型：object（存放在堆heap里）\n\n### JS数据类型检测\n\n- typeof对于原始数据来说，对于null返回的是object，其他都能显示正确的类型。对于引用数据来说，除了函数都会显示object。\n\n- instanceof可以正确判断对象类型，作用是检测当前实例是否属于某个类，但是它不能精准判断基础数据类型。\n\n### ==和===的应用实例\n\n- 只能转化为布尔值/数字/字符串\n\n- 其他规则见原文档\n\n### 四则运算\n\n- 运算中其中一方为字符串，那么就会把另一方也转换为字符串\n\n- 如果一方不是字符串或数字，那么会将它转换为数字或字符串\n\n- 对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。\n\n### 强制类型转换\n\n- Number()\n\n- parseInt()\n\n- parseFloat()\n\n- toString()\n\n- String()\n\n- Boolean()\n\n### js里有哪些内置对象\n\n- Object是所有对象的父对象\n\n- 数据封装类对象：Object、Array、Boolean、Number等。\n\n- 其他对象：Function\n\n### JavaScript的基本规范\n\n- 不要在同一行声明多个变量\n\n- 请使用===/!==来比较true/false或者数值。==，当等号两边的类型相同时直接比较是否相等，若类型不相同则先转化为类型相同的值再进行比较（规则：null和undefined相等，等号两边一个是数值，则把其他类型转化为数字再进步比较，NaN和任何值包括NaN都不想动）。\n\n- if语句必须使用大括号\n\n### null和undefined的区别\n\n- undefined表示不存在这个值，是一个表示“缺省值”的原始值，表示没有定义。如果变量被声明但是没有赋值时就等于undefined。\n\n- null表示一个对象被定义为“空值”，它是一个对象，在验证null时需要用===而不是==。\n\n### 同步和异步的区别\n\n- 同步：浏览器访问服务器请求，用户看得见页面刷新，重新发请求，等请求完，页面刷新，新内容出现，用户看得见新内容，进行下一步操作。同步就是必须先完成前意见事情才能按照顺序完成后一件顺序。\n\n- 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新新内容也会出现，用户能看到新的内容。异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。\n\n### defer和async\n\n- defer并行加载js文件，会按照页面上的script标签的顺序执行。\n\n- async并行加载js文件，下载完成立即执行，不会按照页面上script标签顺序执行。\n\n### Ajax\n\n- 它是一种异步通信的方法，通过直接由js脚本向服务器发起http通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。\n\n### ES6相关\n\n- 新增箭头函数\n\n- ES6将promise对象纳入规范，提供原生promise对象\n\n- 增加let和const命令用来声明变量（let变量增加了块级作用域）\n\n### 面向过程编程和面向对象编程\n\n- 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。\n\n- 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事务在整个解决问题的步骤中的行为。面向对象是以功能来划分问题，而不是步骤。\n\n- 面向对象的编程思想：基本思想是使用了对象、类、继承、封装等基本概念来进行程序设计。\n\n### 事件机制\n\n- 问题：事件的触发过程是怎么样的？知道什么是事件代理嘛？\n\n- 事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在DOM中两种不同的传播方法。事件流有三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。\n\n- 事件捕获就是当鼠标点击或者触发DOM事件时，浏览器会从根节点开始由外向内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定事件。\n\n- 事件冒泡的顺序是由内到外直到根节点的传播。\n\n### 如何通过js判断一个数组\n\n```\n//instanceof方法\nvar arr=[];\nreturn arr instanceof Array==true\n\n//constructor方法\nreturn arr.constructor == Array\n\n\n//isArray()方法\nreturn Array.isArray(arr) == true\n```\n\n### let、var、const\n\n- let和var都可以定义变量，const定义常量\n\n- let和const是在es6中推出的\n\n- let命令不存在变量提升，使用let和const命令会形成封闭作用域。\n\n- let和const不允许重复声明\n\n### map和forEach的区别\n\n- forEach方法是最基本的遍历循环方法，map方法和forEach一致但是它会返回一个新的数组，所以在callback需要有return值，如果没有，会返回undefined。\n\n### 箭头函数和普通函数的区别\n\n- 箭头函数体内的this对象指向定义时所在的对象而不是使用时所在的对象\n\n- 箭头函数不可以当作构造函数，不能使用new命令\n\n### 异步编程实现方法\n\n- 回调函数\n\n- 事件监听\n\n- 发布/订阅（观察者模式）\n\n- Promise对象\n\n- async对象\n\n### js动画和css动画的区别及相应实现\n\n- CSS3的动画在性能上会稍微好一点，代码相对简单，但是在动画控制上不够灵活。JavaScript的动画控制能力强大。\n\n### JS数组和对象的遍历方式\n\n- for循环、for in循环、forEach循环\n\n### Vue的双向绑定数据的原理\n\n- Vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter,getter，在数据变动时发布消息给订阅者，触发响应的监听回调。\n\n### 快速让一个数组乱序\n\n```\nvar arr=[1,2,3,4,5];\narr.sort(function(){\n    return Math.random()-0.5;\n})\nconsole.log(arr);\n```\n\n### 数组去重方法\n\n```\n//1\nfunction unique(arr){\n    return Array.from(new Set(arr))\n}\n//2\nfunction unique(arr){\n    for(var i=0;i<arr.length;i++){\n        for(var j=i+1;j<arr.length;j++){\n        if(arr[i]===arr[j]){\n            arr.splice(j,1)\n            }\n        }\n    }\n}\n//利用sort先排序后比较\n```\n\n### JS中的全局变量和全局函数\n\n- 全局变量：NaN\\undefined等\n\n- 全局函数：isNaN()、Number()、parseFloat()等\n\n### 项目性能优化方法\n\n- 减少HTTP请求数\n\n- 避免重定向\n\n- 压缩JavaScript、CSS、图片等\n\n- 把JavaScript放在页面底部\n\n### 浏览器缓存\n\n- 浏览器缓存分为强缓存和协商缓存，当客户端请求某个资源时，获取缓存的流程如下为先根据这个资源的一些http header判断它是否命中强缓存，如果命中则直接从本地获取缓存资源，如果没有命中，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，如果命中，服务器会返回请求但不反悔资源来告诉客户端直接从缓存中获取。\n\n### WebSocket\n\n- 由于http存在一个明显的弊端（消息只能有客户端推送到服务端），导致服务器如果有连续变化就只能使用轮询，轮询效率过低，并不适合。所以WebSocket被发明出来。\n\n- 对比HTTP，它支持双向通信，实时性强，可以发送文本和二进制文件。无跨域问题。\n\n### 深浅拷贝\n\n```\nlet a={ age:1 }\nlet b=a\na.age=2\nconsole.log(b.age)//2\n```\n\n- 在上面这个例子中，给一个变量赋值一个对象，那么两者引用的就是同一个值，一方改变另一方也会改变。面对上面这个简单的情况，即只有一层对象可以用浅拷贝来解决问题。\n\n- 浅拷贝用Object.assign来解决。\n\n- ```\n  let b=Object.assign({},a)\n  \n  //也可以用展开运算符来解决\n  let b={...a}\n  ```\n\n- 如果是多层对象则需要用深拷贝来解决。\n\n- ```\n  let a={age:1,\n         jobs:{first:'FE'}  \n        }\n  let b=JSON.parse(JSON.stringify(a))\n  //JSON.stringify()将js转json\n  //JSON.parse()将json转js\n  ```\n\n- 但是这个方法也是有局限的，它会忽略undefined，不能序列化函数，不能解决循环引用对象。\n\n### 防抖/节流\n\n- 防抖动是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行\n\n### 作用域和变量提升\n\n- 除了全局执行环境外，每当执行一个函数时也会创建一个新的执行环境，在生成新的执行环境时，会有两个阶段，第一个阶段就是创建的阶段，JS解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存，变量只声明并且赋值underfined，第二个阶段才是代码执行阶段。在变量提升过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升。\n\n### MVVM模型\n\n- MVVM是Model-View-ViewModel的缩写，也就是把MVC的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定倒ViewModel层并自动将数据渲染倒页面中，视图变化的时候会通知ViewModel层更新数据。\n\n- Model:代表数据模型，数据层，它仅仅关注数据本身而不关心任何行为。\n\n- View：用户操作界面，当ViewModel对Model进行更新时，会通过数据绑定更新到View。\n\n- ViewModel：业务逻辑层，View需要什么数据，ViewModel要提供这个数据，View有某些操作，ViewModel就要响应这些操作。\n\n### 请简单实现双向数据绑定\n\n```\n<input id=\"input\"/>\n```\n\n```\nconst data={};\nconst input = document.getElementById('input');\nObject.defineProperty(data, 'text', {\n    set(value){\n    input.value = value;\n    this.value = value;\n}\n});\ninput.onChange = function(e){\n    data.text = e.target.value;\n}\n```\n\n### 微任务和宏任务\n\n- JavaScript是单线程，为了协调任务有条不紊的运行页面进程引入了消息队列和事件循环机制，在主线程的消息队列中的任务叫做宏任务。比如 script、setTimeout、I/0\n- 在当前宏任务执行结束之前执行的任务一般都是微任务。比如process.nextTick、promise\n\n### JavaScript的组成\n\n- ECMAScript（核心）：JavaScript语言基础\n\n- DOM（文档对象模型）：规定了访问HTML和XML的接口\n\n- BOM(浏览器对象模型)：提供了浏览器窗口之间进行交互的对象和方法。\n\n### script的位置是否会影响首屏显示时间\n\n- 在解析HTML生成DOM过程中，js文件的下载是并行的，不需要DOM处理到script节点。因此，script的位置不影响首屏显示的开始时间。\n\n- 浏览器解析HTML是自上而下线性过程，script作为HTML的一部分同样遵循这个原则，因此，script会延迟DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间。\n\n### 介绍DOM的发展\n\n- DOM：文档对象模型，定义了访问HTML和XML文档的标准，与编程语言及平台无关。\n\n- DOM0：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。\n\n- DOM1：W3C提供标准。\n\n### key属性的作用\n\n- 由于在浏览器中操作DOM是很昂贵的，频繁操作DOM，会产生一定的性能问题，Key是元素的唯一标识符，设置key是未来尽可能复用DOM，从而高效更新虚拟DOM。\n\n### 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”\n\n- 客户区坐标：鼠标指针在可视区中水平坐标（clientX）和垂直坐标（clientY）。\n\n- 页面坐标：鼠标指针在页面布局中的水平坐标（pageX）和垂直坐标（pageY）。\n\n- 屏幕坐标：设备物理屏幕的水平坐标（screenX）和垂直坐标（screenY）。\n\n### JavaScript垃圾回收方法\n\n- 标记清除：这是JavaScript最常见的垃圾回收方式，当变量进入执行环境时，垃圾回收器会将其标记为“进入环境”，当变量离开环境时将其标记为“离开环境”。垃圾回收器会去除已经离开环境的变量。\n\n- 引用计数：跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收。\n\n### 如何删除一个cookie\n\n- 将时间设为当前时间往前一点。\n\n### JavaScript数组和对象有哪些原生的方法\n\n- 数组：`arr.concat(arr1,arr2,arr3)`合并几个数组返回一个新的数组。  `arr.join(\",\")`将数组作为字符串返回，中间以都好分隔。`arr.sort(func) `以func的方式进行数组排序。`arr.pop()`删除数组最后一个元素。 `arr.shift()`删除数组第一个元素。`arr.push(e1,e2)`从数组的末尾添加元素。`arr.unshift(e1,e2)`从数组的开头添加元素。`arr.reverse()`反转数组元素顺序。`arr.slice(start,end) `返回选定的元素组成的数组。`arr.splice(index,count,e1,e2,en)`改变原始数组，用于添加或删除数组元素，从下标Index开始数count个元素替换为e1,e2,en，返回的是被删除的数组。`arr.indexOf(el)`返回元素所在的下标。`arr.includes(el)`判断数组是否包含该元素，返回true/false。\n\n- 对象：`object.hasOwnProperty(prop)`判断该对象是否含有对应属性。`object.valueOf()`返回该对象的原始值。`object.toString()`返回一个表示该对象的字符串。\n\n## 微信小程序\n\n### 微信小程序有几个文件\n\n- 包括app.js、app.json、app.wxss以及关于页面的文件是WXML+WXSS+JS+JSON。\n\n### 微信小程序怎么样实现事件传值\n\n- 给WXML元素添加`data-*`属性来传递需要的值，然后通过e.currentTarget.dataset或者onload的param参数获取。\n\n### 小程序的wxss和css有什么区别\n\n- wxss的图片引入需使用外链地址。\n\n- 没有Body；样式可直接使用import导入。\n\n### 微信小程序与vue的区别\n\n- 生命周期不一样，微信小程序生命周期比较简单\n\n- 数据绑定不一样，微信小程序数据绑定直接使用{{}}，vue直接使用:就可以。\n\n- 显示和隐藏元素，vue中，使用v-if和v-show控制元素的显示和隐藏。小程序中使用wx-if和hidden控制元素的显示和隐藏。\n\n- 数据处理不同，小程序中，全用bindtap或者catchtap绑定事件。vue中使用von或@event绑定事件。\n\n### 微信小程序的生命周期\n\n- onLoad：首次进入页面加载时触发，一张页面只进行一次。\n\n- onShow：加载完成后、后台切到前台或者重新进入页面时触发。\n\n- onReady：页面首次渲染完成时触发。\n\n- onHide：从前台切换到后台或者进入其他页面时触发\n\n- onUnload“页面卸载时触发。\n\n## Vue\n\n### Vue响应式原理（双向数据绑定）\n\n- Vue的响应式原理的核心是通过Object.defindeProperty中访问器属性的get和set方法，data中声明的属性都被添加了访问器属性，当读取data中数据时自动调用get方法，修改data的数据时自动调用set方法。检测到数据的变化，会通知观察者Wacher，观察者自动触发重新render（粉刷、渲染）当前组件，生成新的虚拟DOM书，Vue框架会便利并对比新的虚拟DOM书和旧的虚拟DOM书中每个节点的差别，并记录下来。最后加载操作，将所有记录的不同点、局部修改到真实的DOM树上。\n\n- Object.denfineProperty()可以检测到对象中数据发生修改，但是无法深度监听复杂的对象。\n\n- Vue3.x中改用Proxy替代Object。defineProperty。因为Proxy可以直接监听对象和数组的变化。不需要深度遍历监听。Proxy是ES6中新增的功能，可以用来自定义对象的操作。\n\n- Vue采用数据劫持结合发布-订阅模式的方法来实现数据响应。数据劫持就是Object.defineProperty()来劫持各个属性的setter,getter。\n\n### 发布订阅模式和观察者模式\n\n- 发布/订阅模式：假设有一个信号中心。当某个任务执行完成就向信号中心发布（Publish）一个信号，其他任务可以向信号中心定和约（subscribe）这个信号，从而知道什么时候自己可以开始执行。发布/订阅模式由统一调度中心调用，因此发布者和订阅者不需要知道对方存在。\n\n- 观察者模式：当事件发生时，发布者通知自己所有的观察者，观察者获得信号就做需要做的事情。观察者模式是由具体的目标调度，比如当事件触发，Dep就会去调用观察者的方法，所以观察者模式的订阅者和发布者之间是存在依赖的。\n\n### 虚拟DOM\n\n- 虚拟DOM是用js对象模拟的，保存当前视图内所有DOM节点对象基本描述属性和节点间关系的树结构。\n\n- 虚拟DOM的好处是当状态改变时不需要立即更新DOM，只需要创建一个虚拟树来描述DOM，虚拟DOM可以维护程序状态，跟踪上一次的状态，最后通过前后两个虚拟DOM的对比差异来更新真实DOM。\n\n### Vue VS React\n\n- 相同点：数据驱动页面都提供响应式的视图组件；都有virtual DOM,组件化的开发；数据流动单向，都支持服务器的渲染SSR，都有支持native的方法。\n\n- 不同点：数据绑定上Vue实现双向数据绑定，React数据流动是单向的；对于大规模的数据渲染React要更快；在使用场景上React配合Redux架构适合大规模多人协作复杂项目，Vue适合小块的项目。开发风格上React推荐做法jsx+inline style把html和css都写在js了。vue是采用webpack+vue-loader单文件组件格式，html,js,css同一个文件。\n\n### Vue的生命周期\n\n- Vue2的生命周期函数顺序：beforeCreate（实例刚创建）、created（实例创建完成，属性已经绑定，但未生成真实DOM）、beforeMount（模板编译/挂载之前）、mounted（生成真实的DOM并替换到DOM Tree中，组件已挂载）、beforeUpdate（通知所有依赖项更新UI）、updated（组件已更新）、beforeDestroy（销毁开始）、destroyed（完成销毁）。\n\n- Vue3的生命周期函数顺序：onBeforeMount、onMounted、onBeforeUpdate、onUpdated、onBeforeUnmount、onUnmounted。\n\n### vue-router\n\n- 路由就是指向的意思，对应页面中点击图标跳转页面的作用。路由有三个基本概念：route,routes,router。route是一条路由，routes是一组路由，router是一个机制，相当于一个管理者，它用来管理路由。\n\n- 在vue中实现路由很简单，因为所有页面内容都是组件化的，所以只需要把路径和组件对应起来就行了，然后把组件渲染出来。\n\n- 先使用`<router-view>`标签来定义显示部分，再用`<router-link>`来对应点击本分，再js中配置路由，首先可以定义所有的单条路由route，再组合成路由组routes，最后创建router来对路由组进行管理。\n\n### VueX\n\n- Vuex是一个专为Vue.js应用程序开发的状态管理模式+库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n### Vue3\n\n- Vue3带来的新特性：压缩包体积更小；object.defineProperty改成Proxy等；重构Virtual DOM。\n\n### computed的理解\n\n- computed本质是一个惰性求值的观察者computed watcher。其内部通过this.dirty属性标记计算属性是否需要重新求值。\n\n- computed有缓存性，在computed中定义的变量会判断它是否和之前的值有变化，若发生改变则会重新渲染，若没有改变则调用上一次计算缓存的数据，对比methods每调用一次就会重新计算而言提高了程序的性能。\n\n### watch的理解\n\n- watch没有缓存性，更多的是观察的作用，只有当监听的数据产生变化时才会执行对应的程序。\n\n### keep-alive的理解\n\n- keep-alive是Vue提供的一个抽象组件，用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在v页面渲染完毕后不会被渲染成一个DOM元素。\n\n### Diff算法\n\n- 在新老虚拟DOM对比时使用Diff算法\n\n- 搜先对比节点本身，判断是否为同一节点，如果不为相同节点就删除该节点重新创建节点进行替换。\n\n- 若为相同节点就判断如何对该节点的子节点进行处理，先判断一方有子节点一方无子节点的情况，再判断两方都有子节点的情况。\n\n- 在diff中，只对同层子节点进行比较放弃跨级的节点比较，使得时间复杂度从O(N^3)转化为O(N)。\n\n## React\n\n### 对React的理解\n\n- React是一个网页UI框架，通过组件化方式解决视图层开发复用问题，本质上是一个组件化框架，它的核心设计思路分别是声明式、组件化和通用性。声明式优势在于直观与组合，组件化的优势在于视图的拆分与模块复用，可以更容易做到高内聚低耦合，通用性在于一次学习随处编写。\n\n## Http和浏览器\n\n### 浏览器架构演变\n\n- 一开始浏览器是单进程的，里面有很多线程比如说网络线程、页面线程等\n\n- 后来变成了多进程浏览器，进程之间相互隔离提高了性能。Chrome浏览器有一个浏览器主进程、一个GPU进程、一个网络进程、多个渲染进程和多个插件进程。\n\n### 进程和线程\n\n- 进程（process）是CPU资源分配的最小单位（是能拥有资源和独立运行的最小单位）\n\n- 线程（thread）是CPU调度的最小单位（是建立在进程基础的一次程序运行单位）\n\n### HTTP的几种请求\n\n- GET方法：发送请求获取服务器资源\n\n- POST方法：提交服务器某数据\n\n- PUT方法：PUT和POST不同的是，它制定了资源在服务器上的位置。\n\n- DELETE方法：删除服务器上某数据\n\n- OPTIONS方法，获取当前URL支持的所有方法。\n\n### HTTP状态码及其含义\n\n- 1XX：信息状态码。比如100表示继续，一般发送post请求时回返回该码。\n\n- 2XX：成功状态码。\n\n- 3XX：重定向。\n\n- 4XX：客户端错误。\n\n- 5XX：服务端错误。\n\n### HTTP版本\n\n- HTTP/0.9是个简单的文本协议，只能获取文本资源。只有一个命令GET。\n\n- HTTP/1.0确定了大部分现在的实用技术，设立请求/响应报文的头部字段，但它不是正是标准。除了GET命令外还引入了POST和HEAD命令。请求消息中URL并没有传递主机名。\n\n- HTTP/1.1是目前互联网上使用最广泛的协议，功能也非常完善，建立了长连接进行服用，对于TCP和HTTP的长连接。引入管道机制，即在同一个TCP连接中，客户端可以同时发送多个请求。HTTP请求头部信息增加了很多字段。新增了很多请求方法比如PUT、DELETE等。\n\n- HTTP/2基于Google的SPDY协议，注重性能改善，但未普及。头部压缩、多路复用等。\n\n- HTTP/3基于Google的QUIC协议，是将来的发展方向。\n\n### HTTP之URL\n\n- URL是用来唯一标记服务器上资源的一个字符串。\n\n- scheme :// host:port path ?query\n\n- scheme是协议名\n\n- host:port是资源所在服务器主机号和端口号\n\n- path标记资源所在的位置/\n\n- query为对资源附加额外要求\n\n### HTTP分层\n\n- OSI分为七层，分别是物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。\n\n- TCP/IP分为四层，分别是链接层，网络层，传输层和应用层。\n\n- 在网络层实现IP协议，在传输层实现TCP/UDP协议，在应用层实现HTTP等协议。\n\n### HTTP优缺点\n\n- 优点：灵活可扩展、请求-应答模式、可靠传输。\n\n- 缺点：无状态、明文传输、队头阻塞：当http开启长连接时，公用一个TCP连接，当某个请求时间过长，其他的请求只能处于阻塞状态。\n\n### HTTP和HTTPS的区别\n\n- HTTPS就是HTTP加上一个SSL或TLS，SSL/TLS协议是TCP和HTTP之间的协议。\n\n- SSL:安全套接层\n\n- TLS:传输层安全\n\n### 从浏览器地址栏输入URL到显示页面的步骤\n\n- 在地址栏中输入URL，首先会在浏览器的缓存中查找是否有对应资源，若有则直接返回给用户，若无则继续发送新的请求。\n\n- 若继续发送新的请求，则根据URL获取对应的域名，端口号等信息，并且组装一个HTTP(GET)请求报文。\n\n- 还需要获取服务端的IP地址，可以依次从浏览器的缓存、本机缓存、hosts文件、路由器缓存、DNS缓存中查找，若缓存中都没有就会从DNS服务器查找ip地址。\n\n- 此时先建立TCP连接，需要实现三次握手。\n\n- TCP链接建立后就发送之前已经组装的HTTP请求报文给服务器。\n\n- 服务器受到请求后会返回对应的数据给客户端，会按情况将资源存进缓存。\n\n- 可以根据情况关闭TCP连接，这时会有四次握手。\n\n- 浏览器收到资源会先进行解码。\n\n- 获得解析资源后第一步先根据html文件构建DOM树，根据CSS文件构建CSSOM树，两个数结合构建渲染树。\n\n- 解析中途遇到其他资源比如js等可以进行下载，之后进行js解析，最后生成页面，并显示在浏览器上。\n\n### DNS\n\n- DNS的工作就是通过域名查询到具体的IP。DNS协议提供的是一种主机名到IP地址的转换服务，通常该协议运行在UDP协议上使用的端口是53端口号。\n\n- 客户端先从浏览器缓存中查找对应IP，若无再查操作系统缓存，若无再找Host文件缓存，若无会直接去DNS跟服务器查询，然后依次传递查询一级域名服务器、二级域名服务器，三级域名服务器最后返回对应的查询结果。递归查询。\n\n### TCP建立连接的三次握手\n\n- 第一次握手：客服端向服务端发送请求报文，其中ACK=0,SYN=1。握手成功服务端知道了客户端具有发送能力。不懈怠数据。\n\n- 第二次握手：服务端返回客服端一个响应报文，其中SYN=1,ACK=1。握手成功客户端直到服务端具有接收和发送能力。不懈怠数据。\n\n- 第三次握手：客服端向服务端发送确认报文，其中SYN=0,ACK=1。握手成功，服务端知道客户端具有接受能力，已经准备好了。可以携带数据。\n\n- 三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。如果没有三次握手，会出现这种现象，客户端发送请求访问报文给服务端，但是这个报文在网络中受阻延迟没有及时传达到，而超时后客户端会再次发送请求报文给服务端，此时服务端就会收到并且要处理先后两条请求报文，有了三次握手，客户端会忽略服务器发送的第二条响应请求报文，不会进行第三次握手。三次握手的主要目的是为了确认双方发送和接受能力是否正常。三次握手是因为二次握手后，服务器还没有确定客户端是否准备好。\n\n### TCP释放连接的四次挥手\n\n- 第一次挥手：客户端向服务端发送释放请求报文，其中FIN=1\n\n- 第二次挥手：TCP处于半关闭状态，客户端无法再发送报文给服务端，服务端可以向客户端发送服务器端发送还未传送完毕的数据。\n\n- 第三次挥手：服务端向客户端发送释放报文，FIN=1\n\n- 第四次挥手：客户端向服务端发送确认报文，等待2MSL后释放应用。服务端收到确认报文后释放应用。\n\n- 客户端发送释放报文后，TCP处于半关闭状态，这个状态能让服务端继续发送未传送完毕的数据，数据传完后，服务器会发送释放报文。\n\n### UDP和TCP的区别\n\n- TCP协议再传送数据段时要给段标号，UDP不用。\n\n- TCP可靠，UDP不可靠。\n\n- TCP速度慢，UDP速度快。\n\n- TCP面向连接，UDP面向非连接。\n\n- TCP应用于传输大量数据，UDP应用于传输少量数据。\n\n### 如何进行网站性能优化\n\n- 减少http请求，对资源进行压缩，使用link代替@import，删除不必要的代码等。\n\n### 对于浏览器内核的理解\n\n- 浏览器主要分为两个部分，渲染引擎和JS引擎，前者主要负责网页内容的渲染工作，后者主要负责解析和指向js文件。浏览器内核主要倾向于指渲染引擎\n\n- Trident内核（IE、360、搜狗等浏览器）\n\n- Webkit内核（Safari、Chrome浏览器等）\n\n### 请描述cookies、sessionStorage和localStorage的区别\n\n- cookie是网站为了标示用户身份而存储在客户端上的数据，cookie数据始终在同源的http请求中携带，会在浏览器和服务器中来回传递。\n\n- sessionStorage和localStorage不会自动把数据发给服务器，仅保存在本地。\n\n- 在存储大小上：cookie数据大小不超过4K，sessionStorage和localStorage可以达到5M或更大。\n\n- 在有效时间上，localStorage存储持久数据，浏览器关闭后数据不会丢失除非主动删除，sessionStorage在浏览器窗口关闭就会自动删除，cookie数据在其设置的过期时间之前一直有效，即使浏览器关闭。\n\n### 渲染优化\n\n- 少使用gif图片实现loading效果（降低CPU消耗）、使用CSS3代码代替JS动画（尽量避免重绘重排）、对于一些小图标，使用base64编码代替网络连接以减少网络请求等。\n\n### 为什么利用多个域名来存储网站资源会更有效\n\n- 节约主域名的连接数，优化页面响应速度\n\n### 优化图片加载的方法\n\n- 如果是幻灯片、相册等可以使用图片预加载技术，优先下载当前图片前后的图片；如果图片是css图片可以采用CSSsprite以减少网络请求\n\n### web开发中会话跟踪的方法\n\n- 使用cookie\n\n- url重写\n\n### HTTP request报文结构是怎样的\n\n- 首行是Request-Line包括请求方法、请求URL、协议版本。之后是请求头，包括很多词组信息、之后是请求体。\n\n### HTTPresponse报文结构是怎样的\n\n- 首行是状态行包括HTTP版本、状态码、状态描述。之后是响应头，再之后是响应体。\n\n### git fetch和git pull的区别\n\n- git pull相当于是从远程获取最新版本并merge到本地，`git fetch`相当于是从远程获取最新版本到本地，不会自动Merge。\n\n### 跨域方案\n\n- 所有方案都是为了搞定同源政策，比如ifram、script、图片ping\n\n### XSS和CSRF\n\n- CSS攻击就是攻击者想尽一切办法将可以执行的代码注入到网页中。可以分为持久型和非持久型，前者是攻击的代码被服务器端写入数据库，后者是通过修改URL参数的方式加入攻击代码。防范方法是不该信任任何用户的输入，对用户输入进行排查筛选。\n\n- CSRF攻击是跨站请求伪造，简单说就是诱惑用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。防范方法是组织第三方网站请求接口，不让第三方网站访问到用户Cookie。\n\n## 算法和编程\n\n### 数组\n\n- 初始化数组 `const arr= new Array(7)`；简单填充数组 `const arr=(new Array(7)).fill(1)`。\n\n- 数组的遍历 for方法、forEach方法、map方法\n\n### 二叉树\n\n- 二叉树的遍历：先序遍历（根左右）、中序遍历（左根右）、后序遍历（左右根）\n\n## 综合\n\n### WebPack\n\n- 一个模块打包器，能将多个js文件合成一个，增加文档解析效率。\n\n### 重构\n\n- 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，也就是说在不改变UI的情况下对网站进行优化。\n\n- 比如针对SEO进行优化、表格table布局改DIV+CSS、升级第三方依赖、加入响应式布局、使用HTML5、CSS3、ES6新特性等。\n\n### 什么样的前端代码是好的\n\n- 高复用低耦合、遵循设计模式六大原则等。\n\n### 前端工程师这个职业\n\n- 前端是最贴近用户的程序员，比后端、数据库、产品经历、运营都要近。\n\n- 前端工程的价值体现在为简化用户使用提供技术支持、为多个浏览器兼容性提供支持、为提高用户浏览速度提供支持等。\n\n### 平时如何管理你的项目\n\n- 先确定好全局样式、公共脚本\n\n- 杨哥要求代码注释\n\n- 严格要求静态资源存放路径\n\n- Git提交必须填写说明\n\n### web前端开发注意事项\n\n- 多机型、多尺寸、多系统覆盖测试\n\n## 人文相关\n\n### 如何简单全面自我介绍\n\n- 我叫邵美芝，来自浙大城市学院软件工程专业。虽然我主修的方向是大数据和人工智能方向，但是一直以来对软件开发也有浓厚的兴趣。大二的暑假我开始自学微信小程序的前端开发，并且和同学一起申请了一个创新创业项目，我们开发的产品名称叫做“基于传感器技术的智能植物养护系统”，我主要负责的是前端微信小程序开发以及AI花卉识别技术的实现。该项目最后也获得了省级创新创业大赛铜奖，之后我负责编写软著申请材料并且成功申请到了两篇软著，并且也成功发表了两篇论文，其中我为第一作者发表的技术类论文发表在了《计算机时代》这个期刊中。在之后在大三暑假需要实习的时候，我被老师介绍进她的合办公司进行前端开发工作，也因此学习到了除了微信小程序之外的技术，包括vue、un-app技术，并且都运用在了实际开发中。在今年的寒假我也在主动学习React技术。\n\n### 对未来三到五年的规划\n\n- 我知道自己现在的能力相对比较薄弱，所以在未来的一到二年中，我觉得以学习为主是最重要的，我希望在前两年里能够在团队里\n\n### 你的优缺点是什么\n\n- 关于优点，我曾经在学校项目和课程中多次担任小组组长，自认为具有担当力和执行力，有较好的任务规划能力，也能努力脚踏实地地完成自己的任务。\n\n- 关于缺点，我不是一个活泼好动的人，做事比较内敛，很多事情喜欢自己先去琢磨和专研，直到实在无能为力才会寻求他人帮助，这样使得自己有时候会缺少和别人及时沟通而减缓了工作的效率。\n\n### 这份工作能带给你什么\n\n微信小程序复习\n\nwx:if view bindtap image src data-* {{}} wx.showToast this.setData\n\nwx.navigateTo({url:'...'}) wx.reLauch({}) 为什么要有key wx.request\n\nkey有什么作用\n\n账号加密处理  使用MD5加密\n\n网络请求包装\n\n```\nvar util=require('../utils/util.js')\nvar requestHandler={\nurl:'',\nmethod:'',\nparams:{},\nsuccess:function(res){\n},\nfail:function(res){\n},\n}\nvar app=getApp()\nfunction GET(requestHandler){\nrequest(\"GET\",requestHandler)}\nfunction POST(requestHandler){\nrequest(\"POST\",requestHandler)}\nfunction request(method,requestHandler){\nvar ARI_URL=requestHandler.url;\nvar params=requestHandler.params;\nwx.request({\nurl:API_URL,\ndata:params,\nmethod:method,\nheader:{},\nsuccess:function(res){\nrequestHandler.success(res)\n}\nfail:function(res){\nrequestHandler.fail(res)\n}\n})\n}\nmodule.exports={\nGET:GET,\nPOST:POST}\n```\n\n“一耕 GAP”农事记载平台2.0\n\n这是一款面向农户的良好农产品认证以及农产品管理平台。它有两大模块，面向农户的用户模式和面向农科院相关人员的管理员模式。\n\n用户模式主要有两大功能，第一就是农户为自己的产品申请良好农产品认证，需要用户填写包括自己的基本信息，生存产品的基本信息以及相关证明材料。第二就是当认证通过后用户能够为自己申请的产品进行相关管理，总共分为好几大模块，包括种植管理、农场基础信息管理、环境管理、畜牧管理、员工管理等。拥有不同产品的不同农户的农事管理页面也不相同，会根据农户的产品进行对应调配。\n\n管理员模式其实主要是在web端进行的，主要进行的是对农户申请认证信息的审核、以及农户管理产品信息等情况，但是根据甲方需求需要在移动端也增加一个简易版本的管理模块，所以微信小程序上也有了管理员模块。主要有主体信息管理和农事记录管理模块，主体信息管理就是争对每个农户以及他的整体产业的管理、农事记录管理是针对每一次农户记录在案的农事操作比如灌溉、播种等操作记录的管理。具体包括搜索、筛选、查看详情等操作。\n\n遇到过哪些问题\n\n原生组件不能满足需求，只能自己创建组件（picker组件只能支持三列选择，自己创建了五列选择）\n\n以及甲方一些需求，比如说管理端和用户端使用同一个微信小程序但是两个界面的底部导航条就是不一样的，所以就只能将四张页面集中写在一个page上来解决问题。\n\nvue\n\nelement-ui v-if v-model @click : v-for=\"(item,index) in list\"\n\n浙江省农科院样品管理系统\n\n这是一款面对浙江省农科院成员的平台，主要作用是线上管理农科院里的样品。主要包括三大模块，分别是被试物管理、对照物管理、参照物和标准物管理，其实这三个管理的流程是基本一致的。用户成员主要分为普通成员和样品管理员，当有新的样品进入农科院时，样品管理员就能在该平台上登记添加新的样品信息并依次分批使其入库，普通成员能够申请库中还有的样品，当样品管理员通过申请时普通成员就能使用该样品，最后使用完后普通成员需要申请样品归还，样品管理员审核归还的样品信息后会将归还的样品再次入库，最后样品管理员有权利作废样品。\n\n遇到过哪些问题\n\n这个项目只需要清楚业务逻辑就没有很大的问题，所以没有遇到什么比较困难的问题，一直都是根据甲方的需求更改一些功能和细节。比方说甲方希望能够有缓存功能就不用每次都输入很长的样品名称于是就设置了localStorage，甲方说直接在申请页面就能归还就在申请页面也增加了归还的接口等一些小细节问题。\n","slug":"前端相关问题","published":1,"date":"2022-02-23T04:46:32.535Z","updated":"2022-03-17T10:26:21.295Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl16bbh44003o6wtvgfgservo"}],"PostAsset":[],"PostCategory":[{"post_id":"cl16bbh0y000b6wtvhhirhhfc","category_id":"cl16bbh0s00066wtv2vkq69a0","_id":"cl16bbh1a000j6wtv2kxxhc9j"},{"post_id":"cl16bbh0o00036wtv13wqgu9r","category_id":"cl16bbh0s00066wtv2vkq69a0","_id":"cl16bbh1e000n6wtv794db161"},{"post_id":"cl16bbh11000d6wtvh5510ktc","category_id":"cl16bbh0s00066wtv2vkq69a0","_id":"cl16bbh1g000q6wtv0bhgcmpo"},{"post_id":"cl16bbh0r00056wtv6514a7zh","category_id":"cl16bbh0s00066wtv2vkq69a0","_id":"cl16bbh1j000v6wtv96ea72wx"},{"post_id":"cl16bbh0w00096wtv2k9x39vf","category_id":"cl16bbh1a000k6wtv52dhaqch","_id":"cl16bbh1l000x6wtv672u78qt"},{"post_id":"cl16bbh15000h6wtvfhvl888c","category_id":"cl16bbh1g000s6wtve8u87683","_id":"cl16bbh1r00156wtv7h9aaw5a"},{"post_id":"cl16bbh1n00106wtv3a32acbv","category_id":"cl16bbh1m000z6wtvfj1hfcc9","_id":"cl16bbh1u00196wtvge7zemej"},{"post_id":"cl16bbh1d000m6wtv9rn74dd6","category_id":"cl16bbh1m000z6wtvfj1hfcc9","_id":"cl16bbh1x001d6wtv1kk76s3x"},{"post_id":"cl16bbh1p00126wtv7bgb2fd8","category_id":"cl16bbh1m000z6wtvfj1hfcc9","_id":"cl16bbh23001g6wtv7zegbu9y"},{"post_id":"cl16bbh1r00176wtv6lrd49x3","category_id":"cl16bbh1m000z6wtvfj1hfcc9","_id":"cl16bbh28001l6wtv4t5ib413"},{"post_id":"cl16bbh1f000p6wtv345sgwil","category_id":"cl16bbh1m000z6wtvfj1hfcc9","_id":"cl16bbh2b001o6wtvcyj06k86"},{"post_id":"cl16bbh1t00186wtvfxoi69od","category_id":"cl16bbh1a000k6wtv52dhaqch","_id":"cl16bbh2g001t6wtv586ffsty"},{"post_id":"cl16bbh1i000u6wtvd6atev5j","category_id":"cl16bbh1m000z6wtvfj1hfcc9","_id":"cl16bbh2j001w6wtv0oegazac"},{"post_id":"cl16bbh1y001f6wtvh70ean62","category_id":"cl16bbh1a000k6wtv52dhaqch","_id":"cl16bbh2n00206wtv9pzycgok"},{"post_id":"cl16bbh26001k6wtvcrwu9vfc","category_id":"cl16bbh1a000k6wtv52dhaqch","_id":"cl16bbh2o00216wtv40fi4xz3"},{"post_id":"cl16bbh1k000w6wtvgegz6yr8","category_id":"cl16bbh1m000z6wtvfj1hfcc9","_id":"cl16bbh2p00226wtvflky2c77"},{"post_id":"cl16bbh2e001s6wtv2et17vjz","category_id":"cl16bbh1g000s6wtve8u87683","_id":"cl16bbh2q00246wtvf0wx2ati"},{"post_id":"cl16bbh1w001c6wtv9i493ior","category_id":"cl16bbh2d001r6wtvdwg86r89","_id":"cl16bbh2q00256wtvc0ip6znx"},{"post_id":"cl16bbh3800346wtv2n86hvgi","category_id":"cl16bbh1a000k6wtv52dhaqch","_id":"cl16bbh3a00386wtv6tyr983o"},{"post_id":"cl16bbh3800356wtv941idi29","category_id":"cl16bbh1a000k6wtv52dhaqch","_id":"cl16bbh3a003a6wtv6ileepza"},{"post_id":"cl16bbh3900376wtv30je2diy","category_id":"cl16bbh1g000s6wtve8u87683","_id":"cl16bbh3b003d6wtv3l3v9e5d"},{"post_id":"cl16bbh3d003k6wtvfsr8gxzy","category_id":"cl16bbh1g000s6wtve8u87683","_id":"cl16bbh3s003n6wtvcg2uhv8i"}],"PostTag":[{"post_id":"cl16bbh0o00036wtv13wqgu9r","tag_id":"cl16bbh0u00076wtvhe2s0h2q","_id":"cl16bbh1e000o6wtvdrx9b8n0"},{"post_id":"cl16bbh0o00036wtv13wqgu9r","tag_id":"cl16bbh12000f6wtvdbaqf79s","_id":"cl16bbh1g000r6wtv8wyb6bi0"},{"post_id":"cl16bbh0r00056wtv6514a7zh","tag_id":"cl16bbh0u00076wtvhe2s0h2q","_id":"cl16bbh1o00116wtv8sy3hxup"},{"post_id":"cl16bbh0r00056wtv6514a7zh","tag_id":"cl16bbh12000f6wtvdbaqf79s","_id":"cl16bbh1q00136wtvd8mu5u7g"},{"post_id":"cl16bbh0w00096wtv2k9x39vf","tag_id":"cl16bbh12000f6wtvdbaqf79s","_id":"cl16bbh1y001e6wtv08snbkbc"},{"post_id":"cl16bbh0w00096wtv2k9x39vf","tag_id":"cl16bbh1q00146wtv5pqf88z1","_id":"cl16bbh24001h6wtvfjbz0kn0"},{"post_id":"cl16bbh0y000b6wtvhhirhhfc","tag_id":"cl16bbh0u00076wtvhe2s0h2q","_id":"cl16bbh29001m6wtve8yd9zw5"},{"post_id":"cl16bbh0y000b6wtvhhirhhfc","tag_id":"cl16bbh12000f6wtvdbaqf79s","_id":"cl16bbh2c001p6wtvehrzgd7u"},{"post_id":"cl16bbh11000d6wtvh5510ktc","tag_id":"cl16bbh0u00076wtvhe2s0h2q","_id":"cl16bbh2h001u6wtvb05udyn4"},{"post_id":"cl16bbh11000d6wtvh5510ktc","tag_id":"cl16bbh12000f6wtvdbaqf79s","_id":"cl16bbh2k001x6wtvcqnm8cz0"},{"post_id":"cl16bbh15000h6wtvfhvl888c","tag_id":"cl16bbh2d001q6wtv3x5d6252","_id":"cl16bbh2r00276wtv8joq7mbh"},{"post_id":"cl16bbh15000h6wtvfhvl888c","tag_id":"cl16bbh2l001y6wtvbwthfjus","_id":"cl16bbh2r00286wtv9b3o6d6r"},{"post_id":"cl16bbh15000h6wtvfhvl888c","tag_id":"cl16bbh2p00236wtv14bp974g","_id":"cl16bbh2s002a6wtvbta06oqc"},{"post_id":"cl16bbh1d000m6wtv9rn74dd6","tag_id":"cl16bbh2q00266wtva141fzsy","_id":"cl16bbh2t002b6wtvdnjm9ewu"},{"post_id":"cl16bbh1f000p6wtv345sgwil","tag_id":"cl16bbh2q00266wtva141fzsy","_id":"cl16bbh2u002d6wtv0yzf0y3c"},{"post_id":"cl16bbh1i000u6wtvd6atev5j","tag_id":"cl16bbh2q00266wtva141fzsy","_id":"cl16bbh2v002f6wtv8sru6j3s"},{"post_id":"cl16bbh1k000w6wtvgegz6yr8","tag_id":"cl16bbh2q00266wtva141fzsy","_id":"cl16bbh2w002h6wtvdui2g2kb"},{"post_id":"cl16bbh1n00106wtv3a32acbv","tag_id":"cl16bbh2q00266wtva141fzsy","_id":"cl16bbh2x002j6wtv0rd09l35"},{"post_id":"cl16bbh1p00126wtv7bgb2fd8","tag_id":"cl16bbh2q00266wtva141fzsy","_id":"cl16bbh2z002l6wtvgbq69qqs"},{"post_id":"cl16bbh1r00176wtv6lrd49x3","tag_id":"cl16bbh2q00266wtva141fzsy","_id":"cl16bbh30002n6wtvd3swcgm8"},{"post_id":"cl16bbh1t00186wtvfxoi69od","tag_id":"cl16bbh12000f6wtvdbaqf79s","_id":"cl16bbh31002p6wtv95o37hy8"},{"post_id":"cl16bbh1t00186wtvfxoi69od","tag_id":"cl16bbh2z002m6wtv1spf3a03","_id":"cl16bbh31002q6wtv1oxj5bc3"},{"post_id":"cl16bbh1w001c6wtv9i493ior","tag_id":"cl16bbh30002o6wtv5fkig5uw","_id":"cl16bbh31002s6wtvgr3d62gl"},{"post_id":"cl16bbh1w001c6wtv9i493ior","tag_id":"cl16bbh12000f6wtvdbaqf79s","_id":"cl16bbh32002t6wtv1a350s7n"},{"post_id":"cl16bbh1y001f6wtvh70ean62","tag_id":"cl16bbh12000f6wtvdbaqf79s","_id":"cl16bbh33002v6wtv020kdoxg"},{"post_id":"cl16bbh1y001f6wtvh70ean62","tag_id":"cl16bbh31002r6wtv8j02e4e0","_id":"cl16bbh33002w6wtv07411t14"},{"post_id":"cl16bbh26001k6wtvcrwu9vfc","tag_id":"cl16bbh12000f6wtvdbaqf79s","_id":"cl16bbh34002y6wtvhlewgysn"},{"post_id":"cl16bbh26001k6wtvcrwu9vfc","tag_id":"cl16bbh32002u6wtvbs42h5gy","_id":"cl16bbh34002z6wtv5hjj5xnp"},{"post_id":"cl16bbh2e001s6wtv2et17vjz","tag_id":"cl16bbh2p00236wtv14bp974g","_id":"cl16bbh3500316wtv9022ah09"},{"post_id":"cl16bbh2e001s6wtv2et17vjz","tag_id":"cl16bbh2d001q6wtv3x5d6252","_id":"cl16bbh3500326wtv4v1633lf"},{"post_id":"cl16bbh2m001z6wtv9zvu8kqk","tag_id":"cl16bbh2q00266wtva141fzsy","_id":"cl16bbh3500336wtv3wl6bjv0"},{"post_id":"cl16bbh3900376wtv30je2diy","tag_id":"cl16bbh2d001q6wtv3x5d6252","_id":"cl16bbh3a00396wtv04yscpuh"},{"post_id":"cl16bbh3900376wtv30je2diy","tag_id":"cl16bbh2l001y6wtvbwthfjus","_id":"cl16bbh3b003c6wtvbrhq8ie4"},{"post_id":"cl16bbh3900376wtv30je2diy","tag_id":"cl16bbh2p00236wtv14bp974g","_id":"cl16bbh3b003e6wtvhfztfxix"},{"post_id":"cl16bbh3800346wtv2n86hvgi","tag_id":"cl16bbh3900366wtv49o39ipd","_id":"cl16bbh3b003f6wtv2dnf4y98"},{"post_id":"cl16bbh3800346wtv2n86hvgi","tag_id":"cl16bbh12000f6wtvdbaqf79s","_id":"cl16bbh3b003g6wtvgs9yhc1t"},{"post_id":"cl16bbh3800346wtv2n86hvgi","tag_id":"cl16bbh2p00236wtv14bp974g","_id":"cl16bbh3b003h6wtvba4w1p7t"},{"post_id":"cl16bbh3800356wtv941idi29","tag_id":"cl16bbh12000f6wtvdbaqf79s","_id":"cl16bbh3c003i6wtvhlgr0y2y"},{"post_id":"cl16bbh3800356wtv941idi29","tag_id":"cl16bbh3b003b6wtvee9z2464","_id":"cl16bbh3c003j6wtv3ac0bj0t"},{"post_id":"cl16bbh3d003k6wtvfsr8gxzy","tag_id":"cl16bbh2p00236wtv14bp974g","_id":"cl16bbh3e003l6wtv31569fm8"},{"post_id":"cl16bbh3d003k6wtvfsr8gxzy","tag_id":"cl16bbh2d001q6wtv3x5d6252","_id":"cl16bbh3n003m6wtv13l509mw"}],"Tag":[{"name":"React","_id":"cl16bbh0u00076wtvhe2s0h2q"},{"name":"学习","_id":"cl16bbh12000f6wtvdbaqf79s"},{"name":"前端面试，Git","_id":"cl16bbh1q00146wtv5pqf88z1"},{"name":"浏览器","_id":"cl16bbh2d001q6wtv3x5d6252"},{"name":"JavaScript","_id":"cl16bbh2l001y6wtvbwthfjus"},{"name":"前端面试","_id":"cl16bbh2p00236wtv14bp974g"},{"name":"日记","_id":"cl16bbh2q00266wtva141fzsy"},{"name":"前端面试，数据库系统原理","_id":"cl16bbh2z002m6wtv1spf3a03"},{"name":"hexo","_id":"cl16bbh30002o6wtv5fkig5uw"},{"name":"前端面试，操作系统原理","_id":"cl16bbh31002r6wtv8j02e4e0"},{"name":"前端面试，正则表达式","_id":"cl16bbh32002u6wtvbs42h5gy"},{"name":"计算机网络","_id":"cl16bbh3900366wtv49o39ipd"},{"name":"前端面试，面向对象思想","_id":"cl16bbh3b003b6wtvee9z2464"}]}}